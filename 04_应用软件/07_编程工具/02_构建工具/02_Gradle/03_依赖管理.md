# 仓库配置
## 简介
Gradle能够在Maven与Eclipse Ivy仓库中查找并下载工程所依赖的外部组件，因此我们在配置模块的依赖组件前，需要先配置仓库。

## Gradle 6及更低版本
在工程根目录下的 `settings.gradle` 配置文件中， `buildscript{}` 小节用于配置Gradle插件的仓库； `allprojects{}` 小节用于配置所有子模块共用的仓库。

"settings.gradle":

```groovy
// 构建工具的依赖配置
buildscript {
    // 声明Gradle插件仓库
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }

    // 声明插件依赖
    dependencies {
        // Android支持插件
        classpath 'com.android.tools.build:gradle:4.0.0'
        // Kotlin支持插件
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.30"
    }
}

// 所有项目的依赖配置
allprojects {
    // 声明Maven组件仓库
    repositories {
        google()
        mavenCentral()
    }

    // 声明组件依赖
    dependencies {
        // 通常不在此处配置依赖项
    }
}
```

`allprojects{}` 小节中声明的仓库与依赖对所有子模块可用，我们通常只在此声明仓库，而不声明依赖组件，具体的依赖项由各个子模块自行声明。

子模块中的 `build.gradle` 配置文件也可以拥有 `repositories{}` 和 `dependencies{}` 小节，仅对当前模块生效，我们通常在子模块中使用 `dependencies{}` 小节声明依赖项。

## Gradle 7及更高版本
在Gradle 7以及更高版本中，依赖管理相关的配置项发生了变化， `buildscript{}` 小节被替换为 `pluginManagement{}` ； `allprojects{}` 小节被替换为 `dependencyResolutionManagement{}` 。

"settings.gradle":

```groovy
// 构建工具的依赖配置
pluginManagement {
    // 声明Gradle插件仓库
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

// 所有模块的依赖配置
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
```

此时 `pluginManagement{}` 小节仅有插件仓库的配置，插件依赖声明则被移动到 `build.gradle` 配置文件的 `plugins{}` 小节中。

"build.gradle":

```groovy
// Gradle插件版本声明
plugins {
    id 'com.android.application' version '7.1.2' apply false
    id 'com.android.library' version '7.1.2' apply false
    id 'org.jetbrains.kotlin.android' version '1.6.21' apply false
}
```

## 常用仓库
下文将介绍常用公开仓库与自定义仓库的配置方法。

🔶 Maven中心仓库

Maven中心仓库由SonaType公司维护，提供Java与Android的组件，它的官方网页为：

[🧭 Maven中心仓库官方网页](https://central.sonatype.com/) 

该仓库是Gradle的内置仓库，因此我们配置时声明名称即可，无需指明URL。

```groovy
repositories {
    mavenCentral()
}
```

Maven中心仓库是Java开发中最常用的仓库，通常每个项目都会配置。

🔶 Google官方仓库

Google官方Maven仓库由Google公司维护，提供Android相关的官方组件。

该仓库是Gradle的内置仓库，因此我们配置时声明名称即可。

```groovy
repositories {
    google()
}
```

Google官方仓库对于Android工程是必选的；对于非Android工程通常无需配置该仓库。

🔶 JCenter

JCenter仓库由Bintray公司维护，提供Java与Android的非官方组件。

该仓库是Gradle的内置仓库，因此我们配置时声明名称即可。

```groovy
repositories {
    jcenter()
}
```

JCenter仓库目前已经停止维护并清空数据，如果早期创建的工程使用了该仓库，需要将其替换为Maven中心仓库。

🔶 JitPack

JitPack是一个Maven仓库，提供Java与Android的非官方组件，它的官方网页为：

[🧭 JitPack官方网页](https://www.jitpack.io/) 

JitPack不是Gradle的内置仓库，因此我们配置时需要指明它的URL。

```groovy
repositories {
    maven { url 'https://www.jitpack.io' }
}
```

🔶 Maven本地仓库

Maven本地仓库的默认路径为： `<用户主目录>/.m2/repository` ，通常用于调试。

该仓库是Gradle的内置仓库，因此我们配置时声明名称即可。

```groovy
repositories {
    mavenLocal()
}
```

🔶 自定义仓库

自定义Maven仓库是个人或组织自建的仓库，通常不对外部开放，需要通过认证后才能使用。

配置自定义Maven仓库时， `url` 表示仓库地址； `credentials{}` 小节表示认证信息，如果该仓库无需认证，可以省略 `credentials{}` 小节。

```groovy
repositories {
    maven {
        // 指定仓库地址
        url = 'https://repo.example.net/repository/private/'
        // 认证信息
        credentials {
            // 用户名称
            username '<用户名称>'
            // 认证口令
            password '<认证口令>'
        }
    }
}
```

🔶 Gradle社区插件仓库

Gradle社区插件仓库，提供第三方开发的Gradle插件。

该仓库是Gradle的内置仓库，因此我们配置时声明名称即可。

```groovy
repositories {
    gradlePluginPortal()
}
```

<br />

Gradle 7及更高版本默认禁止使用未加密的传输协议，例如HTTP；如果我们要配置这种仓库，应当将 `allowInsecureProtocol` 属性置为"true"。

```groovy
repositories {
    maven {
        // 允许使用非加密的传输协议
        allowInsecureProtocol = true
        // 指定仓库地址
        url = 'http://repo.example.net/repository/private/'
    }
}
```

在后续Gradle版本中该属性不能被直接赋值，我们需要调用 `setAllowInsecureProtocol(true)` 方法进行设置。

## 镜像地址
以下列出了一些中国地区常用的Maven仓库镜像地址，我们可以根据需要在工程全局配置文件中添加它们，以提高访问速度。

```groovy
repositories {
    // 阿里云仓库镜像：Maven中心仓库
    maven { url = "https://maven.aliyun.com/repository/central/" }
    // 阿里云仓库镜像：JCenter
    maven { url = "https://maven.aliyun.com/repository/jcenter/" }
    // 阿里云仓库镜像：Maven中心仓库与JCenter
    maven { url = "https://maven.aliyun.com/repository/public/" }
    // 阿里云仓库镜像：Google
    maven { url = "https://maven.aliyun.com/repository/public/" }
    // 阿里云仓库镜像：Spring
    maven { url = "https://maven.aliyun.com/repository/spring/" }

    // 腾讯云仓库镜像：Maven中心仓库与JCenter
    maven { url = "https://mirrors.cloud.tencent.com/nexus/repository/maven-public/" }

    // 阿里云仓库镜像：Gradle社区插件
    maven { url = "https://maven.aliyun.com/repository/gradle-plugin/" }
    // 阿里云仓库镜像：Spring插件
    maven { url = "https://maven.aliyun.com/repository/spring-plugin/" }
}
```

## 生效顺序
当Gradle查询某个组件时，将会按照仓库列表的顺序检索，若在某个仓库中查询到组件，则下载该项并停止查找；若在某个仓库中没有查询到组件，则在下一个仓库中继续查询，直到所有仓库都查找完毕为止。

当Gradle找到某个组件时，也会优先在当前仓库中查询它所依赖的其他组件；若未查询到某项，则跳转至仓库列表首项，按照前文流程继续查询。

# 声明依赖
## Maven依赖
对于Java或Kotlin工程，我们可以在Gradle中引入Maven组件并调用它们。

以下是一个Maven组件依赖声明示例：

```xml
<dependency>
    <groupId>io.minio</groupId>
    <artifactId>minio</artifactId>
    <version>8.5.7</version>
</dependency>
```

我们需要编辑子模块的 `build.gradle` 配置文件，按照以下规则声明该组件： `<依赖指令> '<GroupID>:<ArtifactID>:<Version>'` 。

"build.gradle":

```groovy
dependencies {
    // 导入Maven依赖（简化写法）
    implementation "io.minio:minio:8.5.7"

    /*
     * 导入Maven依赖（完整写法）
     * 我们通常不使用该写法，而是使用前文的简化写法。
     */
    implementation group: 'io.minio', name: 'minio', version: '8.5.7'
}
```

依赖指令可以控制依赖的传递范围，最常用的指令为 `implementation` ，关于不同依赖指令的区别，详见后文章节： [🧭 依赖指令](#依赖指令) 。

## 本地文件依赖
某些库并不使用在线仓库的形式发布，而是提供"jar"或"aar"等格式的离线包，我们可以将这些文件作为模块的依赖项。

在以下示例工程中，我们在子模块"app"中建立 `libs` 目录放置库文件。

```text
RootProject
├── app
│   ├── libs
│   │   └── minio-8.5.7.jar
│   └── build.gradle
└── build.gradle
```

然后编辑"app"模块的 `build.gradle` 配置文件，通过以下方式声明依赖关系：

"build.gradle":

```groovy
dependencies {
    // 引入指定的库文件（此处名称为"minio-8.5.7.jar"）
    implementation files('libs/minio-8.5.7.jar')

    // 引入"libs"目录下所有名称以".jar"结尾的库文件
    implementation fileTree(dir: 'libs', includes: ['*.jar'])
    // 引入"libs"目录下所有名称以".aar"结尾的库文件
    implementation fileTree(dir: 'libs', includes: ['*.aar'])
    // 引入"libs"目录下所有名称以".jar"或".aar"结尾的库文件
    implementation fileTree(dir: 'libs', includes: ['*.jar', '*.aar'])

    // 引入"libs"目录下所有名称以".jar"结尾的库文件，并排除名称为"minio-8.5.7.jar"的库文件。
    implementation fileTree(dir: 'libs', includes: ['*.jar'], excludes: ['minio-8.5.7.jar'])
}
```

当我们声明文件依赖项时，如果使用相对路径，则参考点为当前模块的根目录，在本示例中即 `RootProject/app/` 。

如果库文件放置在其他位置，我们就需要调整相对路径。在以下工程中，库文件统一放置在 `RootProject/commonlibs/` 目录中。

```text
RootProject
├── app
│   └── build.gradle
├── build.gradle
└── commonlibs
    └── minio-8.5.7.jar
```

此时，若"app"模块需要引用"commonlibs"中的某个库，则路径变更为下文代码块中的形式：

"build.gradle":

```groovy
dependencies {
    // 引入父级目录下"commonlibs"目录中指定的库文件
    implementation files('../commonlibs/minio-8.5.7.jar')
}
```

## 工程依赖
工程中的各个模块之间默认没有依赖关系，因此在代码层面不能相互调用。我们可以为模块配置工程依赖，使其能够调用其他模块中的代码。

作为依赖项的模块可以是当前工程内部的模块，也可以是外部工程的模块，它们必须先在主工程的 `settings.gradle` 配置文件中注册，两种模块的注册方式详见相关章节： [🧭 基础用法 - 模块管理](./02-基础用法.md#模块管理) 。

在以下示例工程中，"app"模块需要调用"base"和"tool"模块中的公共组件。

```text
RootProject
├── app
└── common
    ├── base
    └── tool
```

我们需要编辑"app"模块的 `build.gradle` 配置文件，添加以下依赖项声明语句：

"build.gradle":

```groovy
dependencies {
    implementation project(':common:base')
    implementation project(':common:tool')
}
```

此时"app"模块即可引用"base"和"tool"模块中的类与方法。

## 依赖指令
各种依赖指令的作用与示例如下文所示。

🔷 `implementation`

该指令会使依赖组件参与当前模块的编译、打包至构建产物，但是依赖关系不会传递给当前模块的调用者。

在以下依赖关系示例中，“组件B”使用 `implementation 组件C` 语句声明了对于“组件C”的依赖关系：

```text
组件A -- 依赖于(implementation) -> 组件B -- 依赖于(implementation) -> 组件C
```

此时“组件B”可以调用“组件C”中的代码，但该依赖关系不会传递给“组件A”，因此“组件A”无法调用“组件C”中的代码。

🔷 `api`

该指令会使依赖组件参与当前模块的编译、打包至构建产物，并且依赖关系也会传递给当前模块的调用者。

在以下依赖关系示例中，“组件B”使用 `api 组件C` 语句声明了对于“组件C”的依赖关系：

```text
组件A -- 依赖于(implementation) -> 组件B -- 依赖于(api) -> 组件C
```

此时“组件B”可以调用“组件C”中的代码，该依赖关系会传递给“组件A”，因此“组件A”也可以调用“组件C”中的代码。

由于仅有Library类型模块才会被其他模块作为依赖项引入，所以该指令只能应用在类型为 `java-library` 或 `com.android.library` 的模块中。

🔷 `compileOnly`

该指令会使依赖组件参与当前模块的编译，但不会被打包至构建产物，依赖传递性等同于 `implementation` 指令。

当我们为定制化的Android发行版编写系统级应用程序时，可能需要调用一些特殊的API，这些API在标准的Android SDK中并不存在，或者是隐藏API，直接调用将无法通过编译。此时我们可以将发行版厂商提供的 `framework.jar` 文件作为依赖项，使得程序能够正常编译。由于SDK中的组件在运行时由系统提供， `framework.jar` 中通常只有API的空实现，所以我们需要使用 `compileOnly` 指令，避免将 `framework.jar` 打包至构建产物。

🔷 `runtimeOnly`

该指令所声明的依赖组件不会参与当前模块的编译，但是会被打包至构建产物，依赖传递性等同于 `implementation` 指令。

该指令的作用是实现模块间的解耦，我们在模块中无法直接引用依赖组件中的代码，只能调用模块与依赖组件的公共接口，或者通过反射操作，提高了程序的动态性。

当程序编译时只需要使用JDBC的标准API，并不关心JDBC驱动的具体实现，此时我们就可以使用 `runtimeOnly` 指令配置JDBC驱动依赖项。

🔷 `annotationProcessor`

APT(Annotation Processing Tool)用于扫描并处理代码中的注解，并自动生成相关代码。

AnnotationProcessor是Gradle内置的Java语言APT，当我们使用一些第三方库定义注解时，就需要使用 `annotationProcessor` 指令添加注解处理器，使得编译器能够处理这些注解。

以Android中的Room库为例，我们需要使用 `implementation` 指令声明组件依赖，并使用 `annotationProcessor` 指令声明对应的注解处理器。

```groovy
dependencies {
    // 声明组件依赖
    implementation 'androidx.room:room-runtime:2.6.1'
    // 声明注解处理器
    annotationProcessor 'androidx.room:room-compiler:2.6.1'
}
```

注解处理器的名称可以参考第三方库的说明文档。

🔷 `kapt`

KAPT是Kotlin语言的注解处理器，Kotlin编译器并不能识别 `annotationProcessor` 指令，当我们为项目添加Kotlin语言支持后，需要将 `annotationProcessor` 指令全部替换为 `kapt` 指令。

```groovy
plugins {
    // 为当前模块添加KAPT支持
    id 'kotlin-kapt'
}

dependencies {
    implementation 'androidx.room:room-runtime:2.6.1'
    // 将AnnotationProcessor替换为KAPT
    kapt 'androidx.room:room-compiler:2.6.1'
}
```

# 查看依赖
我们可以使用 `gradle <模块名称>:dependencies` 命令查看指定模块的依赖关系，该命令会递归解析每个依赖项的依赖组件，并显示在控制台上，以便我们进行调试与排错。

为了减少输入内容便于演示，我们仅为"app"模块添加一个依赖项。

```groovy
dependencies {
    implementation "com.squareup.okhttp3:okhttp:4.12.0"
}
```

此时执行依赖查看命令，即可得到以下信息。

```text
# 查看"app"模块的依赖关系
[root@Fedora ~]# ./gradlew app:dependencies

# 此处省略部分输出内容...

compileClasspath - Compile classpath for source set 'main'.
\--- com.squareup.okhttp3:okhttp:4.12.0
     +--- com.squareup.okio:okio:3.6.0
     |    \--- com.squareup.okio:okio-jvm:3.6.0
     |         +--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10
     |         |    +--- org.jetbrains.kotlin:kotlin-stdlib:1.9.10
     |         |    |    +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.9.10
     |         |    |    \--- org.jetbrains:annotations:13.0
     |         |    \--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.9.10
     |         |         \--- org.jetbrains.kotlin:kotlin-stdlib:1.9.10 (*)
     |         \--- org.jetbrains.kotlin:kotlin-stdlib-common:1.9.10
     \--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.21 -> 1.9.10 (*)

# 此处省略部分输出内容...
```

在上述输出内容中， `compileClasspath` 小节即为当前模块编译阶段的依赖关系树，与其类似的还有 `runtimeClasspath` 、 `testCompileClasspath` 、 `testRuntimeClasspath` 等小节，我们可以根据需要选择并查看。

我们可以在命令中添加"--configuration"选项，筛选指定阶段的内容，减少输入内容。

```text
# 查看"app"模块编译阶段的依赖关系
[root@Fedora ~]# ./gradlew app:dependencies --configuration compileClasspath
```

# 依赖冲突
## 简介
当我们为模块配置多个依赖项后，这些依赖项可能依赖于同一个组件的不同版本，此时就有可能产生冲突，导致无法编译。

此处我们创建一个示例工程，演示依赖冲突的情况，工程结构如下文代码块所示：

```text
RootProject
├── app（依赖"library01"和"library02"）
├── library01（依赖于GSON v2.9.0）
└── library02（依赖于GSON v2.9.1）
```

在上述示例工程中，"app"模块依赖于"library01"和"library02"模块，而"library01"和"library02"模块依赖于不同版本的GSON库，此时就会产生冲突。

## 默认策略
当Gradle解析到同一组件的多个版本时，默认行为是选择其中版本号最大的一项。

```text
# 查看"app"模块的依赖关系
[root@Fedora ~]# ./gradlew app:dependencies --configuration runtimeClasspath

runtimeClasspath - Runtime classpath of source set 'main'.
+--- project :library01
|    \--- com.google.code.gson:gson:2.9.0 -> 2.9.1
\--- project :library02
     \--- com.google.code.gson:gson:2.9.1

# 此处省略部分输出内容...
```

从上述输出信息可知，"library01"所依赖的GSON版本号"2.9.0"低于"library02"的"2.9.1"，因此被改写为"2.9.1"。

默认策略能够解决大多数依赖冲突的情况，但有时无法奏效，例如：某个模块调用了较低版本组件中的类，而在较高版本组件中该类已被移除；当Gradle改写版本后，该模块就会因找不到类而无法通过编译。出现此类情况时，我们就需要选择后文的方式手动解决冲突。

## 排除依赖组件
为了模拟依赖冲突的情况，我们可以在工程根目录的 `build.gradle` 文件中添加以下配置，禁用默认策略，改为报错并终止操作。

"build.gradle":

```groovy
configurations.all {
    resolutionStrategy {
        // 禁用默认的依赖冲突策略，而是报错终止。
        failOnVersionConflict()
    }
}
```

此时我们再执行Gradle命令，查看"app"模块的依赖关系。

```text
# 查看"app"模块的依赖关系
[root@Fedora ~]# ./gradlew app:dependencies

Execution failed for task ':dependencies'.
> Could not resolve all dependencies for configuration ':runtimeClasspath'.
   > Conflict(s) found for the following module(s):
       - com.google.code.gson:gson between versions 2.9.1 and 2.9.0

# 此处省略部分输出内容...
```

从上述输出信息可知，GSON组件的版本出现了冲突，导致无法执行后续任务。

我们在声明依赖项时，可以使用 `exclude` 指令排除指定的组件，阻止其通过依赖树传递给其他模块。

以前文工程为例，我们可以修改"app"模块的依赖配置，将版本号较高的GSON组件("2.9.1")排除。

"build.gradle":

```groovy
dependencies {
    implementation project(':library01')
    implementation(project(':library02')) {
        // 排除该模块传递的GSON依赖
        exclude group: 'com.google.code.gson', module: 'gson'
    }
}
```

此时"app"模块只会解析到"library01"传递的GSON版本"2.9.0"，而"library02"传递的GSON依赖项被屏蔽了，冲突得以解决。

如果我们需要排除某个Group下的所有组件，可以只书写 `exclude group: <GroupID>` ，省略 `module` 部分。

## 指定组件版本
我们可以在 `resolutionStrategy{}` 小节中使用 `force` 指令指定某个组件的版本，该配置会覆盖所有依赖传递的组件版本。

"build.gradle":

```groovy
configurations.all {
    resolutionStrategy {
        // 禁用默认的依赖冲突策略，而是报错终止。
        failOnVersionConflict()
        // 指定GSON组件的版本
        force 'com.google.code.gson:gson:2.10.1'
    }
}
```

此时"app"模块应用的GSON版本为"2.10.1"，"library01"和"library02"所传递的GSON版本均不生效。

# 统一版本管理
## 背景
当单一工程中有许多模块、或主工程包括多个子工程时，单独维护每个模块的依赖版本将会变得十分困难。如果我们希望升级某个组件，就要人工寻找每一处涉及该组件的声明语句，并修改其中的版本号；这些操作比较繁琐，并且容易遗漏和出错。

为了解决上述问题，我们可以通过一些方法，统一定义依赖组件名称与版本，并在各个模块中引用。当我们希望升级组件时，只需修改定义组件的一处配置，即可更新所有子模块的依赖版本。

## "ext"属性
### 简介
Gradle脚本中的 `ext{}` 块能够用来定义全局变量，因此我们可以在 `ext{}` 块中定义组件名称与版本，然后在子模块的依赖声明语句中调用它们。

这种方式的缺点是：IDE无法识别 `ext{}` 块中的全局变量，因此书写依赖声明的过程中没有代码提示，使用鼠标点击声明语句也无法跳转到定义变量的文件中，对使用者不够友好。

这种方式适用于Gradle 7.4.1之前的版本，对于使用Gradle 7.4.1及更高版本的工程，我们建议使用Version Catalog进行版本管理，详见后文章节： [🧭 Version Catalog](#version-catalog) 。

### 基本应用
我们首先在工程根目录下创建一个 `deps.gradle` 文件，并在 `ext{}` 块中定义若干全局变量，描述组件名称与版本信息。

"deps.gradle":

```groovy
/* 定义依赖组件的版本 */
ext {
    /* Android依赖 */
    android = [
            "appcompat" : "androidx.appcompat:appcompat:1.5.0",
            "material"  : "com.google.android.material:material:1.8.0"
    ]

    /* 第三方依赖 */
    thirdparty = [
            "gson" : "com.google.code.gson:gson:2.10.1"
    ]
}
```

接着在工程根目录配置文件 `build.gradle` 的任意位置导入 `deps.gradle` 文件。

"build.gradle":

```groovy
// 导入依赖配置文件
apply from: 'deps.gradle'
```

此时我们便可以在子模块的依赖声明语句中引用 `deps.gradle` 文件定义的变量。

"build.gradle":

```groovy
// 引用根工程"ext"块中的变量
dependencies {
    implementation this.rootProject.ext.android.appcompat
    implementation this.rootProject.ext.android.material
    implementation this.rootProject.ext.thirdparty.gson
}
```

为了避免重复书写 `this.rootProject.ext` ，我们可以将其定义为一个变量，并在依赖声明语句中调用。

"build.gradle":

```groovy
// 定义变量
def deps = this.rootProject.ext

// 通过"deps"变量引用依赖声明
dependencies {
    implementation deps.android.appcompat
    implementation deps.android.material
    implementation deps.thirdparty.gson
}
```

## Version Catalog
### 简介
Gradle 7.4.1以及更高版本新增了全局组件版本管理功能，名为Version Catalog。该功能可以识别Gradle构建脚本或配置文件中所声明的组件信息，并生成对应的变量；使用者可以在依赖声明语句中引用这些变量，实现统一的版本管理。

当我们配置该功能后，在书写依赖声明的过程中IDE能够进行代码提示，并且使用鼠标点击声明语句可以跳转到定义变量的文件中，对使用者较为友好，是官方所推荐的管理方式。

### 定义组件
我们首先在工程根目录下 `settings.gradle` 配置文件的 `versionCatalogs{}` 小节中声明若干组件信息。

"settings.gradle":

```groovy
dependencyResolutionManagement {

    // 此处省略其他功能代码...

    // 版本管理配置
    versionCatalogs {
        // 声明命名空间"libs"
        "libs" {
            // 声明组件，名称为"okhttp"，并指定GroupID、ArtifactID和版本号
            library("okhttp", "com.squareup.okhttp3:okhttp:4.11.0")

            // 声明组件，名称为"gson"，并指定GroupID、ArtifactID，单独指定版本号
            library("gson", "com.google.code.gson", "gson").version("2.10.1")
        }
    }
}
```

此时执行一次Gradle构建任务，我们就可以通过 `<命名空间>.<组件名称>` 的方式引用上述的两个组件。

"build.gradle":

```groovy
dependencies {
   implementation libs.okhttp
   implementation libs.gson
}
```

组件名称可以由字母、数字、横杠("-")、下划线("_")和点(".")组成；对于后三种符号，Gradle将会生成具有多个层级的结构。例如：我们在命名空间"libs"中声明组件 `okhttp3-core` 和 `google_gson` ，则对应的引用语句将变为下文代码块所示的形式。

```groovy
dependencies {
   implementation libs.okhttp3.core
   implementation libs.google.gson
}
```

如果我们不希望生成多级名称，可以使用驼峰命名法定义组件名称，将上述两个组件命名为 `okhttp3Core` 和 `googleGson` 。

### 定义插件
我们可以使用 `plugin()` 方法定义插件，第一个参数为插件名称，第二个参数为插件ID；随后再调用插件的 `version()` 方法定义版本号。

"settings.gradle":

```groovy
versionCatalogs {
    "libs" {
        // 定义Gradle插件
        plugin("android-app", "com.android.application").version("7.4.2")
        plugin("android-lib", "com.android.library").version("7.4.2")
    }
}
```

此时执行一次Gradle构建任务，我们就可以通过 `<命名空间>.plugins.<插件名称>` 的方式引用上述的两个插件。

"settings.gradle":

```groovy
plugins {
    // 使用"alias()"方法声明插件
    alias(libs.plugins.android.app) apply false
    alias(libs.plugins.android.library) apply false
}
```

### 定义版本
某些组件的版本号是同步更新的，例如Glide核心库与注解处理器总是使用相同的版本号，此时我就可以将版本号定义为一个独立的变量，便于统一管理。

我们可以使用 `version()` 方法定义版本号，并在组件与插件声明语句中引用。

"settings.gradle":

```groovy
// 版本管理配置
versionCatalogs {
    // 声明命名空间"libs"
    "libs" {
        // 定义Glide库的版本
        version("glide", "4.16.0")

        // 声明组件，并指定版本号为上文"version()"方法所定义的版本。
        library("glide", "com.github.bumptech.glide", "glide").versionRef("glide")
        library("glide_compiler", "com.github.bumptech.glide", "compiler").versionRef("glide")
    }
}
```

在组件与插件声明语句中， `versionRef()` 方法表示引用 `version()` 方法所定义的版本号，参数为版本号的名称。

### 定义编组
如果我们经常使用多个特定的组件，就可以使用Version Catalog提供的Bundle功能，将它们定义为一个编组。如此一来，我们只需要声明对于编组的引用，即可引入编组内所有的组件。

我们可以使用 `bundle()` 方法定义编组，第一个参数是编组名称，第二个参数是字符串列表，表项为需要关联的组件名称。

"settings.gradle":

```groovy
// 版本管理配置
versionCatalogs {
    "libs" {
        library("coil-core", "io.coil-kt", "coil").version("1.1.1")
        library("coil-gif", "io.coil-kt", "coil-gif").version("0.9.5")

        // 声明Bundle，名为"coil-all"，包括上述两个组件。
        bundle("coil-all", ["coil-core", "coil-gif"])
    }
}
```

此时执行一次Gradle构建任务，我们就可以通过 `<命名空间>.bundles.<Bundle名称>` 的方式引用该编组。

"settings.gradle":

```groovy
dependencies {
    // 声明依赖编组"coil-all"
    implementation libs.bundles.coil.all

    // 上述语句相当于以下两条语句
    implementation libs.coil.core
    implementation libs.coil.gif
}
```

使用编组的前提是依赖指令完全相同，如果一些模块需要 `implementation` 指令，另外一些模块需要 `annotationProcessor` 指令，它们就无法被编成一组，需要单独书写。

### 加载配置文件
一个工程通常包括许多组件依赖项，此时在Gradle配置文件中定义组件会占据大量的篇幅，并且与构建逻辑耦合在一起，不便于跨工程共享配置。

Version Catalog支持从TOML配置文件中加载组件与版本信息，其中 `[versions]` 、 `[libraries]` 、 `[bundles]` 、 `[plugins]` 四个小节的名称是固定的，它们的语法可以参考下文示例代码。

"versions.toml":

```toml
# 版本号
[versions]
gson = "2.10.1"
agp = "7.4.2"

coil-core = "1.1.1"
coil-gif = "0.9.5"


# 组件
[libraries]
# ----- 组件声明语法示例 -----
# 分别设置GroupID、ArtifactID和版本号
gson = { group = "com.google.code.gson", name = "gson", version = "2.10.1" }
# 设置GroupID、ArtifactID，并设置版本号
gson2 = { module = "com.google.code.gson:gson", version = "2.10.1" }
# 设置GroupID、ArtifactID，并引用"[versions]"小节中的版本号
gson3 = { module = "com.google.code.gson:gson", version.ref = "gson" }


android_coil-core = { group = "io.coil-kt", name = "coil", version.ref = "coil-core" }
android_coil-gif = { group = "io.coil-kt", name = "coil-gif", version.ref = "coil-gif" }


# 编组
[bundles]
coil-all = ["android_coil-core", "android_coil-gif"]


# Gradle插件
[plugins]
android_application = { id = "com.android.application", version.ref = "agp" }
android_library = { id = "com.android.library", version.ref = "agp" }
```

在TOML配置文件中，组件名称可以使用横杠("-")和下划线("_")，但不能出现点(".")，它会与TOML语法冲突，导致Gradle解析失败。

`version = <字符串>` 表示直接使用此处设置的字符串作为版本号， `version.ref = <配置项名称>` 表示引用 `[versions]` 小节中对应配置项的值，这与前文通过代码配置的逻辑一致。

我们可以使用以下方式加载配置文件：

"settings.gradle":

```groovy
// 版本管理配置
versionCatalogs {
    // 声明命名空间"libs"
    "libs" {
        // 导入依赖版本配置文件
        from(files("./versions.toml"))
    }
}
```

此时执行一次Gradle构建任务，我们就可以通过以下方式访问各配置项：

- `[versions]` : 通过 `libs.versions.<版本号名称>` 访问。
- `[libraries]` : 通过 `libs.<组件名称>` 访问。
- `[bundles]` : 通过 `libs.bundles.<编组名称>` 访问。
- `[plugins]` : 通过 `libs.plugins.<版本号名称>` 访问。

# 本地组件缓存
Gradle会将远程依赖组件存储到环境变量 `GRADLE_USER_HOME` 所指定的路径中，以便在多个项目之间共享依赖，避免重复下载。

以下路径为未设置环境变量时的默认Maven组件存储路径：

```text
<用户主目录>/.gradle/caches/modules-2/files-2.1/<GroupID>/<ArtifactID>/<Version>/<SHA1消息摘要>/<JAR或AAR文件>
```

当我们需要替换某个组件进行本地调试时，可以根据以上规则定位到JAR或AAR文件，执行替换操作。

# 疑难解答
## 索引

<div align="center">

|       序号        |                      摘要                      |
| :---------------: | :--------------------------------------------: |
| [案例一](#案例一) | 使用Kotlin语言时，注解处理器未能自动生成代码。 |

</div>

## 案例一
### 问题描述
使用Kotlin语言时，注解处理器未能自动生成代码。

在Kotlin项目中，引入了含有自定义注解的第三方库，此时程序运行后提示“找不到相关的类”。当我们查看编译产物时，其中确实没有注解生成的代码。

### 问题分析
Kotlin编译器并不能识别 `annotationProcessor` 指令，因此没有正确的处理注解并生成相关代码，导致出现上述错误。

详见前文章节： [🧭 依赖指令](#依赖指令) 。

### 解决方案
将所有的 `annotationProcessor` 指令替换为 `kapt` 指令。

详见前文章节： [🧭 依赖指令](#依赖指令) 。
