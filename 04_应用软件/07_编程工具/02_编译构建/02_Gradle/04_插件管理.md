# Maven Publish
## 简介
Maven Publish是Gradle的一个插件，它的功能是将模块编译产生的JAR或AAR文件上传至Maven仓库，以便被其他工程引用。

## 基本应用
在下文示例中，我们为一个Java Library模块配置Maven Publish插件，使其能够将编译产生的JAR包发布至Maven仓库。

"build.gradle":

```groovy
plugins {
    id('java-library')
    // 引入Maven Publish插件
    id('maven-publish')
}

// Maven Publish插件配置
publishing {
    // 发布目标仓库配置
    repositories {
        // 添加远端Maven仓库
        maven {
            url = '<仓库地址>'
            credentials {
                username = '<用户名称>'
                password = '<登录口令>'
            }
        }
    }

    // 发布参数配置
    publications {
        // 创建名为"maven"的发布配置
        maven(MavenPublication) {
            // 产物的基本信息
            groupId = '<Group名称>'
            artifactId = '<Artifact名称>'
            version = '<版本号>'

            // 发布程序包
            from components.java

            // POM信息
            pom {
                // 打包格式
                packaging = 'jar'

                name = '<工程名称>'
                url = '<工程对应的网站>'
            }
        }
    }
}
```

上述内容也可以使用Kotlin语言书写：

"build.gradle.kts":

```kotlin
plugins {
    id("java-library")
    // 引入Maven Publish插件
    id("maven-publish")
}

// Maven Publish插件配置
publishing {
    // 发布目标仓库配置
    repositories {
        // 添加远端Maven仓库
        maven {
            setUrl("<仓库地址>")
            credentials {
                username = "<用户名称>"
                password = "<登录口令>"
            }
        }

        // 添加本地Maven仓库
        mavenLocal()
    }

    // 发布参数配置
    publications {
        // 创建名为"maven"的发布配置
        create<MavenPublication>("maven") {
            // 产物的基本信息
            groupId = "<Group名称>"
            artifactId = "<Artifact名称>"
            version = "<版本号>"

            // 发布程序包
            from(components.getByName("java"))

            // POM信息
            pom {
                // 打包格式
                packaging = "jar"

                name.set("<工程名称>")
                url.set("<工程对应的网站>")
            }
        }
    }
}
```

Maven Publish插件的主要配置项都在 `publishing {}` 小节中，其中 `repositories {}` 小节用于配置目标仓库信息，语法与组件依赖仓库配置完全相同，详见相关章节： [🧭 依赖管理 - 仓库配置](./03_依赖管理.md#仓库配置) 。 `publications {}` 小节用于配置发布参数，控制需要发布的产物和生成的POM信息。

此处的 `groupId` 、 `artifactId` 、`version` 分别为当前模块的Group名称、Artifact名称和版本号，均为必填项； `from components.java` 语句指明了需要发布Java代码编译后产生的JAR包； `pom {}` 小节则声明了POM信息，其中 `packaging` 属性要与编译产物类型保持一致，其他属性则可根据实际需要选择性地填写。

此时我们可以在终端中执行 `gradle publish` 命令，Gradle将会开始编译任务，并在编译成功后将产生的JAR包上传到目标仓库中。

```text
[root@Fedora Project]# ./gradlew publish
BUILD SUCCESSFUL in 1s
12 actionable tasks: 11 executed, 1 up-to-date
```

## 发布源码包
在前文示例中，Maven Publish插件只会上传当前模块的字节码（JAR包）及组件依赖信息（包含在POM文件中），使用者在IDE中无法查看源码。

如果模块的代码允许公开，我们可以为Maven Publish插件添加一些配置项，在发布程序包的同时附带源码包，方便使用者查看源码。

"build.gradle":

```groovy
java {
    // 编译模块时同时打包源码
    withSourcesJar()
}
```

上述内容也可以使用Kotlin语言书写：

"build.gradle.kts":

```kotlin
java {
    // 编译模块时同时打包源码
    withSourcesJar()
}
```

如果我们在发布配置中使用 `from components.java` 语句发布编译产物，此时只需在 `java {}` 小节中指明打包源码即可，Maven Publish插件可以自动上传后缀为"-sources.jar"的源码包；如果我们使用其他编译产物发布语句，或者希望改变源码包的名称、打包内容等，就要自行创建打包源码的任务：

"build.gradle":

```groovy
// 打包源码的任务
def sourcesJar = tasks.register('sourcesJar', Jar) {
    // 将"src/main"目录下的源码文件打包
    from sourceSets.main.allJava
    // 为源码包添加后缀与程序包作区分
    archiveClassifier = 'sources'
}

publishing {
    publications {
        // 创建名为"maven"的发布配置
        maven(MavenPublication) {
            // 此处省略其他配置项 ...

            // 发布源码包
            artifact sourcesJar
        }
    }
}
```

上述内容也可以使用Kotlin语言书写：

"build.gradle.kts":

```kotlin
// 发布源码包的任务
val sourcesJar by tasks.creating(Jar::class) {
    // 将"src/main"目录下的源码文件打包
    from(sourceSets.getByName("main").allJava.srcDirs)
    // 为源码包添加后缀与程序包作区分
    archiveClassifier.set("sources")
}

publishing {
    publications {
        // 创建名为"maven"的发布配置
        create<MavenPublication>("maven") {
            // 此处省略其他配置项 ...

            // 发布源码包
            artifact(sourcesJar)
        }
    }
}
```

在上述示例代码中，我们创建了名为 `sourcesJar` 的任务以生成源码包，然后在 `publishing {}` 小节中通过 `artifact()` 方法应用该任务，将源码包也发布至仓库。

## 发布文档包
Maven Publish插件支持发布JavaDoc文档到Maven仓库中，如果我们需要实现此功能，可以在Gradle配置文件中添加以下配置：

"build.gradle":

```groovy
java {
    // 编译模块时同时打包文档
    withJavadocJar()
}

// 可选配置，根据实际需要添加即可。
javadoc {
    // 指定JavaDoc编码，解决系统编码与文件不一致导致错误。
    options.encoding = 'UTF-8'
}
```

上述内容也可以使用Kotlin语言书写：

"build.gradle.kts":

```kotlin
java {
    // 编译模块时同时打包文档
    withJavadocJar()
}

// 可选配置，根据实际需要添加即可。
tasks.withType<Javadoc> {
    // 指定JavaDoc编码，解决系统编码与文件不一致导致错误。
    options.encoding = "UTF-8"
}
```

## 发布Maven模块包
有些模块中不包含任何程序代码，只有POM文件，这种模块的作用是聚合多个依赖项，使用者只需依赖该模块，就会间接依赖其他组件。

由于没有程序代码，我们也不需要在发布配置中书写 `from components.java` 语句，此时插件不会自动在POM文件中生成 `<dependencies/>` 节点，因此我们需要新增一些逻辑代码，遍历Gradle的依赖组件，将其转为XML格式并写入POM文件。

"build.gradle":

```groovy
dependencies {
    implementation '<组件依赖项1>'
    implementation '<组件依赖项2>'
    implementation '<组件依赖项N>'
}

publishing {
    publications {
        maven(MavenPublication) {
            // 此处省略其他配置项 ...

            pom.withXml {
                def dependenciesNode = asNode().appendNode('dependencies')
                // 获取当前模块的所有"implementation"节点
                configurations.implementation.allDependencies.forEach() { Dependency dependency ->
                    def group = dependency.group
                    def artifact = dependency.name
                    def version = dependency.version
                    println("Parse dependency item. Group:[$group] Artifact:[$artifact] Version:[$version]")

                    // 向POM中添加依赖项，并跳过组名与版本号为空的项。
                    if (group != null && version != null) {
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', group)
                        dependencyNode.appendNode('artifactId', artifact)
                        dependencyNode.appendNode('version', version)
                        dependencyNode.appendNode('scope', 'compile')
                    }
                }
            }
        }
    }
}
```

上述内容也可以使用Kotlin语言书写：

"build.gradle.kts":

```kotlin
dependencies {
    implementation("<组件依赖项1>")
    implementation("<组件依赖项2>")
    implementation("<组件依赖项N>")
}

publishing {
    publications {
        create<MavenPublication>("maven") {
            // 此处省略其他配置项 ...

            pom.withXml {
                val dependenciesNode = asNode().appendNode("dependencies")
                // 获取当前模块的所有"implementation"节点
                configurations.getByName("implementation").allDependencies.forEach { dependency ->
                    val group: String? = dependency.group
                    val artifact: String = dependency.name
                    val version: String? = dependency.version
                    println("Parse dependency item. Group:[$group] Artifact:[$artifact] Version:[$version]")

                    // 向POM中添加依赖项，并跳过组名与版本号为空的项。
                    if (group != null && version != null) {
                        val dependencyNode = dependenciesNode.appendNode("dependency")
                        dependencyNode.appendNode("groupId", group)
                        dependencyNode.appendNode("artifactId", artifact)
                        dependencyNode.appendNode("version", version)
                        dependencyNode.appendNode("scope", "compile")
                    }
                }
            }
        }
    }
}
```
