> Git - 概述

什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

---

> Gradle - 概述

TODO

---

> CMake - 概述

TODO

---

> CMake - 基础用法

# 安装

TODO

# 基本应用



```text
Project
├── cmake-build-debug/
│   └── 构建缓存文件...
├── CMakeLists.txt
└── main.c
```





"CMakeLists.txt":

```cmake
# 声明该工程可使用的最低CMake版本
cmake_minimum_required(VERSION 3.23)

# 工程名称
# 我们可以通过"CMAKE_PROJECT_NAME"变量访问该名称
project(Study-C)

# 设置变量的值
# 变量"CMAKE_C_STANDARD"表示C语言标准版本，此处将其设为"C99"。
set(CMAKE_C_STANDARD 99)

# 添加编译任务：编译一个可执行文件
add_executable(
        # 构建产物的名称
        BuildResult

        # 需要参与编译的源代码文件列表
        # 存在多个文件时可以换行书写或使用空格分隔。
        main.c)
```

---

> Nextcloud



# 疑难解答
## 索引

<div align="center">

|       序号        |                         摘要                          |
| :---------------: | :---------------------------------------------------: |
| [案例一](#案例一) | PHP版本更新后，点击登录按钮片刻后又重新回到登录界面。 |

</div>

## 案例一
### 问题描述
PHP版本更新后，点击登录按钮片刻后又重新回到登录界面。

### 问题分析
首先进入NextCloud数据目录，查看 `nextcloud.log` 日志文件的内容。

```text
# 进入NextCloud数据目录（路径视具体情况而定）
[root@Fedora ~]# cd /srv/nextcloud

# 查看最近的日志消息
[root@Fedora nextcloud]# tail -f -n 10 nextcloud.log
{"reqId":"mZBEu0PHYGo3Wd09cjep","level":3,"time":"2024-02-01T14:41:16+00:00","remoteAddr":"172.18.1.1","user":"--","app":"PHP","method":"GET","url":"/login?direct=1&user=bi4vmr","message":"session_start(): Failed to read session data: files (path: /var/lib/php/session) at /usr/share/nginx/html/nextcloud/lib/private/Session/Internal.php#222","userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36","version":"27.0.1.2","data":{"app":"PHP"}}

# 此处省略部分输出内容...
```

从上述输出信息可知，用户登录时，PHP无法读写Session目录创建会话记录文件，因此导致登录失败。

接着我们查看Session目录的权限信息：

```text
# 查看PHP-FPM的Session目录权限
[root@Fedora ~]# ls -lh /var/lib/php
total 4.0K
drwxrwx---   2 root apache    6 Jan 16 08:00 opcache
drwxr-xr-x   2 root root    192 Feb  1 21:12 peclxml
drwxrwx---   2 root apache    6 Feb  1 22:25 session
drwxrwx---   2 root apache    6 Jan 16 08:00 wsdlcache
```

本案例中Web服务通过Nginx的专有用户"nginx"提供；由于系统升级时更新了PHP组件，它的Session目录属性被还原至"root apache"，从而导致Nginx无法在此创建会话记录文件。

### 解决方案
我们需要将Session目录的所有者与所属组重新改为Web服务提供程序的用户，以解决权限问题。

```text
# 修改Session目录的权限
[root@Fedora ~]# chown nginx:nginx /var/lib/php/session/

# 重启服务
[root@Fedora ~]# systemctl restart nginx.service php-fpm.service
```

此时客户端应当可以正常登录了；如果个别客户端仍然无法登录，我们可以尝试清空本地缓存后再次进行尝试。

---

> SQLite

# 自增主键
当主键的数据类型为 `INTEGER` 时，具有自增的特性，如果我们在插入新的记录时将主键填写为空值，新记录的主键将被设置为 $所有记录主键的最大值 + 1$ 。

假如当前表中没有记录，我们插入一条主键为空值的记录，其主键将被填写为"1"；再插入一条主键为空值的记录，其主键将被填写为"2"，后续的新记录以此类推。

如果我们插入一条指定主键值且该值大于现有最大主键的记录，后续插入的新记录自增序号将会以此为基础递增。例如：当前表中已有主键为"1"至"5"的记录，我们插入一条主键为"100"的记录，下一个自增序号将从"101"开始。

上述默认策略并不保证新增记录的序号严格递增，如果主键数值最大的记录被删除，插入新数据时存储引擎会将该数值重新分配；如果自增序号达到 `INTEGER` 类型的最大值，存储引擎将会尝试分配数值较小的且未被分配的数值。如果我们希望改变默认策略，可以在声明主键时添加 `AUTOINCREMENT` 关键字。

我们可以使用以下代码块中的SQL语句进行测试：

```sql
CREATE TABLE student_info
(
student_id INTEGER PRIMARY KEY AUTOINCREMENT,
student_name TEXT,
age INTEGER
);

INSERT INTO student_info VALUES(null, '张三', 19);
INSERT INTO student_info VALUES(null, '李四', 22);
INSERT INTO student_info VALUES(null, '王五', 24);
```

学生信息表"student_info"中以自增主键的方式被插入3条记录，由于主键被 `AUTOINCREMENT` 关键字修饰，存储引擎生成了名为"sqlite_sequence"的内置表，用于记录其他表自增主键的最大值，我们可以使用 `select * from sqlite_sequence;` 语句查看其中的内容：

<div align="center">

|     name     |  seq  |
| :----------: | :---: |
| student_info |   3   |

</div>

该表的"name"字段是二维表的名称，"seq"字段是当前自增主键的最大值，新增记录将以该数值的后一个整数作为主键，不会复用被删除的记录主键；如果某张表的"seq"数值达到 `INTEGER` 类型最大值，新增记录时将会产生"SQLITE_FULL"错误，此时应用程序可以执行分库分表或提示用户，实现了严格的序号递增。

# RowID字段
SQLite中的二维表默认包含一个"rowid"字段，它的数据类型为 `INTEGER` ，首条记录的值为"1"，后续插入记录时具有自增的特性，步进为"1"。在创建表结构时，我们可以添加 `WITHOUT ROWID` 子句禁止生成"rowid"字段，例如 `CREATE TABLE <表名>(<字段声明...>) WITHOUT ROWID;` ，但通常没有必要这样做。

包含"rowid"字段的表被称为“RowID表”，在SQLite内部使用B-Tree数据结构存储，以"rowid"值为Key。我们可以使用"rowid"查询数据，通常比主键索引或其他索引更快。

我们可以使用以下代码块中的SQL语句进行测试：

```sql
CREATE TABLE student_info
(
student_id INT PRIMARY KEY,
student_name TEXT,
age INTEGER
);

INSERT INTO student_info VALUES(20240001, '张三', 19);
INSERT INTO student_info VALUES(20240002, '李四', 22);
INSERT INTO student_info VALUES(20240003, '王五', 24);
```

当我们使用通配符"*"查询表的所有字段时，"rowid"字段不会显示在结果集中；若要查看该字段，我们需要明确地书写它，例如执行 `SELECT rowid, * FROM student_info;` 语句可以查看"student_info"表中的所有字段，包括"rowid"字段。

<div align="center">

| rowid | student_id | student_name |  age  |
| :---: | :--------: | :----------: | :---: |
|   1   |  20240001  |     张三     |  19   |
|   2   |  20240002  |     李四     |  22   |
|   3   |  20240003  |     王五     |  24   |

</div>

"rowid"字段具有一些别名，包括"oid"、"\_rowid\_"以及它们的大小写变种，如果表中的其他字段名称与某个别名相同，该别名就会失效，无法被用于访问"rowid"字段。

如果主键的数据类型是 `INTEGER` ，此时主键实际上就是"rowid"字段的一个别名，访问主键即指向"rowid"字段；如果主键不是 `INTEGER` 类型，则不会产生这种映射关系。在前文示例中，主键"student_id"的数据类型是 `INT` ，此时它不指向"rowid"字段，而是作为一个独立的字段存在。

我们可以使用以下代码块中的SQL语句进行测试：

```sql
CREATE TABLE student_info
(
student_id INTEGER PRIMARY KEY AUTOINCREMENT,
student_name TEXT,
age INTEGER
);

INSERT INTO student_info VALUES(null, '张三', 19);
INSERT INTO student_info VALUES(null, '李四', 22);
INSERT INTO student_info VALUES(null, '王五', 24);
```

此时主键"student_id"的数据类型为 `INTEGER` ，插入测试数据时"student_id"属性均为空值，表示使用自增数值填写，我们可以再次执行 `SELECT rowid, * FROM student_info;` 语句查看生成的数据。

<div align="center">

| student_id | student_id | student_name |  age  |
| :--------: | :--------: | :----------: | :---: |
|     1      |     1      |     张三     |  19   |
|     2      |     2      |     李四     |  22   |
|     3      |     3      |     王五     |  24   |

</div>

根据上述输出内容可知：

此时"rowid"字段与"student_id"字段的值完全相同，并且"rowid"字段的别名也显示为"student_id"，它们实际上是同一个字段。
