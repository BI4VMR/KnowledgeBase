# 简介
方法(Method)是用来解决特定问题的代码组合，我们将若干语句定义为方法后，就可以多次重复调用，提高可读性与可维护性。

方法与面向过程语言中的“函数(Function)”类似，都是用于实现特定功能的模块；在面向对象语言中，我们习惯将这种代码组合称为“方法”。

定义方法的语法如下文代码块所示：

```text
[访问修饰符] [static] <返回值类型> <方法名称>([参数列表...]) {
	[方法体...]
}
```

🔷 访问修饰符

用于限定方法的访问范围，可以是"public、protected、private"或省略不写，具体用法可参考相关章节： [🧭 面向对象 - 封装](../03_高级特性/01_面向对象/02_封装.md) ，本节内容为了简化操作，均将其省略。

🔷 "static"关键字

用于声明是否为静态方法，Java是面向对象语言，书写"static"关键字时方法跟随“类”，不必创建对象也能够直接调用；不书写"static"关键字时方法跟随“对象”，需要获取类的对象后才能调用。

面向对象的有关知识可参考相关章节： [🧭 面向对象 - 静态成员](../03_高级特性/01_面向对象/01_概述.md#静态成员) ，本节内容为了简化操作，均使用静态方法。

🔷 返回值类型

返回值是方法的输出，如果方法不需要向调用者汇报结果，此处应当填写"void"；如果方法需要汇报结果，此处应当填写结果的数据类型，并在方法体中使用"return"语句指明结果。

🔷 方法名称

此处必须定义合法的标识符，我们通常使用驼峰命名法进行命名。

🔷 参数列表

参数是方法的输入，传递给方法的参数可以有多个，此时各参数间以逗号(",")隔开，每个参数由参数类型和参数名称组成，例如： `(int arg1, int arg2)` 。

<br />

调用方法的语法如下文代码块所示：

```text
// 调用非静态方法
<对象名称>.<方法名称>([参数...]);

// 调用静态方法
<类名>.<方法名称>([参数...]);
```

如果方法有返回值，我们也可以直接给变量赋值来接收返回值：

```text
<变量类型> <用于存储返回值的变量> = <对象名称>.<方法名称>([参数...]);
```

# 方法的参数
有些操作需要依赖于特定的外部条件，例如：手机可以用来拨打电话，但我们必须先提供电话号码，才能进入后续步骤。通过输入参数，我们可以把外部条件传递给方法，以便方法内部根据实际情况执行对应的操作，提高方法的普适性。

方法名称后的括号中是参数列表，参数列表声明了方法需要从外部接收的参数数量与类型。

🔴 示例一

我们定义一个方法，接收两个整型参数，功能是将它们的值累加求和，并将结果输出到控制台上。

"TestMethod.java":

```java
public class TestMethod {

    // 计算两数之和
    static void plus(int a, int b) {
        int sum = a + b;
        System.out.println(a + " + " + b + " = " + sum);
    }

    public static void main(String[] args) {
        int x = 8;
        int y = 6;

        // 调用带参数无返回值方法，依次传入各参数。
        plus(x, y);
    }
}
```

在上述代码中， `plus(int a, int b)` 方法的参数列表声明了 `a` 与 `b` 两个整型变量；当我们调用该方法时，需要根据参数列表的顺序依次传入对应的值。

此时运行示例程序，并查看控制台输出信息：

```text
8 + 6 = 14
```

我们把定义方法时的参数称为“形参”，它们用于声明方法所需的参数数量与类型；我们在调用方法时传入的参数则被称为“实参”，这些参数是程序运行时真正被传递到方法中的值。

当我们调用方法时，方法所接收到的实参是调用者传入变量的副本，因此对于基本数据类型参数，两者完全没有关联，我们在方法内部可以随意修改实参的值，不会影响到原始变量。对于引用数据类型，实参与原始变量指向相同的内存空间，修改实参属性等同于修改原始变量。

🟠 示例二

我们定义一个方法，分别接收基本数据类型与引用数据类型两个参数，在方法内部改变他们，然后在方法外部访问。

"TestMethod.java":

```java
public class TestMethod {

    // 测试方法
    static void parameterType(int a, StringBuilder b) {
        a = a + 1;
        b.append(" HelloWorld!");
        System.out.println("[参数值] a: " + a + " b: " + b);
    }

    public static void main(String[] args) {
        // 基本数据类型
        int x = 8;
        // 引用数据类型
        StringBuilder y = new StringBuilder("Test");
        System.out.println("[操作前] x: " + x + " y: " + y);

        // 调用测试方法，在其中改变参数的值。
        parameterType(x, y);
        System.out.println("[操作后] x: " + x + " y: " + y);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
[操作前] x: 8 y: Test
[参数值] a: 9 b: Test HelloWorld!
[操作后] x: 8 y: Test HelloWorld!
```

根据上述输出内容可知：

变量 `x` 与 `y` 在 `parameterType()` 方法中被修改后，基本数据类型变量 `x` 的值没有被改变，而引用数据类型变量 `y` 的值已经被改变了。

当我们将变量传递给方法后，需要注意方法内部对原始变量的修改是否有影响。

## 方法的返回值
在有返回值的方法中，我们需要使用"return"关键字标识需要输出到外部的结果，该结果可以是变量或固定值，结果的数据类型必须与实际返回的变量类型一致，
不需要返回值的方法类型应填写为"void"。Java不支持多个返回值，因此我们只能向外部输出一个变量，如果需要返回多个值，可以使用数组、集合、对象等结构进行封装。

🟡 示例三

修改前文“示例一”中的 `plus()` 方法，通过返回值汇报计算结果。

"TestMethod.java":

```java
public class TestMethod {

    // 计算两数之和
    static int plus2(int a, int b) {
        int sum = a + b;
        return sum;
    }

    public static void main(String[] args) {
        int x = 8;
        int y = 6;

        // 调用带返回值方法"plus2()"，使用一个变量接收返回值。
        int sum = plus2(x, y);
        // 将接收到的参数显示在控制台上
        System.out.println("两数之和：" + sum);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
两数之和：14
```

上述代码中我们定义了 `plus2(int a, int b)` 方法，对前文示例的 `plus()` 方法进行修改，原本计算两数之和后，我们将数值显示在控制台上，此处我们将两数之和"sum"使用"return"关键字返回给调用者；原本的返回值类型"void"此处也需要改写为"int"。

# 方法的重载
如果同一个类中包含两个或更多同名方法，但它们的参数数量或类型不同，则称为方法的“重载(Overload)”。当我们调用重载方法时，Java会根据参数数量与位置来判断应该使用哪个方法，参数列表完全匹配的方法将被执行。

以下代码中，我们定义了求两数、三数之和的 `plus()` 方法，调用它们时，分别传入对应数量的参数。

🟢 示例四

<!-- TODO -->

"TestMethod.java":

```java
public class TestMethod {

    // 计算两数之和
    static void plus(int a, int b) {
        int sum = a + b;
        System.out.println(a + "+" + b + "=" + sum);
    }

    // 计算三数之和
    static int plus(int a, int b, int c) {
        int sum = a + b + c;
        return sum;
    }

    public static void main(String[] args) {
        int x = 8;
        int y = 6;
        int z = 10;

        // 调用具有两个参数的"plus()"方法
        plus(x, y);
        // 调用具有三个参数的"plus()"方法
        int sum = plus(x, y, z);
        System.out.println("三数之和：" + sum);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
8 + 6 = 14
三数之和：24
```

# 可变参数

可变参数是Java 5引入的一项功能，它允许你在方法中传递不定数量的参数。可变参数用三个点（...）表示，放置在方法参数的类型之前。可变参数实际上是一个数组，允许你传递任意数量的参数值。



```text
<返回值> <方法名称>(<参数类型>... <参数名称>) {
    // 方法体
}
```

参数类型后添加三个点即表示该参数为可变参数。




🔵 示例五

<!-- TODO -->

"TestMethod.java":

```java
public class TestMethod {

    // 计算若干数之和
    static long calculateSum(Integer... args) {
        // 可变参数本质上是数组
        Integer[] type = args;

        long sum = 0;
        // 遍历可变参数
        for (Integer arg : args) {
            // 累加求和
            sum += arg;
        }

        return sum;
    }

    public static void main(String[] args) {
        int x = 8;
        int y = 6;
        int z = 10;

        // 调用具有两个参数的"plus()"方法
        plus(x, y);
        // 调用具有三个参数的"plus()"方法
        int sum = plus(x, y, z);
        System.out.println("三数之和：" + sum);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
8 + 6 = 14
三数之和：24
```




在使用可变参数时，需要注意以下事项：
1. 可变参数必须是最后一个参数

可变参数必须是方法参数列表中的最后一个参数。这是因为可变参数会捕获所有传递的参数，导致无法确定参数的数量。

由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数

2. 可变参数不是数组

虽然可变参数看起来像数组，但它们实际上是不同的。可变参数是数组的语法糖，编译器会将可变参数转换为数组。因此，你可以像处理数组一样处理可变参数。



```java
// 具有可变参数的方法
void method(Integer... args) { }

// 具有数组参数的方法
void method(Integer[] args) { }
```

上述示例代码中




# 回调方法
## 简介
回调方法(Callback Method)是一种常用的设计模式，

回调方法是一种强大的机制，用于实现异步通信和事件响应，但在设计时需要谨慎处理其潜在的复杂性和性能影响。

当我们调用A方法时，将B方法作为一个参数传入，将B方法的控制权移交给A方法，当时机合适时，B方法才会触发。B方法不是我们主动调用的，而是A方法内部逻辑调用的，所以被称为“回调”。

回调方法通常用在以下场景：

- 异步任务：在异步操作中，你发起一个请求但不等待其结果，而是继续执行后续代码。当异步操作完成时，回调方法将被执行，通知你操作的结果。
- 多线程编程：在多线程环境中，一个线程可以启动另一个线程执行任务，并提供回调方法以在任务完成后得到通知。
- 事件处理：在事件驱动的程序中，当特定事件发生时，注册的回调方法将被调用来响应事件。

## 基本应用
在Java语言中，我们只能将引用数据类型的对象传递给，无法将方法作为参数传递给另一个方法，因此需要定义接口，调用者创建接口对应的实现对象，再将对象传递给方法。

🟣 示例六

定义一个接口，将其作为方法的参数，在方法中。

"TestMethod.java":

```java
// 回调接口
interface Callback {

    // 回调方法
    void onResult(boolean result, String message);
}

// 保存文件
static void saveFile(Callback callback) {
    TimerTask task = new TimerTask() {

        @Override
        public void run() {
            // 异步操作完成，调用回调接口实现中的方法，通知调用者。
            callback.onResult(true, "OK.");
            // 清除Timer，终止当前程序。
            System.gc();
        }
    };
    // 延迟2秒再执行上述任务，模拟异步操作。
    new Timer().schedule(task, 2000L);
}
```

第二步，我们在测试代码中调用 `saveFile()` 方法，传入Callback接口的实现类。

"TestMethod.java":

```java
System.out.println("Test method start.");
// 调用回调方法，传入Callback接口的实现。
saveFile(new Callback() {

    @Override
    public void onResult(boolean result, String message) {
        // 回调被触发后的动作
        System.out.println("Callback method was triggered. Result: " + result + ", Message: " + message);
    }
});
System.out.println("Test method end.");
```



此时运行示例程序，并查看控制台输出信息：

```text
Test method start.
Test method end.
Callback method was triggered. Result: true, Message: OK.
```
