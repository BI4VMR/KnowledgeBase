# 简介
JNI(Java Native Interface)技术使JVM具有调用C/C++代码的能力，扩展了Java语言的生态。

JNI技术较为复杂，在一般的Java应用程序中较少被使用，它的典型应用场景如下文列表所示：

- 提供平台支持：JVM的跨平台特性即由JNI技术提供支撑，例如：在Windows和Linux环境中“打开文件”的方式是不同的，JVM通过JNI接口分别访问各个系统调用，从而实现该功能；上层应用程序统一使用Java语法编写，不必关心底层的实现方式。
- 提高计算性能：对于计算密集型业务（例如：音视频处理、游戏引擎等），C/C++的执行效率高于Java；此时我们可以通过C/C++实现相关逻辑，并在Java中调用。
- 保护重要业务：与Java字节码相比，C/C++的动态链接库具有较高的反编译难度，因此我们可以将重要的业务逻辑通过C/C++实现。
- 调用第三方库：部分第三方库只提供了C/C++实现，例如FFmpeg；如果我们要在Java中使用相关功能，就需要通过JNI调用它们。

# 基本应用
## 编写含有本地方法的Java类
我们首先创建一个名为JNIClass的Java类，其中包括一些本地方法的声明语句。

"JNIClass.java":

```java
package net.bi4vmr.study.jni.base;

public class JNIClass {

    static {
        /*
         * 加载C或C++编写的动态链接库
         */
        System.loadLibrary("native");
    }

    // 本地方法：输出文本
    private native void printInfo();
}
```

静态初始化块中的 `System.loadLibrary("<动态链接库名称>")` 语句指定了需要加载的动态链接库名称，此处我们填写"native"，当程序运行在Linux环境时，将查找 `libnative.so` ；当程序运行在Windows环境时，将查找 `native.dll` 。

方法 `printInfo()` 被"native"关键字修饰，这表明它是一个本地方法，具体的实现在动态链接库中，而不在Java源代码中。

然后我们创建一个具有Main方法的测试类TestJNI，调用JNIClass类中的本地方法。

"TestJNI.java":

```java
public class TestJNI {

    public static void main(String[] args) {
        JNIClass c = new JNIClass();
        c.printInfo();
    }
}
```

此时我们运行一次示例程序，并查看控制台输出信息：

```text
Exception in thread "main" java.lang.UnsatisfiedLinkError: no native in java.library.path: [/usr/java/packages/lib, /usr/lib64, /lib64, /lib, /usr/lib]
	at java.base/java.lang.ClassLoader.loadLibrary(ClassLoader.java:2662)
	at java.base/java.lang.Runtime.loadLibrary0(Runtime.java:827)
	at java.base/java.lang.System.loadLibrary(System.java:1871)
	at net.bi4vmr.study.base.JNIClass.<clinit>(JNIClass.java:22)
	at net.bi4vmr.study.base.TestJNI.example01(TestJNI.java:27)
	at net.bi4vmr.study.base.TestJNI.main(TestJNI.java:19)
```

根据上述输出内容可知：

由于在默认目录中未能找到"native"动态链接库文件，JVM抛出了UnsatisfiedLinkError异常。

接下来我们需要通过C/C++语言实现 `printInfo()` 方法，并且将源代码编译为动态链接库文件，以供JVM调用。

## 生成C/C++头文件
C/C++头文件类似于Java中的接口，我们首先需要获取JNIClass类对应的头文件，再编写C/C++代码实现头文件中的函数。

JNI所使用的头文件格式具有固定的规律，我们熟悉JNI技术之后可以自行编写，此处为了简化操作，我们使用JDK中的命令自动生成头文件。

在JDK8及以下的版本中，我们可以使用 `javah` 命令生成JNIClass类对应的C/C++头文件。

```text
# 命令语法
[root@Fedora ~]# javah <需要生成头文件的类名>

# 命令示例
[root@Fedora ~]# javah JNIClass
```

在JDK8及以上的版本中，Native头文件生成功能被集成到 `javac` 命令中，语法为 `javac -h <输出目录> <需要生成头文件的类名>` 。

```text
# 进入当前Java类所在目录
[root@Fedora ~]# cd src/main/java/net/bi4vmr/study/jni/

# 编译Java源码文件并生成头文件
[root@Fedora jni]# javac -h ./ JNIClass
```

如果Java源代码的字符编码与系统默认值不同，该命令可能会产生错误，此时我们可以尝试添加 `-encoding <编码>` 选项。

```text
# 编译Java源码文件并生成头文件
[root@Fedora jni]# javac -encoding UTF-8 -h ./ JNIClass.java
```

上述命令执行成功后， `JNIClass.java` 文件的同级目录内将会生成扩展名为".h"的头文件，我们可以查看其中的内容。

"net_bi4vmr_study_jni_JNIClass.h":

```h
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class net_bi4vmr_study_jni_base_JNIClass */

#ifndef _Included_net_bi4vmr_study_jni_base_JNIClass
#define _Included_net_bi4vmr_study_jni_base_JNIClass
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     net_bi4vmr_study_jni_base_JNIClass
 * Method:    printInfo
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_net_bi4vmr_study_jni_base_JNIClass_printInfo
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

该文件首部引入的 `jni.h` 包含JNI在C语言侧所需的全局变量、结构体与方法定义，后续出现的 `JNIEXPORT` 、 `JNIEnv` 、 `jobject` 等元素均包含在其中，C语言编译器需要识别到该文件才能正确编译JNI源代码。

Java的本地方法映射到头文件后格式为 `Java_<类的完全限定名称>_<方法名称>(<参数列表>)` ，每个函数的固定前缀为"Java_"；随后为类的完全限定名称，我们需要将点(".")替换为下划线("_")，例如前文示例中的"net.bi4vmr.study.jni.JNIClass"类，替换后变为"net_bi4vmr_study_jni_JNIClass"；最后为方法名称和参数列表。

JNI映射函数除了拥有Java侧原本的参数列表之外，还有两个固定参数，它们的作用详见下文列表：

- `JNIEnv *` : 该参数是指向JNI运行环境的指针，我们可以通过它访问JNI在C语言侧的一切函数，例如：“获取数组长度”、“获取字符串”等，便于完成JNI与C语言数据类型的转换工作。
- `jobject` : 该参数是Java中调用该方法的对象。若本地方法为静态方法，此参数类型将变更为 `jclass` ，表示本地方法所在类的Class对象。

关键字 `JNIEXPORT` 和 `JNICALL` 之间的内容即函数的返回值类型，需要与对应的Java侧方法保持一致，此处Java方法 `printInfo()` 的返回值类型为"void"，因此在头文件中也为"void"。

## 编写C/C++实现
我们可以将前文步骤中生成的头文件复制或链接到外部C/C++ IDE工程中，并编写实现代码、配置编译脚本，实施项目化的开发流程。此处为了演示方便，我们直接在Java工程中创建对应的C/C++源代码文件，然后使用命令行编译生成动态链接库。

我们在 `net_bi4vmr_study_jni_JNIClass.h` 文件的同级目录下创建C++源代码文件 `jni.cpp` ，引入该头文件并实现其中的JNI映射函数。

"jni.cpp":

```cpp
#include <jni.h>
#include <stdio.h>
#include "net_bi4vmr_study_jni_base_JNIClass.h"

JNIEXPORT void JNICALL Java_net_bi4vmr_study_jni_base_JNIClass_printInfo(JNIEnv *env, jobject instance) {
   printf("Hello World!");
}
```

此处我们并未用到任何JNI环境中的工具，只是简单的向控制台输出文本"Hello World!"。

接着我们使用GCC编译C++源代码，生成对应的".so"或".dll"文件。

```text
# Windows平台编译命令
[user@Windows jni]# gcc -Wl,--add-stdcall-alias -I"%JAVA_HOME%\include" -I"%JAVA_HOME%\include\win32" -shared -o native.dll jni.cpp

# Linux平台编译命令
[root@Fedora jni]# gcc -fPIC -I /usr/lib/jvm/default/include/ -I /usr/lib/jvm/default/include/linux/ --shared -o libnative.so jni.cpp
```

上述命令执行成功后，C++源代码文件旁边将会生成对应的动态链接库文件；我们可以将其复制到系统库目录，再次运行示例程序，此时应当不会再产生错误，且控制台能够输出预设的文本内容"Hello World!"。

# 数据类型转换
## 简介
Java与C/C++的数据类型并不相同，因此头文件 `jni.h` 中定义了二者数据类型的映射关系，以便我们在JNI函数中访问Java数据，具体的映射关系如下文表格所示。

<div align="center">

| Java数据类型 |   C数据类型   |       描述       |
| :----------: | :-----------: | :--------------: |
|     void     |     void      |     无返回值     |
|   boolean    |   jboolean    |      布尔型      |
|     byte     |     jbyte     |      字节型      |
|    short     |    jshort     |      短整型      |
|     int      |     jint      |       整型       |
|     long     |     jlong     |      长整型      |
|    float     |    jfloat     |   单精度浮点型   |
|    double    |   jdoubley    |   双精度浮点型   |
|    String    |    jstring    |      字符串      |
|  Throwable   |  jthrowable   |     异常对象     |
|    Object    |    jobject    |     任意对象     |
|    Class     |    jclass     |    Class对象     |
|  boolean[]   | jbooleanArray |    布尔型数组    |
|    byte[]    |  jbyteArray   |    字节型数组    |
|   short[]    |  jshortArray  |    短整型数组    |
|    int[]     |   jintArray   |     整型数组     |
|    long[]    |  jlongArray   |    长整型数组    |
|   float[]    |  jfloatArray  | 单精度浮点型数组 |
|   double[]   | jdoubleArray  | 双精度浮点型数组 |
|   Object[]   | jobjectArray  |   任意对象数组   |

</div>

对于基本数据类型，它们只是C语言数据类型的别名，相关定义在头文件 `jni.h` 中，我们通常会将它们转换为对应的C语言数据类型，再传递给其他未引入 `jni.h` 的组件。

对于引用数据类型，它们会被转换为一个C/C++指针，需要通过JNI运行环境提供的工具转换为C++字符串等类型才能进一步操作。如果某个参数是引用数据类型，在本地方法执行结束前，它都不会被JVM回收。

## 传递基本数据类型参数
JNI的基本数据类型可以直接被转换为C/C++数据类型，详见下文的示例代码：

"jni.cpp":

```cpp
JNIEXPORT void JNICALL Java_net_bi4vmr_study_jni_datatype_JNIClass_passBasicTypes(
        JNIEnv *env, jobject instance, jboolean b, jint i, jdouble d) {
    // 将JNI数据类型转为C++原生数据类型
    bool b1 = b;
    long i1 = i;
    double d1 = d;

    // 使用转换后的变量（此处只是简单地在控制台输出它们）
    printf("PassBasicTypes. b1:[%b], i1:[%ld], d1:[%f]", b1, i1, d1);
}
```

## 传递字符串参数
我们需要对JNI字符串类型进行一些额外的处理，将其转为C的字符指针或C++的"string"类型，相关操作详见下文的示例代码：

"jni.cpp":

```cpp
JNIEXPORT void JNICALL Java_net_bi4vmr_study_jni_datatype_JNIClass_passString(
        JNIEnv *env, jobject instance, jstring str) {
    // 将数组元素转为字符指针
    const char *pString = env->GetStringUTFChars(str, nullptr);
    // 将字符指针转为C++字符串
    string cString = string(pString);
    // 释放资源
    env->ReleaseStringUTFChars(str, pString);

    // 使用转换后的变量
    printf("PassString. String:[%s]", cString.c_str());
}
```

JNI运行环境的 `GetStringUTFChars(jstring string, jboolean* isCopy)` 方法可以将"jstring"类型数据转换为C语言的字符指针，参数 `string` 是待转换的变量；参数 `isCopy` 表示是否复制数据，我们通常不使用该功能，此时传入空值即可。

JNI运行环境的 `ReleaseStringUTFChars(jstring string, const char* utf)` 方法可以释放字符串资源，当数据转换完毕后我们应当调用该方法，参数 `string` 是待释放的变量；参数 `utf` 是转换后的字符指针。

## 传递字符串数组参数
JNI字符串数组的处理方式与单个字符串是类似的，主要是增加了获取数组长度与遍历每个元素的逻辑，相关操作详见下文的示例代码：

"jni.cpp":

```cpp
JNIEXPORT void JNICALL Java_net_bi4vmr_study_jni_datatype_JNIClass_passStringArray(
        JNIEnv *env, jobject instance, jobjectArray stringArray) {
    // 获取数组总长度
    int count = env->GetArrayLength(stringArray);
    // 创建C++列表存储结果
    vector<string> list = vector<string>(count);
    // 遍历Java数组，获取字符串。
    for (int i = 0; i < count; i++) {
        // 获取数组元素，并转换为C++的String。
        auto jString = (jstring) (env->GetObjectArrayElement(stringArray, i));
        // 将数组元素转为字符指针
        const char *pString = env->GetStringUTFChars(jString, nullptr);
        // 将字符指针转为C++字符串
        string cString = string(pString);
        // 释放资源
        env->ReleaseStringUTFChars(jString, pString);
        // 将字符串存储至集合
        list[i] = cString;
    }

    // 使用转换后的变量
    for (int j = 0; j < list.size(); j++) {
        printf("PassStringArray. Index:[%d], Content:[%s]", j, list[j].c_str());
    }
}
```

# 动态注册
## 简介
在前文示例中，我们通过JNI固有的名称映射规则编写C++函数，使得JVM能够自动从动态链接库中找到本地方法的实现，这种方式被称为“静态注册”。

静态注册方式的缺点是函数名称过于繁琐，如果对应的Java包名发生变化，C语言文件名称与所有函数名称都要同步修改，可维护性较差。

除了静态注册方式，我们还可以通过动态注册方式维护Java本地方法与C语言函数的映射关系，解决静态注册方式所带来的问题。

## 方法签名
### 简介
Java支持方法重载，因此我们无法仅通过方法名称唯一标识某个方法。在JVM中，每种数据类型都有对应的类型描述符，方法参数与返回值的描述符组合即可唯一标识每个方法，这些描述符组合也被称为“方法签名”。

动态注册JNI方法时，我们需要手动书写方法签名，因此必须提前了解这部分知识。

### 描述符
下文表格展示了每种数据类型与描述符的对应关系：

<div align="center">

|  数据类型  |     类型描述符      |
| :--------: | :-----------------: |
|   `void`   |         `V`         |
| `boolean`  |         `Z`         |
|   `byte`   |         `B`         |
|  `short`   |         `S`         |
|   `int`    |         `I`         |
|   `long`   |         `J`         |
|  `float`   |         `F`         |
|  `double`  |         `D`         |
|   `char`   |         `C`         |
| `引用类型` |   `L<类型全名>;`    |
|   `数组`   | `[<其他类型描述符>` |

</div>

下文列表描述了引用类型、数组等特殊类型的转换规则：

- 方法签名的格式为 `(<参数类型I><参数类型II><参数类型...>)<返回值类型>` ，若存在多个参数，则对应的类型描述符紧挨着书写即可，每个描述符对应一个参数，无需插入任何分隔符。例如：具有整型、布尔型、浮点型三个参数的方法，参数列表部分记作 `IZF` 。
- 方法返回值类型不可省略，如果是无参方法，其返回值类型为"void"，则类型描述符记作 `V` 。
- 数组的类型描述符以方括号（左）开头，其后为元素的数据类型。例如：整型数组记作 `[I` ；布尔型数组记作 `[Z` 。
- 如果是N维数组，则添加对应数量的方括号即可。例如：整型二维数组记作 `[[I` ；布尔型四维数组记作 `[[[[Z` 。
- 引用类型的描述符以"L"开头，其后为类的完全限定名称（其中点(".")需要替换为斜杠("/")），并且以分号(";")作为结束符。例如："java.lang.String"类型记作 `Ljava/lang/String;` 。

### 示例
下文内容描述了一些示例方法及签名的转换过程，可供读者参考。

🔷 `void printInfo()`

该方法没有参数，参数描述符留空即可；返回值为"void"类型，记作 `V` ；因此方法签名为 `()V` 。

🔷 `long sum(int x, int y)`

该方法具有两个"int"类型的参数，记作 `II` ；返回值为"long"类型，记作 `J` ；因此方法签名为 `(II)J` 。

🔷 `double[] position(float a, float b)`

该方法具有两个"float"类型的参数，记作 `FF` ；返回值为"double"数组类型，记作 `[D` ；因此方法签名为 `(FF)[D` 。

🔷 `void passObjects(String str, Date obj)`

该方法的首个参数为"String"类型，记作 `Ljava/lang/String;` ；第二个参数为"Date"类型，记作 `Ljava/util/Date;` ；返回值为"void"类型，记作 `V` ；因此方法签名为 `(Ljava/lang/String;Ljava/util/Date;)V` 。

## 实现动态注册
本节将以前文示例中的一些本地方法为例，演示JNI的动态注册方式。

"JNIClass.java":

```java
native void passBasicTypes(boolean b, int i, double d);

native void passString(String str);

native void passStringArray(String[] array);

native long returnBasicTypes();

native String returnString();
```

如果使用动态注册的方式，我们可以跳过生成Native类头文件的步骤，直接编写C语言源代码 `jni.cpp` 即可。

头文件 `jni.h` 中定义了名为"JNINativeMethod"的结构体，用来描述Java本地方法与C语言函数的映射关系，其中第一参数是Java本地方法的名称；第二参数是本地方法的方法签名；第三参数是对应的C语言函数指针。

为了实现动态注册，我们首先需要定义JNINativeMethod结构体数组，描述 `JNIClass.java` 中本地方法与 `jni.cpp` 中函数的映射关系。

"jni.cpp":

```cpp
// 结构体数组，用于声明当前Native类包含的所有JNI方法。
static const JNINativeMethod jniNativeMethod[] = {
        {"passBasicTypes",   "(ZID)V",                 (void *) (passBasicTypes)},
        {"passString",       "(Ljava/lang/String;)V",  (void *) (passString)},
        {"passStringArray",  "([Ljava/lang/String;)V", (void *) (passStringArray)},
        {"returnBasicTypes", "()J",                    (void *) (returnBasicTypes)},
        {"returnString",     "()Ljava/lang/String;",   (void *) (returnString)},
};
```

接着我们需要在C语言侧重写 `JNI_OnLoad()` 方法，这是一个回调方法，当Java侧执行 `System.loadLibrary()` 方法时，该方法将被触发，我们需要在此处注册映射关系。

"jni.cpp":

```cpp
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {
    // 通过JavaVM，获取JNIEnv实例。
    JNIEnv *jniEnv = nullptr;
    // 该方法的第二个参数是JNI标准版本号，常用的值为"1.6"。
    jint result = jvm->GetEnv(reinterpret_cast<void **>(&jniEnv), JNI_VERSION_1_6);
    // 判断JNIEnv初始化结果
    if (result == JNI_OK) {
        // 绑定目标Native类
        jclass jniClass = jniEnv->FindClass("net/bi4vmr/study/jni/dynamic/JNIClass");
        // 获取JNI方法的数量
        long arraySize = sizeof(jniNativeMethod) / sizeof(JNINativeMethod);
        // 动态注册Native方法
        jniEnv->RegisterNatives(jniClass, jniNativeMethod, arraySize);
        return JNI_VERSION_1_6;
    } else {
        return JNI_ERR;
    }
}
```

`JNI_OnLoad()` 方法具有两个参数，其中参数 `jvm` 是JVM环境变量，我们需要通过它执行后续的其他操作，相关步骤详见上文示例代码及注释；参数 `reserved` 是一个预留的值，无实际意义。

`JNI_OnLoad()` 方法的返回值类型为整型，若注册成功，需要返回JNI版本号；若注册失败，则应返回错误码，相关常量定义在 `jni.h` 文件中。

我们首先通过 `jvm` 的 `GetEnv()` 方法获取JNI运行环境 `jniEnv` ，然后调用 `jniEnv` 实例的 `RegisterNatives()` 方法实现动态注册。

`RegisterNatives()` 方法具有三个参数，各个参数的含义见下文内容：

- 参数 `clazz` : Java中Native类的Class实例。我们可以调用 `FindClass()` 方法，传入类的完全限定名称获取该实例，其中点(".")需要替换为斜杠("/")。
- 参数 `methods` : JNI方法结构体数组。
- 参数 `nMethods` : JNI方法的数量。我们可以通过计算结构体数组的长度得到该数值，而不是填写常量，避免后期增减方法导致数量变更而出现错误。

最后我们还需要重写 `JNI_OnUnload()` 方法，该方法也是一个回调方法，当JVM回收本C++类对应的Java类时，该方法将被触发，我们需要在此处调用 `UnregisterNatives()` 方法解除JNI方法注册。

"jni.cpp":

```cpp
JNIEXPORT void JNICALL JNI_OnUnload(JavaVM *jvm, void *reserved) {
    JNIEnv *jniEnv = nullptr;
    jint result = jvm->GetEnv(reinterpret_cast<void **>(&jniEnv), JNI_VERSION_1_6);
    if (result == JNI_OK) {
        jclass jniClass = jniEnv->FindClass("net/bi4vmr/study/jni/dynamic/JNIClass");
        // 注销Native方法
        jniEnv->UnregisterNatives(jniClass);
    }
}
```

至此，动态注册JNI方法的关键代码已经编写完成，我们可以按照前文JNINativeMethod结构体中定义的函数名称编写函数实现，不必再按照静态注册方式的规则为函数命名。

# 疑难解答
## 索引

<div align="center">

|       序号        |                               摘要                                |
| :---------------: | :---------------------------------------------------------------: |
| [案例一](#案例一) | 在Windows环境中编译C/C++代码时，编译器无法识别"__int64"数据类型。 |

</div>

## 案例一
### 问题描述
在Windows环境中编译C/C++代码时，编译器无法识别"__int64"数据类型，提示信息如下文代码块所示：

```text
错误：未知的类型名‘__int64’
35 | typedef __int64 jlong;
```

### 问题分析
"__int64"是Microsoft Visual C++中的专有类型，Windows平台的 `jni.h` 头文件中引用了它；如果我们未使用Visual Studio编译C/C++源代码，就会遇到该错误，因为其他编译器中没有名为"__int64"的数据类型。

### 解决方案
C/C++中的标准类型"long long"长度为8字节，与"__int64"的取值范围相同，因此我们可以使用宏定义将"__int64"定义为"long long"的别名。

```c
// 该定义语句需要书写在引用"jni.h"的语句之前
#define __int64 long long
#include <jni.h>
```
