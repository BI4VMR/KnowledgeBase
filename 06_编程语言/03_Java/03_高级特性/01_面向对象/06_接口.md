# 简介
接口由全局常量和抽象方法组成，它与抽象类相比只有功能规范而无任何具体的实现。类包含一组功能的具体实现，而接口只定义类需要遵守的规范，规定类必须提供哪些方法，并不关心具体的实现细节。

子类只能继承一个父类，但可以实现多个接口，因此我们可以认为接口变相实现了多继承机制。

---------------


定义接口的语法如下文代码块所示：

```text
public interface <接口名称> extends [父接口1, 父接口2, 父接口N...] {

    // 定义常量
    public static final <常量类型> <常量名称> = <常量的值>;

    // 定义抽象方法
    public abstract <返回值类型> <方法名称>();
}
```

接口与类的定义方式类似，关键字为"interface"，当访问修饰符为"public"时可以作为一个独立的".java"文件存在。

接口的名称通常为它所抽象的实体，在部分项目中会在名称之前添加字符"I"以便与类作区分，但这种命名方式现今已经较少使用了。

接口可以继承多个其他接口，此时接口的实现类需要实现当前接口及其所有父接口中的抽象方法。

接口中的元素修饰符是固定且不可更改的，因此我们也可以将它们省略。定义常量时可以省略"public static final"部分；定义抽象方法时可以省略"public abstract"部分。

# 基本应用







"Animal.java":


```java
public interface Animal {

    // 定义常量
    String TYPE_NAME = "Animal";

    // 定义抽象方法
    void eat();
}
```




"Dog.java":

```java
public class Dog implements Animal {

    @Override
    public void eat() {
        // 访问接口中的常量
        System.out.println("类型：" + TYPE_NAME);

        // 实现"eat()"方法的逻辑
        System.out.println("狗吃狗粮");
    }
}
```


"Cat.java":

```java
public class Cat implements Animal {

    @Override
    public void eat() {
        // 实现"eat()"方法的逻辑
        System.out.println("猫吃猫粮");
    }
}
```





<!-- TODO
        1.4   匿名内部类
匿名内部类只关注具体实现而不关注类的名称，有时候有的类只需要创建一个它的对象，以后不会再用到这个类，这时使用匿名内部类比较合适。
                • 示例
创建匿名内部类。
public class Test {

	public static void main(String[] args) {
		IAnimal dog = new IAnimal() {

			@Override
			public void eat() {
				System.out.println("狗吃狗粮");
			}
		};
		dog.eat();
	}
}
控制台输出：
狗吃狗粮
有时我们使用内部类甚至不需要创建相应的对象，只需要作用一次。
public class Test {

	public static void main(String[] args) {
		new IAnimal() {

			@Override
			public void eat() {
				System.out.println("狗吃狗粮");
			}
		}.eat();
	}
}
控制台输出：
狗吃狗粮

-->
