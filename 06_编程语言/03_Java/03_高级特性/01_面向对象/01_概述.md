# 类与对象
## 简介
类(Class)是某种事物的静态模板，用来描述该事物所拥有的特征（属性）和行为（方法）；对象(Object)则是类的具象化实体，拥有具体的属性。我们使用类创建对象的过程被称为“实例化”，构建出的对象也被称为实例(Instance)。

定义类与创建对象的语法如下文代码块所示：

```text
// 定义一个“类”
class <类名> {
    /* 成员变量... */

    /* 成员方法... */
}

// 由类创建对象，并保存至变量。
<类名> <变量名称> = new <类名>();

// 访问对象的属性
<变量名称>.<属性>;
// 调用对象的方法
<变量名称>.<方法>({参数});
```

## 基本应用
我们首先定义一个Person类描述“人类”，它拥有姓名、年龄、性别三个属性，以及“说话”方法。

"Person.java":

```java
public class Person {

    /* 属性 */
    String name;
    int age;
    char sex;

    /* 方法 */
    public void speak() {
        System.out.println("我是" + name + "，年龄" + age + "岁，性别为" + sex);
    }
}
```

“对象”是程序运行时根据“类”动态产生的实体，例如：“张三”的年龄是18岁，性别为“男”；“李四”的年龄是20岁，性别为“女”。

我们在测试类中创建两个Person类的对象，并通过访问属性与方法读写“张三”和“李四”的姓名、年龄、性别。

"TestClass.java":

```java
// 从模板“人类”创建实体“张三”
Person zhangsan = new Person();
// 设置属性
zhangsan.name = "张三";
zhangsan.age = 18;
zhangsan.sex = '男';
// 调用方法
zhangsan.speak();

// 从模板“人类”创建实体“李四”
Person lisi = new Person();
lisi.name = "李四";
lisi.age = 20;
lisi.sex = '女';
lisi.speak();
```

此时运行示例程序，并查看控制台输出信息：

```text
我是张三，年龄18岁，性别为男
我是李四，年龄20岁，性别为女
```

## 全局变量
类所拥有的属性被称为“成员变量”，这种变量的生命周期跟随对象，并且作用域为整个类，类中的所有位置均可访问它们，因此也被称为“全局变量”。前文示例中Person类的姓名、年龄、性别三个属性即为全局变量，我们在 `speak()` 方法内部可以访问这些变量。

当我们声明全局变量时，可以不指定初始值，JVM会在类加载时自动为它们赋予默认值。

我们在测试类中声明一些全局变量，并在方法中访问它们，并将值输出到控制台上。

"TestScope.java":

```java
public class TestScope {

    // 声明全局变量
    short a;
    int b;
    float c;
    double d;
    boolean e;
    String f;
    Object g;

    public static void main(String[] args) {
        // 访问全局变量
        System.out.println("a: " + a);
        System.out.println("b: " + b);
        System.out.println("c: " + c);
        System.out.println("d: " + d);
        System.out.println("e: " + e);
        System.out.println("f: " + f);
        System.out.println("g: " + g);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
a: 0
b: 0
c: 0.0
d: 0.0
e: false
f: null
g: null
```

根据上述输出内容可知：

数值类型变量的初始值为"0"；布尔类型变量的初始值为"false"；引用类型变量的初始值为"null"。

## 局部变量
我们在代码块 `{}` 中声明的变量被称为“局部变量”，它们的作用域仅限其所在的代码块，一般用于保存临时性的数据；当代码块中的语句执行完毕后变量就会失效，基本数据类型变量所占用的内存将被立刻回收，引用数据类型变量所占用的内存由垃圾收集器控制回收。

"TestScope.java":

```java
public class TestScope {

    public void function1() {
        // 声明局部变量"x"
        int x = 0;
    }

    public void function2() {
        // 此方法无法访问"function1()"方法中的局部变量"x"，编译器会提示错误。
        System.out.println(x);
    }
}
```

在上述示例代码中，方法 `function1()` 内部定义的局部变量 `x` 无法被方法 `function2()` 访问，方法 `function2()` 中的 `System.out.println(x)` 语句会导致编译错误。

## 构造方法
构造方法是用来初始化对象的方法，它与类同名并且没有返回值，因此我们不能书写返回值类型。

当我们没有声明构造方法时，类中默认存在一个无参数、方法体为空的构造方法。前文测试代码中创建Person对象时，"new"关键字后跟随的部分 `Person()` 即为构造方法。

构造方法允许重载，以便我们使用不同的初始条件来创建对象。一旦我们声明了有参数的构造方法，默认构造方法就会被系统移除，若我们需要保留无参数的构造方法，则必须手动将其书写在类中。

我们为Person类添加一个构造方法，分别接收姓名、年龄、性别三个参数，并赋值给对应的属性。

"Person2.java":

```java
public class Person2 {

    /* 属性 */
    String name;
    int age;
    char sex;

    /* 构造方法 */
    public Person2() {}

    /* 构造方法 */
    public Person2(String name, int age, char sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    /* 方法 */
    public void speak() {
        System.out.println("我是" + name + "，年龄" + age + "岁，性别为" + sex);
    }
}
```

在上述示例代码中，我们需要使用"this"关键字为全局变量完成赋值，这是因为构造方法的形参与全局变量同名，此时型参的优先级高于全局变量，语句"name"即表示型参 `name` ；"this"关键字表示“当前类的对象”，语句"this.name"表示全局变量 `name` ，完整的语句 `this.name = name` 表示将型参 `name` 的值赋给全局变量 `name` 。

随后，我们在测试代码中调用有参构造方法，一次性给三个属性赋值，完成对象的初始化。

"TestClass.java":

```java
// 使用"new"关键字创建对象
Person2 zhangsan = new Person2("张三", 18, '男');
zhangsan.speak();
```

此时运行示例程序，并查看控制台输出信息：

```text
使用有参构造方法初始化对象...
我是张三，年龄18岁，性别为男
```

## 静态成员
普通的成员变量与方法属于对象，我们只能通过保存对象引用的变量访问，并且它们的生命周期跟随对象，对象被JVM回收后就无法访问了。

我们可以为成员变量或方法添加"static"关键字，使其成为类的静态成员，这些变量或方法被类生成的所有对象共享。静态成员的生命周期跟随其所属的类，当JVM第一次加载某个类时，其中的静态变量将被初始化并分配资源；直到类被JVM卸载（通常是进程结束的时刻），静态变量的资源才会被释放。

定义与访问静态成员的语法如下文所示：

```text
/* 定义静态成员 */
class <类名> {

    // 定义静态变量
    static <变量类型> <变量名称> = <初始值>;

    // 定义静态方法
    static <返回值> <方法名称>({参数列表}) {
        // 方法体 ...
    }
}

/* 访问静态成员 */
// 通过类名访问静态变量（常用）
<类名>.<静态变量或方法>

// 通过对象名访问静态变量
<对象>.<静态变量或方法>
```

我们可以通过类或对象访问静态变量与方法，由于它的生命周期跟随类，我们更习惯于通过类名进行访问。

"TestStatic.java":

```java
public class TestStatic {

    // 定义静态变量
    public static int num = 100;

    // 测试方法
    public static void main(String[] args) {
        // 创建第一个对象，修改静态变量"num"的值
        TestStatic obj1 = new TestStatic();
        obj1.num = -1;
        System.out.println("对象1读取到的num变量值: " + obj1.num);

        // 创建第二个对象，读取静态变量"num"的值。
        TestStatic obj2 = new TestStatic();
        System.out.println("对象2读取到的num变量值: " + obj2.num);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
对象1读取到的num变量值: -1
对象2读取到的num变量值: -1
```

根据上述输出内容可知：

对象1将静态变量"num"的值修改为"-1"后，对象2读取到的值也为"-1"，说明该变量被类的所有对象共享。

静态方法可以访问静态变量与其它静态方法，但无法访问非静态成员。我们常用的 `main()` 方法就是一个静态方法，因此JVM不需要新建测试类的对象即可直接执行其中的语句。

## 初始化块
初始化块提供了一种初始化成员变量的方式，我们可以在其中对成员变量进行赋值，将较为复杂的语句从类的头部移除，提高代码可读性。

一个类可以包含多个初始化块，当我们创建类的实例时，系统就会按照书写顺序依次执行这些代码块，然后执行构造方法中的逻辑。

如果我们使用"static"关键字修饰初始化块，它就会成为静态初始化块，类加载时将被最先执行，并且只会执行一次。静态初始化块只能用来初始化静态成员变量，以及调用静态方法。

初始化块的语法为：

```text
// 初始化块
{
	<初始化操作...>
}

// 静态初始化块
static {
	<初始化操作...>
}
```

我们在测试类中书写一些初始化块，测试它们的执行顺序与次数。

"TestInitBlock.java":

```java
public class TestInitBlock {

    static int a;
    int b;

    // 静态初始化块，用于初始化静态成员变量。
    static {
        System.out.println("静态初始化块执行了...");
        a = 100;
    }

    // 初始化块，用于初始化静态成员变量。
    {
        System.out.println("初始化块执行了...");
        b = 200;
    }

    // 构造方法
    public TestInitBlock() {
        System.out.println("构造方法执行了...");
    }

    // 测试方法
    public static void main(String[] args) {
        // 连续构建两个本类的对象，观察各模块的执行次数与顺序。
        System.out.println("开始创建第一个对象：");
        new TestInitBlock();
        System.out.println();
        System.out.println("开始创建第二个对象：");
        new TestInitBlock();
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
静态初始化块执行了...
开始创建第一个对象：
初始化块执行了...
构造方法执行了...

开始创建第二个对象：
初始化块执行了...
构造方法执行了...
```

根据上述输出内容可知：

当 `new TestInitBlock()` 语句被执行时，测试类被JVM加载，静态初始块首先被执行，且只会执行一次。当创建第一个对象时，初始化块、构造方法依次被执行；当创建第二个对象时，初始化块再次被执行。

# 空值安全
## 简介
引用类型变量存储的是指向堆内存的地址，如果一个引用类型变量并未指向任何堆内存，它的值就为"null"，也被称为“空值对象”。

空值对象产生的原因可能是：全局变量未经初始化、程序员主动将变量赋值为"null"、方法的返回值为"null"等，其中部分情况是编码遗漏、时序不当这类错误；而另外的部分情况则是空值具有特殊含义，例如：从数据库中查询学生信息时，返回非空Student对象表示存在记录；返回空的Student对象则表示不存在记录。

如果我们试图访问空值对象中的变量或方法，就会产生空指针异常 `NullPointerException` ，这种异常也被简称为NPE，经常导致程序意外崩溃，详见下文的示例代码：

"TestNullSafe.java":

```java
// 创建一个值为空的对象"zhangsan"
Person zhangsan = null;
// 调用该对象的方法
zhangsan.speak();
```

此时运行示例程序，并查看控制台输出信息：

```text
Exception in thread "main" java.lang.NullPointerException
	at net.bi4vmr.study.nullsafe.TestClass.main(TestClass.java:17)
```

## 判断可空变量
当我们操作一个值可能为空的变量时，应当先对其进行空值判断，若值不为空再调用它的变量与方法，防止出现NPE。

"TestNullSafe.java":

```java
// 创建一个值为空的对象"zhangsan"
Person zhangsan = null;

// 判断对象是否为空
if (zhangsan != null) {
    // 调用该对象的方法
    zhangsan.speak();
} else {
    System.out.println("对象为空，放弃操作！");
}
```

# Object类
## 简介
Object类是 `java.lang` 包中的核心类，它是所有类的顶级父类，其他的类都直接或间接地继承自Object。

Object类拥有一些实用的方法，后文章节将对它们进行详细的介绍。

## 输出对象信息
Object拥有 `String toString()` 方法，该方法能够以字符串形式展示对象的详情，我们可以用它输出日志以便调试。

`toString()` 方法默认返回对象在内存中的哈希值，我们自定义的对象通常需要重写该方法，输出重要的成员变量信息。

以前文的Person类为例，我们可以重写该方法，并输出Person实例的名称、年龄、性别。

"Person.java":

```java
public class Person {

    /* 属性 */
    String name;
    int age;
    char sex;

    /* 此处省略构造方法等 ... */

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", sex=" + sex +
                '}';
    }
}
```

我们在测试类中创建一个Person对象，并使用控制台打印方法输出该对象的信息。

"TestObject.java":

```java
// 构建对象
Person person = new Person("张三", 22, '男');
// 打印对象信息
System.out.println("对象信息：" + person);
```

对于 `print()` 方法，其内部会自动调用对象的 `toString()` 方法，因此我们只需要书写 `person` ，而不需要书写 `person.toString()` ；如果传入的对象为空值， `print()` 方法会将其输出为"null"，而不会导致空指针异常。

此时运行示例程序，并查看控制台输出信息：

```text
对象信息：Person{name='张三', age=22, sex=男}
```

## 对象之间的判等
对于基本数据类型，我们可以直接使用 `A == B` 来判断变量A与B的值是否相等，而对于引用数据类型，双等号比较的是两个对象内存地址是否一致，因此有时双等号无法得到正确的结果。

我们在测试类中创建两个Person对象，并设置相同的属性，然后比较它们是否相等。

"TestObject.java":

```java
Person person1 = new Person("张三", 22, '男');
Person person2 = new Person("张三", 22, '男');

System.out.println("使用等号比较两个对象：" + (person1 == person2));
System.out.println("使用\"equals()\"比较两个对象：" + (person1.equals(person2)));
```

此时运行示例程序，并查看控制台输出信息：

```text
使用等号比较两个对象：false
使用"equals()"比较两个对象：false
```

当我们使用"new"关键字创建对象时，JVM将会在堆内存中分配一块新的空间，因此即使两个Person对象的属性完全相同，它们的内存地址也是不同的，双等号将会返回"false"。

Object类的 `equals()` 方法默认比较方式与双等号相同，因此也返回了"false"，我们可以在Person类中重写该方法，覆盖默认的比较规则。

"Person.java":

```java
public class Person {

    String name;
    int age;
    char sex;

    /* 此处省略构造方法等 ... */

    @Override
    public boolean equals(Object o) {
        // 如果两个对象的内存地址相同，则可以直接判定相等。
        if (this == o) {
            return true;
        }

        // 如果传入对象为空，或对象类型与当前类不一致，则可以直接判定不等。
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        // 比较对象的每个属性是否相等
        Person person = (Person) o;
        return age == person.age &&
                sex == person.sex &&
                Objects.equals(name, person.name);
    }
}
```

我们首先比较了传入对象的内存地址是否与当前对象相等、传入对象是否非空、传入对象类型与本类是否一致；如果这些条件均满足，再比较传入对象的每个属性值是否与当前对象相等，如果所有属性均相等，则认为两个对象是相等的；如果任意一个属性不相等，则认为两个对象是不等的。

此时我们再次运行前文的示例代码，可以发现 `equals()` 方法返回值为"true"，因为两个Person对象的所有属性都是一致的，虽然它们的内存地址不同，但逻辑上可以被认为是等价的。

我们可以根据实际需要设计判等方式，提高程序执行效率。前文的Person类没有唯一的ID，因此我们需要对比所有属性；如果某个实体拥有唯一的ID，我们也可以只比较ID是否相等，不必遍历所有的属性。

## 对象的哈希值
哈希算法能够快速地将无限的输入内容转为有限的消息摘要，在很多场景中都有应用。

以我们常用的MD5算法为例，字符串A与B如果具有不同的消息摘要，它们一定是不同的；如果具有相同的消息摘要，它们可能是相同的，这是因为有限的消息摘要对应无限的输入内容，必然有至少两个输入内容对应着同一个消息摘要，这种情况被称为“哈希碰撞”。

假如内存中有10000个对象，它们按照顺序依次排列，当我们需要查找某个对象时，它可能正好位于队列尾部，该过程需要遍历先前的9999个对象，消耗了大量的时间。

对象的哈希值用于标识对象在内存中的存储区域，我们可以通过哈希算法将对象分组，然后把具有相同哈希值的对象存放在同一组中。当我们需要查找某个对象时，首先通过哈希算法快速查找其所属的组，再尝试匹配组内的对象，这种机制减少了查找时间。

我们在测试类中创建两个属性完全相同的对象，并调用它们的 `hashCode()` 方法查看哈希值。

"TestObject.java":

```java
Person person1 = new Person("张三", 22, '男');
Person person2 = new Person("张三", 22, '男');

System.out.println("person1的哈希值：" + person1.hashCode());
System.out.println("person2的哈希值：" + person2.hashCode());
```

此时运行示例程序，并查看控制台输出信息：

```text
person1的哈希值：1239731077
person2的哈希值：557041912
```

根据上述输出内容可知：

即使两个对象的属性完全相同，JVM默认算法得出的哈希值也不相等。这种情况会导致某些场景中出现错误，例如：我们向HashMap等容器中存入对象，取出时却得到了空值。根据前文所述，如果两个对象的 `equals()` 结果相同，它们的哈希值理应是相等的，否则从容器中查找对象时，就会因为判等失败导致匹配不到对象。

综上所述，当我们重写 `equals()` 方法时，也要重写 `hashCode()` 方法，并将所有需要比较的属性纳入哈希计算。

"Person.java":

```java
public class Person {

    /* 属性 */
    String name;
    int age;
    char sex;

    /* 此处省略构造方法等 ... */

    @Override
    public int hashCode() {
        return Objects.hash(name, age, sex);
    }
}
```

此时再次运行程序，我们可以观察到两个对象的哈希值是相同的，能够满足要求。

当我们重写 `hashCode()` 方法后，可以将其用于对象的判等。因为哈希算法效率较高，我们可以先比较两个对象的哈希值，若不相同，可直接判定两个对象不同；若相同，为防止哈希碰撞再进一步比较所有属性。

"Person.java":

```java
public class Person {

    /* 属性 */
    String name;
    int age;
    char sex;

    /* 此处省略构造方法等 ... */

    @Override
    public boolean equals(Object o) {
        // 如果两个对象的内存地址相同，则可以直接判定相等。
        if (this == o) {
            return true;
        }

        // 如果传入对象为空，或对象类型与当前类不一致，则可以直接判定不等。
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        // 比较对象的哈希值是否相等
        if (hashCode() != o.hashCode()) {
            return false;
        }

        // 比较对象的每个属性是否相等
        Person person = (Person) o;
        return age == person.age &&
                sex == person.sex &&
                Objects.equals(name, person.name);
    }
}
```

Java的哈希计算方法是一个Native方法，我们可以通过JVM启动参数调整计算策略。

```text
java -jar <JAR包> -XX:hashCode=<策略代码>
```

常用的哈希策略代码及其含义如下文所示：

🔷 "0"

调用操作系统的随机数API获取随机数。

🔷 "1"

在STW(stop-the-world)操作中，利用对象地址进行计算。

🔷 "2"

始终返回"1"，仅用于测试。

🔷 "3"

从0开始线性分配哈希值，这种方式不是线程安全的，多线程操作时可能产生相同的值。

🔷 "4"

返回对象在内存空间中的实际位置。

🔷 "5"

默认策略，使用Marsaglia的"xor-shift"算法产生伪随机数，支持多线程。
