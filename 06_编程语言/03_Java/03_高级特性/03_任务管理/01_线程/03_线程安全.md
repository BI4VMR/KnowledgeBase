# 竞态条件
由于线程的执行过程具有随机性，当多个线程都需要修改同一个共享变量时，就有可能出现逻辑错误，这种情况被称为“竞态条件(Race Condition)”。

🔴 示例一

在本示例中，我们以“多人购买同一款商品”为例，展示竞态条件造成的问题。

第一步，我们创建BuyThread类来模拟购买商品的过程。

"BuyThread.java":

```java
public class BuyThread extends Thread {

    // 静态全局变量，表示商品的剩余数量，初始为10件。
    static int count = 10;

    @Override
    public void run() {
        while (true) {
            // 判断如果商品仍有存货，则进行购买。（动作一）
            if (count > 0) {
                // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
                count--;
                // 输出日志（动作三）
                System.out.println(getName() + ": Buy good with index: " + (count + 1));
            } else {
                break;
            }
        }
    }
}
```

全局变量 `count` 表示商品的剩余数量，它是一个静态变量，因此多个BuyThread对象读写的内存区域是相同的。

第二步，我们在测试代码中创建3个BuyThread对象，分别模拟3个不同的客户。

"TestThreadSync.java":

```java
// 定义三个线程，模拟三个客户，它们的任务都是循环购买商品。
Thread thread1 = new BuyThread();
thread1.setName("客户1");
Thread thread2 = new BuyThread();
thread2.setName("客户2");
Thread thread3 = new BuyThread();
thread3.setName("客户3");

// 依次开启三个任务，模拟三个客户的购买行为。
thread1.start();
thread2.start();
thread3.start();
```

此时运行示例程序，并查看控制台输出信息：

```text
客户1: Buy good with index: 10
客户2: Buy good with index: 8
客户3: Buy good with index: 8
客户1: Buy good with index: 8
客户2: Buy good with index: 7
客户1: Buy good with index: 6
客户1: Buy good with index: 4
客户3: Buy good with index: 5
客户2: Buy good with index: 3
客户2: Buy good with index: 2
客户1: Buy good with index: 1
客户3: Buy good with index: 0
```

根据上述输出内容可知：

多个客户在购买同一款商品时，出现了以下两个问题：

🔷 重复购买

首先线程1执行一次循环体，剩余商品数量从10变为9；此时线程2执行完动作二（变量自减）后失去CPU执行权并暂停，剩余商品数量从9变为8；线程3也在自减动作后暂停，剩余商品数量从8变为7；接着线程2与线程3重新获取到CPU执行权，开始执行动作三（打印日志），此时它们获取的商品剩余数量均为7，因此显示的商品编号均为8。

🔷 超出范围

当剩余商品数量为1时，线程1执行动作一（判断剩余商品数量）通过判断并暂停，由于并未执行动作二，剩余商品数量仍然为1，此时线程3执行动作一，也满足循环条件；后续线程1与线程3依次恢复并执行循环体，线程3就会购买到超出范围的商品（编号为0）。

<br />

> 🚩 提示
>
> 现代计算机CPU性能较高且核心数量较多，上述两种情况可能不会同时出现，甚至都不出现。
> 
> 遇到这种现象时，我们可以增大商品总数并多次运行程序进行测试。
<!-- 
为了解决共享数据的竞态条件问题，我们可以引入线程之间的协调机制，以实现线程安全：当任意一个“购买商品”任务开始后，其中的三个操作必须连续执行完毕（体现了并发的原子性），在此期间其他的“购买商品”任务都将暂停运行，防止它们修改共享变量导致出错；当前一个任务的步骤都完成后再执行后一个任务，以此类推直到商品卖完。

这种协调机制被称为“同步”，能够将不可分割的中将线程的随机执行限制为顺序执行。

JUC提供了一些“锁”工具，我们可以将需要保持原子性的代码块上锁，当多个调用者调用同步代码片段时，最先抢到同步锁的调用者可以执行，其他调用者只能等待，以此实现线程安全。后文章节将介绍JUC中的“锁”工具。 -->

# 同步代码块
