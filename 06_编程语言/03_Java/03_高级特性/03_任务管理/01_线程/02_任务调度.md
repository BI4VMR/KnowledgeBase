# 顺序执行任务
线程的 `run()` 方法与普通方法相同，其中的语句将会按照书写顺序执行，当前一个语句执行完毕后，后一个语句才会开始执行，以此类推直到所有语句都执行完毕。

🔴 示例一

在本示例中，我们创建一个线程，并调用两次 `task()` 方法。

第一步，我们定义 `task(String name, long time)` 方法，该方法会使调用它的线程休眠 `time` 毫秒，并在休眠前后向控制台输出一些信息。

"TestCooperation.java":

```java
static void task(String name, long time) {
    try {
        System.out.println("Task " + name + " start. Name:[" + getName() + "] Time:[" + getTime() + "]");
        Thread.sleep(time);
        System.out.println("Task " + name + " end. Name:[" + getName() + "] Time:[" + getTime() + "]");
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

第二步，我们创建一个线程，调用两次 `task()` 方法，并观察执行顺序。

"TestCooperation.java":

```java
Thread thread = new Thread(() -> {
    // 先执行第一个任务
    task("A", 2000L);
    // 第一个任务执行完毕后，再执行第二个任务。
    task("A", 2000L);
});
thread.start();
```

此时运行示例程序，并查看控制台输出信息：

```text
Task A start. Thread:[Thread-0] Time:[14:55:45.261]
Task A end. Thread:[Thread-0] Time:[14:55:47.280]
Task B start. Thread:[Thread-0] Time:[14:55:47.281]
Task B end. Thread:[Thread-0] Time:[14:55:49.282]
```

根据上述输出内容可知：

线程首先执行TaskA，当TaskA执行完毕之后，继续执行TaskB，两个任务是串行关系。

# 并发执行任务
我们可以在现有线程中创建新的Thread对象并启动线程，这些线程将会同步推进，默认情况下没有顺序依赖关系。

🟠 示例二

在本示例中，我们创建两个线程，分别调用 `task()` 方法。

"TestCooperation.java":

```java
// 定义线程A并启动它
Thread threadA = new Thread(() -> {
    task("A", 2000L);
});
threadA.start();

// 定义线程B并启动它
Thread threadB = new Thread(() -> {
    task("B", 2000L);
});
threadB.start();
```

此时运行示例程序，并查看控制台输出信息：

```text
Task A start. Thread:[Thread-0] Time:[17:03:45.228]
Task B start. Thread:[Thread-1] Time:[17:03:45.228]
Task A end. Thread:[Thread-0] Time:[17:03:47.239]
Task B end. Thread:[Thread-1] Time:[17:03:47.239]
```

根据上述输出内容可知：

TaskA与TaskB同时启动、同时运行完毕，二者是并行推进的，没有相互等待。












## 礼让
我们可以使已经进入“运行”状态的线程暂停，回到“就绪”状态，让出CPU资源。

🔷 `void yeild()`

静态方法，使得当前线程让出CPU资源。

<br />

线程让出CPU资源后，将重新进入就绪队列等待调度，此时该线程也有可能立刻被调度，继续执行。

## 插队
我们可以在当前线程的作用域内，调用其他线程的 `join()` 方法，使当前线程阻塞，等待其他线程执行完毕后，当前线程再继续执行任务。

我们可以通过以下两个方法使线程插队：

🔶 `void join()`

暂停当前线程，使被调用 `join()` 的线程插队至当前线程之前执行。

🔶 `void join(long millis)`

该方法与无参的 `join()` 方法功能相同，但还设置了超时时间。如果到达超时时间后，插队线程仍未执行完毕，当前线程就会自动唤醒，不再等待。

<br />

我们在主线程与子线程中都循环打印消息，并且在主线程开始打印前，使子线程插队至主线程前执行。

"TestThread.java":

```java
MyThread subThread = new MyThread();
// 启动子线程
subThread.start();

try {
    // 使子线程插队至主线程前执行。
    subThread.join();
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}

// 在主线程中输出消息
for (int i = 1; i <= 5; i++) {
    System.out.println("Print some messages in thread:Main, index:" + i);
}
```

子线程如果收到其他消息而中断，将会抛出异常：InterruptedException，我们可以在此处清理资源。

此时运行示例程序，并查看控制台输出信息：

```text
Print some messages in thread:Thread-0, index:1
Print some messages in thread:Thread-0, index:2
Print some messages in thread:Thread-0, index:3
Print some messages in thread:Thread-0, index:4
Print some messages in thread:Thread-0, index:5
Print some messages in thread:Main, index:1
Print some messages in thread:Main, index:2
Print some messages in thread:Main, index:3
Print some messages in thread:Main, index:4
Print some messages in thread:Main, index:5
```

根据上述输出内容可知：

主线程被插队后，阻塞至子线程执行完毕后才执行。
