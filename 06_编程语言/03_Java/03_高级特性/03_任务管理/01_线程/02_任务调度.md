## 礼让
我们可以使已经进入“运行”状态的线程暂停，回到“就绪”状态，让出CPU资源。

🔷 `void yeild()`

静态方法，使得当前线程让出CPU资源。

<br />

线程让出CPU资源后，将重新进入就绪队列等待调度，此时该线程也有可能立刻被调度，继续执行。

## 插队
我们可以在当前线程的作用域内，调用其他线程的 `join()` 方法，使当前线程阻塞，等待其他线程执行完毕后，当前线程再继续执行任务。

我们可以通过以下两个方法使线程插队：

🔶 `void join()`

暂停当前线程，使被调用 `join()` 的线程插队至当前线程之前执行。

🔶 `void join(long millis)`

该方法与无参的 `join()` 方法功能相同，但还设置了超时时间。如果到达超时时间后，插队线程仍未执行完毕，当前线程就会自动唤醒，不再等待。

<br />

我们在主线程与子线程中都循环打印消息，并且在主线程开始打印前，使子线程插队至主线程前执行。

"TestThread.java":

```java
MyThread subThread = new MyThread();
// 启动子线程
subThread.start();

try {
    // 使子线程插队至主线程前执行。
    subThread.join();
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}

// 在主线程中输出消息
for (int i = 1; i <= 5; i++) {
    System.out.println("Print some messages in thread:Main, index:" + i);
}
```

子线程如果收到其他消息而中断，将会抛出异常：InterruptedException，我们可以在此处清理资源。

此时运行示例程序，并查看控制台输出信息：

```text
Print some messages in thread:Thread-0, index:1
Print some messages in thread:Thread-0, index:2
Print some messages in thread:Thread-0, index:3
Print some messages in thread:Thread-0, index:4
Print some messages in thread:Thread-0, index:5
Print some messages in thread:Main, index:1
Print some messages in thread:Main, index:2
Print some messages in thread:Main, index:3
Print some messages in thread:Main, index:4
Print some messages in thread:Main, index:5
```

根据上述输出内容可知：

主线程被插队后，阻塞至子线程执行完毕后才执行。
