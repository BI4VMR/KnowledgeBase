# 简介
普通变量的类型在声明时就被确定了，这在框架开发过程中不够灵活。假如我们正在开发能够存放大量同类实例的容器，元素可以是String、Date或者任何其他类型；由于我们不可能预先知道使用者会存入何种元素，只能将实例类型设为Object，

在下文示例中，我们定义了一个类用于表示二维平面上的坐标，坐标可以支持整数、小数、文本等多种格式。

"Location1.java":

```java
public class Location1 {

    private Object x, y;

    // 构造实例并设置坐标
    public Location1(Object x, Object y) {
        this.x = x;
        this.y = y;
    }

    // 获取坐标(X)
    public Object getX() {
        return x;
    }

    // 获取坐标(Y)
    public Object getY() {
        return y;
    }
}
```

由于每个变量只能被声明为一个类型，若定义为Integer就无法传入文本，若定义为String则无法传入数字，因此我们只能将坐标的数据类型定义为所有类的顶级父类Object。

在测试方法中，我们创建一个Location1实例，然后调用获取坐标的 `getX()` 和 `getY()` 方法，读取坐标值并比较其是否与指定的值相等。

"TestBase.java":

```java
// 使用数字类型数据创建实例
Location1 i1 = new Location1();
i1.setXY(100, 25.1082);

// 读取数据时需要判断具体的类型
Object xRaw = i1.getX();
if (xRaw instanceof Integer) {
    // 将数据转换为具体类型再操作
    boolean resultX = ((Integer) xRaw).compareTo(100) == 0;
    System.out.println("x = 100? " + resultX);
} else if (xRaw instanceof Double) {
    boolean resultX = ((Double) xRaw).compareTo(100.0) == 0;
    System.out.println("x = 100? " + resultX);
} else {
    throw new IllegalArgumentException("参数类型错误！");
}
// 比较Y轴的数据时也需要判断类型，此处省略相关代码。
```

由于坐标的数据类型为Object，我们首先需要判断其具体类型，然后才能进行比较操作，并且在数据类型不合法时抛出异常。

上述示例代码中的判断逻辑非常繁琐，降低了程序的可维护性；并且调用者在构造Location1实例时可以传入任何类型的数据，需要到程序运行阶段才会发现错误，降低了程序的稳定性：

"TestBase.java":

```java
// 创建实例时随便传入非法数据也不会出错，只在读取数据时才能发现错误。
Location1 i2 = new Location1(TestBase.class, Thread.currentThread());
```
# 基本应用
我们可以使用泛型来表示坐标值的类型，使得调用者自行决定需要使用何种数据类型，以解决前文示例中的部分问题。

"Location2.java":

```java
public class Location2<T1, T2> {

    // 变量"x"和"y"的类型由外部调用者决定
    private T1 x;
    private T2 y;

    // 构造实例并设置坐标
    public Location2(T1 x, T2 y) {
        this.x = x;
        this.y = y;
    }

    // 获取坐标(X)
    public T1 getX() {
        return x;
    }

    // 获取坐标(Y)
    public T2 getY() {
        return y;
    }
}
```

上述示例代码中的坐标变量 `x` 和 `y` 类型为两个泛型类型，而不是某种具体的数据类型，此时构造方法的参数与获取坐标方法的返回值也被设为对应的泛型类型，不再是宽泛的Object类型。

在测试方法中，我们创建一个Location2实例，然后调用获取坐标的 `getX()` 和 `getY()` 方法，读取坐标值并比较其是否与指定的值相等。

"TestBase.java":

```java
// 使用数字类型数据创建实例
Location2<Integer, Double> i1 = new Location2<>(100, 25.1082);

// 读取数据时无需判断类型，与创建实例时的类型一致。
Integer x = i1.getX();
boolean resultX = x.compareTo(100) == 0;
System.out.println("x = 100? " + resultX);
// 比较Y轴的数据时无需判断类型，此处省略相关代码。
```

当我们构建Location2实例时，已经在类名后的尖括号内指明了两个方向坐标变量的数据类型，因此 `getX()` 与 `getY()` 方法也会返回对应类型的数据，无需再进行类型判断。

此时如果我们创建一个Location2实例，并传入一些类型与泛型不一致的数据，编译时编译器将会提示数据类型不匹配，使我们提早发现错误。

"TestBase.java":

```java
// 构造方法参数与声明实例时的泛型类型不一致，编译时将会报错。
Location2<Integer, Double> i2 = new Location2<>(TestBase.class, Thread.currentThread());
```


泛型(Generics)是JDK 5引入的特性，也被称为“参数化类型”，我们在设计集合等工具时，可以只声明

定义泛型的语法如下文代码块所示：

```text
// 声明包含泛型的类
class 类名<泛型占位符I，泛型占位符II，...> {
    // 在变量或方法中使用占位符 ...
}
```

类名后的尖括号 `<>` 代表占位符，表示当前类是一个泛型类，常用的其他名称有：


```text
class 类名<T1，T2，...> extend 父类名称<T1> {

}
```

在上述代码块中






- `T` : Type，泛指任何类型。
- `E` : Element，表示集合中的元素。
- `K` : Key，表示键名。
- `V` : Value，表示键值。
- `N` : Number，表示数字。



可以通过泛型实例化一个泛型对象

    泛型类<类型实参> 变量名; // 定义一个泛型类引用
    new 泛型类<类型实参>(构造方法实参); // 实例化一个泛型类对象
     
    MyArray<Integer> list = new MyArray<Integer>();

当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写

MyArray<Integer> list = new MyArray<>(); // 可以推导出实例化需要的类型实参为 Integer

泛型只能接受类，所有的基本数据类型必须使用包装类 


# 类型擦除
Java语言的泛型只在编译前有效，以便IDE进行语法检查提前发现错误；当源代码被编译为字节码后，泛型类型将被替换为Object或上界类型。

此处我们创建前文示例中的Location2实例，通过泛型指定X轴坐标为Integer类型、Y轴坐标为Double类型，然后获取Location2内部变量的数据类型。

"TestBase.java":

```java
// 创建实例并指定类型
Location2<Integer, Double> location = new Location2<>(100, 25.1082);
// 尝试获取变量的类型
Field[] fields = location.getClass().getDeclaredFields();
for (Field f : fields) {
    System.out.println("变量名称：" + f.getName());
    System.out.println("变量类型：" + f.getType());
}
```

此时运行示例程序，并查看控制台输出信息：

```text
变量名称：x
变量类型：class java.lang.Object
变量名称：y
变量类型：class java.lang.Object
```

根据上述输出内容可知：

即使我们通过泛型指明了变量类型，程序运行时获取到的类型仍然为Object。
