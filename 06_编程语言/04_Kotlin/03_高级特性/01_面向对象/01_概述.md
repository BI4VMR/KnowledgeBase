# 类与对象
## 简介
类(Class)是某个事物的静态模板，用于描述该事物所拥有的特征（属性）和行为（方法），例如：人类拥有性别、年龄等特征，以及说话、行走等行为。

对象(Object)则是类的具象化实体，拥有具体的属性和行为，例如：小明是男生，今年18岁，会说汉语及英语。为类赋予属性创建对象的过程被称为“实例化”，因此对象有时也被称为实例(Instance)。

定义类的语法如下文代码块所示：

```text
// 定义一个“类”
class <类名> {
    /* 成员变量... */
    val x :Int = 100;
    val y :Int = -100;

    /* 成员方法... */
    fun foo() {}
    fun boo() {}
}
```

创建与访问对象的语法如下文代码块所示：

```text
// 由类创建对象，并保存至变量。
var <变量名称> = <类名>();

// 通过变量引用访问对象的属性
<变量名称>.<属性>;
// 通过变量引用调用对象的方法
<变量名称>.<方法>([参数...]);
```

类的构造方法为 `<类名>()` 形式，用于从类创建对象；为了便于后续访问对象，我们通常会声明一个变量用于保存构造方法所创建对象的引用。

## 基本应用
下文示例展示了面向对象的基本编程范式。

🔴 示例一：面向对象的基本应用。

在本示例中，我们定义Person类描述“人类”，并创建一些对象。

第一步，我们定义Person类，声明姓名、年龄、性别三个属性，并声明“说话”方法，其行为是将三个变量的值输出到控制台上。

"Person.kt":

```kotlin
class Person {

    /* 属性 */
    var name: String = ""
    var age: Int = 0
    var sex: Char = '男'

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

第二步，我们基于Person类创建两个对象，并访问它们的属性与方法。

"TestClass.kt":

```kotlin
// 从模板“人类”创建实体“张三”
val zhangsan = Person()
// 设置属性
zhangsan.name = "张三"
zhangsan.age = 18
zhangsan.sex = '男'
// 调用方法
zhangsan.speak()

// 从模板“人类”创建实体“李四”
val lisi = Person()
lisi.name = "李四"
lisi.age = 20
lisi.sex = '女'
lisi.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
我是张三，年龄18岁，性别为男。
我是李四，年龄20岁，性别为女。
```

## 全局变量
类所拥有的属性被称为“成员变量”，前文“示例一”中的姓名、年龄、性别三个属性即为Person类的成员变量；此类变量的生命周期跟随对象：“张三”和“李四”各自都有这些属性，并且同名变量相互独立，修改“张三”的年龄不会影响“李四”的年龄。

成员变量的作用域为整个对象，我们可以在对象的任意位置访问它们（例如：前文“示例一”中的 `speak()` 方法），因此成员变量也被称为“全局变量”。我们习惯在成员变量的变量名之前加上 `m` 前缀（即Member的首字母），以便与其他作用域不同的变量作区分。

全局变量的初始值必须在其声明语句处立刻指明，或者由构造方法进行赋值，确保对象被创建后这些变量是可用的。如果我们在声明语句中为全局变量赋值，可以不指明其类型，由编译器自动进行推断，但我们更推荐明确写出变量类型，提高代码的可读性。

🟠 示例二：全局变量的基本应用。

在本示例中，我们定义一个类并声明若干全局变量，然后在方法中访问它们。

第一步，我们创建类，并声明全局变量。

"TestScope.kt":

```kotlin
class TestScope {

    // 声明全局变量并指定初始值
    val x: Int = 1

    // 声明全局变量但由构造方法指定初始值
    val y: String

    constructor(value: String) {
        // 使用构造方法的参数为全局变量设置初始值。
        y = value
    }

    // 访问全局变量
    fun useGlobalVariables() {
        println("x:[$x]")
        println("y:[$y]")
    }
}
```

第二步，我们在测试代码中创建TestScope对象，并调用 `useGlobalVariables()` 方法访问全局变量。

"TestScope.kt":

```kotlin
// 创建测试类的对象
val instance = TestScope("ABC")
// 访问全局变量
instance.useGlobalVariables()
```

此时运行示例程序，并查看控制台输出信息：

```text
x:[1]
y:[ABC]
```

根据上述输出内容可知：

全局变量 `x` 的值为声明它时指定的 `1` ， `y` 的值为测试代码调用构造方法时指定的 `ABC` ，符合预期。

## 局部变量
与全局变量相反，我们在代码块 `{}` 中声明的变量被称为“局部变量”，它们的作用域仅限其所在的代码块，通常用于保存临时性的数据；当代码块中的语句执行完毕后变量就会失效，基本数据类型变量所占用的内存将被立刻回收，引用数据类型变量所占用的内存由垃圾收集器安排择机回收。

🟡 示例三：局部变量的基本应用。

在本示例中，我们定义一个方法并声明局部变量，然后在另一个方法中访问它。

"TestScope.kt":

```kotlin
class TestScope {

    // 局部变量测试方法一
    fun function1() {
        // 声明局部变量 `temp`
        val temp = 0
    }

    // 局部变量测试方法二
    fun function2() {
        // 此处无法访问 `function1()` 方法中的局部变量 `temp` ，编译器会提示错误。
        println(temp)
    }
}
```

在上述代码中，方法 `function1()` 内部定义的局部变量 `temp` 无法被方法 `function2()` 访问， `println(temp)` 语句会导致编译错误。

## 构造方法
### 简介
构造方法是用于创建对象的特殊方法，它与类同名并且固定返回新的实例，因此我们不能指定它的返回值类型。我们可以为构造方法定义参数列表，通过调用者传入的参数为全局变量赋值，初始化新创建的实例。

当我们没有在代码中声明构造方法时，类默认拥有一个无参数、方法体为空的构造方法。在前文“示例一”中，变量等号右侧的 `Person()` 语句即为默认构造方法。

### 主要构造方法
Kotlin类只能拥有单个主要构造方法，默认形式为 `public constructor()` ，此时我们可以省略这些字符；若要更改参数列表或访问修饰符，则不可省略。

🟢 示例四：使用主要构造方法初始化对象。

在本示例中，我们对前文“示例一”所定义的Person类进行修改，为构造方法添加姓名、年龄两个参数，并为对应的全局变量赋值，完成对象的初始化。

第一步，我们编写新的Person类代码，并修改默认的构造方法。

"Person2.kt":

```kotlin
class Person2 constructor(
    name: String,
    age: Int
) {

    /* 属性 */
    var name: String = ""
    var age: Int = 0

    /* 初始化块 */
    init {
        println("使用主要构造方法初始化对象...")
        this.name = name
        this.age = age
    }

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁。")
    }
}
```

在上述代码中， `constructor(name: String, age: Int)` 即主要构造方法，它没有方法体，我们需要在 `init {}` 块中编写初始化逻辑代码，该块将在主要构造方法执行时被调用，并且可以访问构造方法声明的参数。一个类中可以存在多个 `init {}` 块，此时将会按照编写顺序依次执行块中的语句。

在 `init {}` 块中，我们需要使用 `this` 关键字为全局变量完成赋值，这是因为构造方法的形参与全局变量同名，此时局部的型参优先级高于全局变量，语句 `name` 即表示型参 `name` ； `this` 关键字表示“当前类的对象”，语句 `this.name` 表示全局变量 `name` ，完整语句 `this.name = name` 表示将型参 `name` 的值赋予全局变量 `name` 。

第二步，我们在测试代码中调用Person2的主要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 使用主要构造方法创建对象
val zhangsan = Person2("张三", 18)
zhangsan.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
使用有参构造方法初始化对象...
我是张三，年龄18岁。
```

---

通过构造方法参数初始化全局变量是一种常用的操作，Kotlin提供了简化语法，当我们在主要构造方法的参数前添加 `val` 或 `var` 关键字后，该参数即与同名全局变量绑定，实例化时自动赋值，无需再手动声明全局变量并在构造方法中通过 `this` 调用赋值。

🔵 示例五：在主要构造方法中声明全局变量。

在本示例中，我们对前文“示例四”所定义的Person类进行修改，在构造方法中定义与参数同名的全局变量。

第一步，我们编写新的Person类代码。

"Person3.kt"

```kotlin
class Person3 constructor(
    val name: String,
    val age: Int,
    private val sex: Char = '男'
) {

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

在构造方法中声明全局变量的语法与类中相同，我们可以指定访问修饰符，也可以指定默认值，当调用者未传该值时自动以默认值初始化变量。

第二步，我们在测试代码中调用Person3的主要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 创建对象，可选参数使用默认值。
val lisi = Person3("李四", 20)
lisi.speak()

// 创建对象，可选参数使用指定值。
val alice = Person3("Alice", 22, '女')
alice.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
我是李四，年龄20岁，性别为男。
我是Alice，年龄22岁，性别为女。
```

### 次要构造方法
除了唯一的主要构造方法之外，我们还可以声明多个次要构造方法，以适应不同场景下的初始化条件。次要构造方法必须首先调用主要构造方法，或其他已调用主要构造方法的次要构造方法，满足创建对象的必要条件，然后才能执行自己的初始化逻辑。

🔵 示例六：使用次要构造方法初始化对象。

在本示例中，我们对前文“示例五”所定义的Person类进行修改，添加次要构造方法。

第一步，我们编写新的Person类代码。

"Person4.kt"

```kotlin
class Person4 constructor(
    val name: String,
    val age: Int,
    private val sex: Char = '男'
) {

    /* 初始化块 */
    init {
        println("初始化块...")
    }

    /* 次要构造方法 */
    constructor(name: String) : this(name, 18) {
        println("次要构造方法...")
    }

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

次要构造方法 `constructor(name: String)` 执行时，首先通过 `this(name, 18)` 语句调用主要构造方法，传入姓名和年龄属性，再继续执行次要构造方法的方法体语句。

第二步，我们在测试代码中调用Person4的次要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 使用次要构造方法创建对象
val lisi = Person4("李四")
lisi.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
初始化块...
次要构造方法...
我是李四，年龄18岁，性别为男。
```

根据上述输出内容可知：

次要构造方法被调用时，首先执行了初始化块（即主要构造方法），然后再执行次要构造方法中的语句。

## 伴生对象
### 简介
Kotlin中没有静态成员的概念，如果我们希望像Java等语言一样声明类级别的变量与方法，可以使用伴生对象，这种对象将在类被加载时初始化，我们可以直接通过类名访问其中的变量与方法。

定义伴生对象的语法如下文代码块所示：

```text
class <类名> {

    // 声明伴生对象
    companion object <对象名称> {
        /* 声明变量... */
        val x :Int = 100;
        val y :Int = -100;

        /* 声明方法... */
        fun foo() {}
        fun boo() {}
    }
}
```

访问伴生对象中属性与方法的语法如下文代码块所示：

```text
<类名>.<变量名称>
<类名>.<方法名称>([参数...])
```

每个类只能拥有一个伴生对象，因此它的名称可以省略，此时默认名称为 `Companion` 。

### 基本应用
下文示例展示了伴生对象的基本使用方法：

🟣 示例七：伴生对象的基本应用。

在本示例中，我们定义测试类并声明伴生对象，然后访问其中的变量与方法。

第一步，我们编写测试类代码。

"TestCompanion.kt"

```kotlin
class TestCompanion {

    // 声明伴生对象
    companion object {

        // 声明变量
        val x: String = "TEST"

        // 声明方法
        fun avg(a: Int, b: Int): Double {
            return ((a + b) / 2.0)
        }
    }
}
```

第二步，我们在测试代码中访问TestCompanion伴生对象中的属性与方法。

"TestCompanion.kt":

```kotlin
// 访问伴生对象中的属性
println("访问属性：${TestCompanion.x}")

// 访问伴生对象中的方法
println("访问方法：${TestCompanion.avg(6, 4)}")
```

此时运行示例程序，并查看控制台输出信息：

```text
访问属性：TEST
访问方法：5.0
```

---

当我们在伴生对象中声明基本数据类型或String类型的常量时，可以添加 `const` 关键字，此时编译器将会进行一些优化，提高运行效率。

🔴 示例八：了解"const"关键字的作用。

在本示例中，我们以JVM平台为基础，比较 `const` 常量与普通常量的区别。

第一步，我们编写测试类代码。

"TestCompanion2.kt"

```kotlin
class TestCompanion2 {

    companion object {

        // 声明"const"常量
        const val PI: Float = 3.141593F

        // 声明普通常量
        val X: String = "TEST"
    }
}
```

第二步，我们将测试类的字节码反编译为Java代码。

"TestCompanion2.java"

```java
public final class TestCompanion2 {

    // "const"常量
    public static final float PI = 3.141593F;

    // 普通常量
    private static final String X = "TEST";

    public static final class Companion {
        public final String getX() {
            return TestCompanion2.X;
        }
    }
}
```

普通常量 `X` 在JVM中生成了私有静态常量，以及公开方法 `getX()` ，调用语句 `TestCompanion2.X` 实际上需要通过方法读取常量值； `const` 常量 `PI` 对应的则是公开静态常量，调用者可以直接读取变量值，相比前者效率更高。

### 与Java交互
当我们使用Java访问伴生对象中的变量与方法时，需要通过内部类Companion；例如前文示例代码中的变量 `x` ，语法为 `TestCompanion.Companion.getX()` 。

我们可以查看Kotlin字节码对应的Java代码：

```java
public final class TestCompanion {

    private static final String x = "TEST";

    public static final class Companion {

        public final String getX() {
            return TestCompanion.x;
        }

        public final double avg(int a, int b) {
            return (double)(a + b) / 2.0;
        }
    }
}
```

根据上述内容可知：

伴生对象在Java中是一个静态内部类，包含访问静态变量的方法、伴生对象中定义的方法，内部类的名称取决于我们定义伴生对象时是否声明了自定义名称。

我们可以为伴生对象中的属性与方法添加 `@JvmStatic` 注解，这些属性与方法会在类中额外生成对应的静态成员。

"TestCompanion.kt":

```kotlin
class TestCompanion {

    // 伴生对象
    companion object {
        // 声明变量
        @JvmStatic
        val x: String = "TEST"

        // 声明方法
        @JvmStatic
        fun avg(a: Int, b: Int): Double {
            return ((a + b) / 2.0)
        }
    }
}
```

随后我们就可以在Java中直接通过类名访问伴生对象内部的变量与方法了，例如： `TestCompanion.getX()`  。

此时可以再次查看Kotlin字节码对应的Java代码：

```java
public final class TestCompanion {

    private static final String x = "TEST";

    // 注解生成的静态方法
    public static final String getX() {
        return x;
    }

    // 注解生成的静态方法
    public static final double avg(int a, int b) {
        return Companion.avg(a, b);
    }

    public static final class Companion {

        public final String getX() {
            return TestCompanion.x;
        }

        public final double avg(int a, int b) {
            return (double)(a + b) / 2.0;
        }
    }
}
```




# 空值安全
## 简介
引用类型变量存储的是指向堆内存的地址，如果一个引用类型变量并未指向任何堆内存，它的值就为"null"，也被称为“空值对象”。

空值对象产生的原因可能是：全局变量未经初始化、程序员主动将变量赋值为"null"、方法的返回值为"null"等，其中部分情况是编码遗漏、时序不当这类错误；而另外的部分情况则是空值具有特殊含义，例如：从数据库中查询学生信息时，返回非空Student对象表示存在记录；返回空的Student对象则表示不存在记录。

如果我们试图访问空值对象中的变量或方法，就会产生空指针异常 `NullPointerException` ，这种异常也被简称为NPE，经常导致程序意外崩溃。

Kotlin的类型系统能够标明对象是否可能为空值，当我们访问可空对象时，编译器将会检查代码是否进行了空值校验，以便提前发出错误提示，在一定程度上减少空指针异常。

默认情况下，变量是不可为空的，我们必须在声明变量时赋予有效的初始值。如果一个变量的值可以为空，我们需要在它的类型之后添加一个问号("?")作为标识。

"TestNullSafe.kt":

```kotlin
// 声明非空字符串"str1"
var str1: String = "字符串内容"
// 声明可空字符串"str2"
var str2: String? = null

// 将空值赋予非空字符串，该语句无法通过编译。
str1 = null
// 将空值赋予可空字符串，该语句可以通过编译。
str2 = null

// 调用无空变量的属性，该语句可以通过编译。
str1.length
// 调用可空变量的属性，该语句无法通过编译。
str2.length
```

在上述示例代码中，当我们将"null"赋值给非空变量、未经判空直接访问可空变量时，编译器都会产生错误提示，提示我们修正代码。

## 判断可空变量
当我们操作一个值可能为空的变量时，应当先对其进行空值判断，若值不为空再调用它的变量与方法，防止出现NPE。

"TestNullSafe.kt":

```kotlin
var str: String? = null

// 判断字符串是否为空值
if (str != null) {
    // 当变量不为空时，再访问其中的属性与方法。
    println(str.length)
} else {
    println("对象为空，放弃操作！")
}
```

## 安全调用操作符
当我们访问可空变量中的属性与方法时，可以使用安全调用操作符 `?.` 。

在表达式 `<对象>?.<方法或属性>` 中，如果对象为空值，该表达式的结果也为空值；如果对象不为空值，则表达式的结果为方法返回值或属性。

"TestNullSafe.kt":

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

// 使用安全调用操作符访问两个变量
println("str1的内容：" + str1?.length)
println("str2的内容：" + str2?.length)
```

在上述示例代码中，方法 `String.length()` 的返回值类型为 `Int` ，因此表达式 `str1?.length` 的返回值类型为 `Int?` 。

此时运行示例程序，并查看控制台输出信息：

```text
str1的内容：5
str2的内容：null
```

根据上述输出内容可知：

对象 `str1` 的值不为空，因此整个表达式的值为字符串长度"5"；对象 `str2` 的值为空，因此整个表达式的值为"null"。

当我们需要判断可空变量时，可以采用所有语言通用的等值判断语法，也可以使用安全调用操作符，有时后者比前者更为简洁。

"TestNullSafe.kt":

```kotlin
var str: String? = null

// 判断字符串是否为空值
if (str != null) {
    // 当变量不为空时，再访问其中的属性与方法。
    println(str.length)
}

// 上述逻辑的等价写法
str?.let {
    // 变量"it"等同于"str"
    println(it)
}
```

`<对象>.let{}` 是一个Kotlin标准库中的扩展函数，在其作用域内可以使用变量 `it` 访问对象。在上述示例代码中，我们结合安全调用操作符使用扩展函数，表达式为 `<对象>?.let{}` 。当对象为空时，表达式结果为"null"，整个语句将被忽略；当对象不为空时，将会执行 `let{}` 作用域中的语句。

当我们使用安全调用操作符时，扩展函数中的逻辑只在对象不为空值时执行，如果对象为空和非空时都需要执行一些逻辑，我们就无法使用安全调用操作符了。

## 级联判空
安全调用操作符可以级联使用，这有利于减少模板代码。

假设现有一个学生对象 `student` ，我们需要依次调用方法获取“所有课程”、“最新课程”、“最新课程的学分”。前述每个步骤获取到的对象均可能为空，因此我们需要按照如下步骤逐层进行空值判断。

```kotlin
// 获取学生的所有课程
val courses = student.getCourses()
if (courses != null) {
    // 获取最新选择的课程
    val latestCourse = courses.getLatestCourse()
    if (latestCourse != null) {
        // 获取课程的学分
        val credit = latestCourse.getCredit()
        println("学分：$credit")
    }
}
```

我们可以级联使用安全调用操作符，将上述代码简化为一行。

```kotlin
val credit = student?.getCourses()?.getLatestCourse()?.getCredit()
println("学分：$credit")
```

当程序运行至级联语句时，它会从左至右依次执行每个步骤，只要其中任意一个步骤的结果为空，整个表达式的结果即为空。

## Elvis运算符
Elvis运算符的形式为 `<表达式A> ?: <表达式B>` ，当表达式A的结果不为"null"时，整个语句的结果即表达式A的结果；当表达式A的结果为"null"时，整个语句的结果为表达式B的结果；

"TestNullSafe.kt":

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

val length1: Int = str1?.length ?: 0
val length2: Int = str2?.length ?: 0

println("str1的长度:$length1")
println("str2的长度:$length2")
```

此时运行示例程序，并查看控制台输出信息：

```text
str1的长度:5
str2的长度:0
```

根据上述输出内容可知：

字符串 `str1` 不为空，因此表达式 `str1?.length` 也不为空，此时整个Elvis语句的结果为 `str1?.length` 的结果。字符串 `str2` 为空，因此表达式 `str2?.length` 为空，此时整个Elvis语句的结果是"0"。

Elvis运算符通常用于设置左侧表达式为空时的默认值，此时右侧表达式将被直接填写为默认值。若右侧表达式包含修改其他变量的操作，则需要引起注意，仅当左侧表达式为空时，右侧表达式才会触发修改动作。

Elvis运算符的右侧表达式不仅支持普通数值运算，还能使用"return"和"throw"语句，我们可以按需使用。

```kotlin
// 在Elvis运算符中使用"return"和"throw"语句
fun getLength(str: String?): Int {
    str?.length ?: return 0
    str?.length ?: throw IllegalArgumentException("入参为空值！")
}
```

## 非空断言
非空断言运算符 `!!` 能够将可空变量引用转换为非空变量引用，跳过编译器的语法检查。

```kotlin
var str: String? = null
// 字符串为空时，终止进程。
runBlocking {
    if (str == null) {
        exitProcess(1)
    }
}

// 该语句无法编译通过
println(str.length)

// 该语句可以编译通过
println(str!!.length)
```

在上述代码中， `runBlocking {}` 块对 `str` 变量进行了判空，如果变量为空则退出程序；若代码能够执行到后续的 `println()` 语句，则 `str` 变量必然是非空的，但编译器无法识别跨作用域的判空语句，因此仍然认为该变量是可空的，要求我们判空后访问该变量。

非空断言只能用来解除Kotlin语法限制，其他任何情况下都不应当被使用，如果代码运行至非空断言时变量为空，则会抛出NPE导致程序崩溃。

## "requireNotNull()"方法
`requireNotNull(value: T?): T` 方法也是非空断言的一种形式，唯一参数 `value` 即需要进行断言的变量，返回值为该变量的非空类型。该方法与 `!!` 运算符的行为是一致的。

```kotlin
var str: String? = null
// 字符串为空时，终止进程。
runBlocking {
    if (str == null) {
        exitProcess(1)
    }
}

// 将变量转换为非空变量，并设置变量为空时的错误消息。
val nonNullStr = requireNotNull(str) { "预期之外的空值，请检查业务逻辑！" }
// 使用非空变量
println(nonNullStr.length)
println(nonNullStr.isEmpty())
```

requireNotNull() 的第二参数是一个表达式，如果断言失败将会被触发，表达式的返回值将被放入异常消息中，我们可以填写自定义提示语。



## 延迟加载非空变量
lateinit 关键字
适用于 var 且类型为非原生类型（如 String、对象等），允许稍后初始化。


class MyClass {
    lateinit var name: String
}
自定义 getter
通过 getter 动态返回值，适合需要计算或懒加载的场景。


class MyClass {
    val name: String
        get() = "computed"
}
by lazy 延迟初始化
适用于 val，在第一次访问时初始化，线程安全。


class MyClass {
    val name: String by lazy { "lazyValue" }
}



# 疑难解答
## 索引

<div align="center">

|       序号        |                        摘要                         |
| :---------------: | :-------------------------------------------------: |
| [案例一](#案例一) | 对可变全局变量判空后，IDE仍然提示无法安全地调用它。 |

</div>

## 案例一
### 问题描述
当我们对可变全局变量进行空值判断后，编译器仍然提示无法安全地调用它。

```kotlin
class Test {

    // 定义一个可变的全局变量
    var text: String? = null

    // 测试方法
    fun logic() {
        // 对变量"text"进行判空
        if (text != null) {
            // 将变量"text"传入参数不可为空的方法
            // 此处IDE将会提示错误，并且无法通过编译。
            show(text)
        }
    }

    // 显示信息的方法
    private fun show(info: String) {
        println(info)
    }
}
```

在上述示例代码中，我们首先对变量 `text` 进行空值判断，当其不为空值时，将它作为非空参数传递给 `show()` 方法。

此时IDE将在 `show(text)` 处提示以下错误信息：

```text
Smart cast to 'String' is impossible, because 'text' is a mutable property that could have been changed by this time.
```

### 问题分析
全局变量 `text` 是一个可变变量，这意味着它的值可以被任何线程修改。假设线程A通过空值判断后立刻休眠，线程B将该变量修改为空值；随后线程A恢复运行，此时线程A传给 `show()` 方法的参数即为空值，与该方法的参数非空要求不符。

如果我们将判空语句改为以下写法，虽然能够消除IDE错误提示并通过编译，但未从根本上解决线程安全问题。

```kotlin
// 错误示范一
fun logic() {
    // 使用非空断言，以符合语法检查要求。
    if (text != null) {
        show(text!!)
    }
}

// 错误示范二
fun logic() {
    // 使用内置函数"let"，不直接引用变量"text"。
    text?.let { show(it) }
}
```

在错误示范一中，非空断言强制改写变量 `text` 为非空，符合 `show()` 方法的参数要求，因此能够通过语法检查，但遇到前文所述的多线程场景时，仍然会出现空指针异常。

在错误示范二中，扩展函数 `let()` 作用域内的变量 `it` 等同于变量 `text` ，当函数体执行时， `it` 所指向的内存区域仍然可能被改为空值。

### 解决方案
该问题的正确解决方法如下文代码块所示：

```kotlin
fun logic() {
    // 声明局部变量存储全局变量"text"的引用。
    val temp: String? = text
    // 使用局部变量进行后续操作
    if (temp != null) {
        show(temp)
    }
}
```

我们在空值判断之前使用局部变量 `temp` 存储变量 `text` 的引用，由于局部变量跟随当前线程（该特性被称为“线程封闭”），即使后续全局变量 `text` 被改为空值，局部变量 `temp` 仍然持有原先的非空引用，因此实现了线程安全。

> 🚩 提示
>
> 关于“线程封闭”的相关概念，可以参考以下文章： [🔗 “线程封闭”的相关概念](https://www.cnblogs.com/binghe001/p/12808419.html) 。
