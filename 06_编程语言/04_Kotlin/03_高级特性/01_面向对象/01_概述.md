# 类与对象
## 简介
类(Class)是某个事物的静态模板，用于描述该事物所拥有的特征（属性）和行为（方法），例如：人类拥有性别、年龄等特征，以及说话、行走等行为。

对象(Object)则是类的具象化实体，拥有具体的属性和行为，例如：小明是男生，今年18岁，会说汉语及英语。为类赋予属性创建对象的过程被称为“实例化”，因此对象有时也被称为实例(Instance)。

定义类的语法如下文代码块所示：

```text
// 定义一个“类”
class <类名> {
    /* 成员变量... */
    val x :Int = 100;
    val y :Int = -100;

    /* 成员方法... */
    fun foo() {}
    fun boo() {}
}
```

创建与访问对象的语法如下文代码块所示：

```text
// 由类创建对象，并保存至变量。
var <变量名称> = <类名>();

// 通过变量引用访问对象的属性
<变量名称>.<属性>;
// 通过变量引用调用对象的方法
<变量名称>.<方法>([参数...]);
```

类的构造方法为 `<类名>()` 形式，用于从类创建对象；为了便于后续访问对象，我们通常会声明一个变量用于保存构造方法所创建对象的引用。

## 基本应用
下文示例展示了面向对象的基本编程范式。

🔴 示例一：面向对象的基本应用。

在本示例中，我们定义Person类描述“人类”，并创建一些对象。

第一步，我们定义Person类，声明姓名、年龄、性别三个属性，并声明“说话”方法，其行为是将三个变量的值输出到控制台上。

"Person.kt":

```kotlin
class Person {

    /* 属性 */
    var name: String = ""
    var age: Int = 0
    var sex: Char = '男'

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

第二步，我们基于Person类创建两个对象，并访问它们的属性与方法。

"TestClass.kt":

```kotlin
// 从模板“人类”创建实体“张三”
val zhangsan = Person()
// 设置属性
zhangsan.name = "张三"
zhangsan.age = 18
zhangsan.sex = '男'
// 调用方法
zhangsan.speak()

// 从模板“人类”创建实体“李四”
val lisi = Person()
lisi.name = "李四"
lisi.age = 20
lisi.sex = '女'
lisi.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
我是张三，年龄18岁，性别为男。
我是李四，年龄20岁，性别为女。
```

## 全局变量
类所拥有的属性被称为“成员变量”，前文“示例一”中的姓名、年龄、性别三个属性即为Person类的成员变量；此类变量的生命周期跟随对象：“张三”和“李四”各自都有这些属性，并且同名变量相互独立，修改“张三”的年龄不会影响“李四”的年龄。

成员变量的作用域为整个对象，我们可以在对象的任意位置访问它们（例如：前文“示例一”中的 `speak()` 方法），因此成员变量也被称为“全局变量”。我们习惯在成员变量的变量名之前加上 `m` 前缀（即Member的首字母），以便与其他作用域不同的变量作区分。

全局变量的初始值必须在其声明语句处立刻指明，或者由构造方法进行赋值，确保对象被创建后这些变量是可用的。如果我们在声明语句中为全局变量赋值，可以不指明其类型，由编译器自动进行推断，但我们更推荐明确写出变量类型，提高代码的可读性。

🟠 示例二：全局变量的基本应用。

在本示例中，我们定义一个类并声明若干全局变量，然后在方法中访问它们。

第一步，我们创建类，并声明全局变量。

"TestScope.kt":

```kotlin
class TestScope {

    // 声明全局变量并指定初始值
    val x: Int = 1

    // 声明全局变量但由构造方法指定初始值
    val y: String

    constructor(value: String) {
        // 使用构造方法的参数为全局变量设置初始值。
        y = value
    }

    // 访问全局变量
    fun useGlobalVariables() {
        println("x:[$x]")
        println("y:[$y]")
    }
}
```

第二步，我们在测试代码中创建TestScope对象，并调用 `useGlobalVariables()` 方法访问全局变量。

"TestScope.kt":

```kotlin
// 创建测试类的对象
val instance = TestScope("ABC")
// 访问全局变量
instance.useGlobalVariables()
```

此时运行示例程序，并查看控制台输出信息：

```text
x:[1]
y:[ABC]
```

根据上述输出内容可知：

全局变量 `x` 的值为声明它时指定的 `1` ， `y` 的值为测试代码调用构造方法时指定的 `ABC` ，符合预期。

## 局部变量
与全局变量相反，我们在代码块 `{}` 中声明的变量被称为“局部变量”，它们的作用域仅限其所在的代码块，通常用于保存临时性的数据；当代码块中的语句执行完毕后变量就会失效，基本数据类型变量所占用的内存将被立刻回收，引用数据类型变量所占用的内存由垃圾收集器安排择机回收。

🟡 示例三：局部变量的基本应用。

在本示例中，我们定义一个方法并声明局部变量，然后在另一个方法中访问它。

"TestScope.kt":

```kotlin
class TestScope {

    // 局部变量测试方法一
    fun function1() {
        // 声明局部变量 `temp`
        val temp = 0
    }

    // 局部变量测试方法二
    fun function2() {
        // 此处无法访问 `function1()` 方法中的局部变量 `temp` ，编译器会提示错误。
        println(temp)
    }
}
```

在上述代码中，方法 `function1()` 内部定义的局部变量 `temp` 无法被方法 `function2()` 访问， `println(temp)` 语句会导致编译错误。

## 构造方法
### 简介
构造方法是用于创建对象的特殊方法，它与类同名并且固定返回新的实例，因此我们不能指定它的返回值类型。我们可以为构造方法定义参数列表，通过调用者传入的参数为全局变量赋值，初始化新创建的实例。

当我们没有在代码中声明构造方法时，类默认拥有一个无参数、方法体为空的构造方法。在前文“示例一”中，变量等号右侧的 `Person()` 语句即为默认构造方法。

### 主要构造方法
Kotlin类只能拥有单个主要构造方法，默认形式为 `public constructor()` ，此时我们可以省略这些字符；若要更改参数列表或访问修饰符，则不可省略。

🟢 示例四：使用主要构造方法初始化对象。

在本示例中，我们对前文“示例一”所定义的Person类进行修改，为构造方法添加姓名、年龄两个参数，并为对应的全局变量赋值，完成对象的初始化。

第一步，我们编写新的Person类代码，并修改默认的构造方法。

"Person2.kt":

```kotlin
class Person2 constructor(
    name: String,
    age: Int
) {

    /* 属性 */
    var name: String = ""
    var age: Int = 0

    /* 初始化块 */
    init {
        println("使用主要构造方法初始化对象...")
        this.name = name
        this.age = age
    }

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁。")
    }
}
```

在上述代码中， `constructor(name: String, age: Int)` 即主要构造方法，它没有方法体，我们需要在 `init {}` 块中编写初始化逻辑代码，该块将在主要构造方法执行时被调用，并且可以访问构造方法声明的参数。一个类中可以存在多个 `init {}` 块，此时将会按照编写顺序依次执行块中的语句。

在 `init {}` 块中，我们需要使用 `this` 关键字为全局变量完成赋值，这是因为构造方法的形参与全局变量同名，此时局部的型参优先级高于全局变量，语句 `name` 即表示型参 `name` ； `this` 关键字表示“当前类的对象”，语句 `this.name` 表示全局变量 `name` ，完整语句 `this.name = name` 表示将型参 `name` 的值赋予全局变量 `name` 。

第二步，我们在测试代码中调用Person2的主要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 使用主要构造方法创建对象
val zhangsan = Person2("张三", 18)
zhangsan.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
使用有参构造方法初始化对象...
我是张三，年龄18岁。
```

---

通过构造方法参数初始化全局变量是一种常用的操作，Kotlin提供了简化语法，当我们在主要构造方法的参数前添加 `val` 或 `var` 关键字后，该参数即与同名全局变量绑定，实例化时自动赋值，无需再手动声明全局变量并在构造方法中通过 `this` 调用赋值。

🔵 示例五：在主要构造方法中声明全局变量。

在本示例中，我们对前文“示例四”所定义的Person类进行修改，在构造方法中定义与参数同名的全局变量。

第一步，我们编写新的Person类代码。

"Person3.kt"

```kotlin
class Person3 constructor(
    val name: String,
    val age: Int,
    private val sex: Char = '男'
) {

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

在构造方法中声明全局变量的语法与类中相同，我们可以指定访问修饰符，也可以指定默认值，当调用者未传该值时自动以默认值初始化变量。

第二步，我们在测试代码中调用Person3的主要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 创建对象，可选参数使用默认值。
val lisi = Person3("李四", 20)
lisi.speak()

// 创建对象，可选参数使用指定值。
val alice = Person3("Alice", 22, '女')
alice.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
我是李四，年龄20岁，性别为男。
我是Alice，年龄22岁，性别为女。
```

### 次要构造方法
除了唯一的主要构造方法之外，我们还可以声明多个次要构造方法，以适应不同场景下的初始化条件。次要构造方法必须首先调用主要构造方法，或其他已调用主要构造方法的次要构造方法，满足创建对象的必要条件，然后才能执行自己的初始化逻辑。

🟣 示例六：使用次要构造方法初始化对象。

在本示例中，我们对前文“示例五”所定义的Person类进行修改，添加次要构造方法。

第一步，我们编写新的Person类代码。

"Person4.kt"

```kotlin
class Person4 constructor(
    val name: String,
    val age: Int,
    private val sex: Char = '男'
) {

    /* 初始化块 */
    init {
        println("初始化块...")
    }

    /* 次要构造方法 */
    constructor(name: String) : this(name, 18) {
        println("次要构造方法...")
    }

    /* 方法 */
    fun speak() {
        println("我是${name}，年龄${age}岁，性别为${sex}。")
    }
}
```

次要构造方法 `constructor(name: String)` 执行时，首先通过 `this(name, 18)` 语句调用主要构造方法，传入姓名和年龄属性，再继续执行次要构造方法的方法体语句。

第二步，我们在测试代码中调用Person4的次要构造方法，完成对象的初始化。

"TestClass.kt":

```kotlin
// 使用次要构造方法创建对象
val lisi = Person4("李四")
lisi.speak()
```

此时运行示例程序，并查看控制台输出信息：

```text
初始化块...
次要构造方法...
我是李四，年龄18岁，性别为男。
```

根据上述输出内容可知：

次要构造方法被调用时，首先执行了初始化块（即主要构造方法），然后再执行次要构造方法中的语句。

## 伴生对象
### 简介
Kotlin中没有静态成员的概念，如果我们希望像Java等语言一样声明类级别的变量与方法，可以使用伴生对象，这种对象将在类被加载时初始化，我们可以直接通过类名访问其中的变量与方法。

定义伴生对象的语法如下文代码块所示：

```text
class <类名> {

    // 声明伴生对象
    companion object <对象名称> {
        /* 声明变量... */
        val x :Int = 100;
        val y :Int = -100;

        /* 声明方法... */
        fun foo() {}
        fun boo() {}
    }
}
```

访问伴生对象中属性与方法的语法如下文代码块所示：

```text
<类名>.<变量名称>
<类名>.<方法名称>([参数...])
```

每个类只能拥有一个伴生对象，因此它的名称可以省略，此时默认名称为 `Companion` 。

我们习惯在伴生对象成员变量的变量名之前加上 `s` 前缀（即Static的首字母），以便与其他作用域不同的变量作区分。

### 基本应用
下文示例展示了伴生对象的基本使用方法：

🟤 示例七：伴生对象的基本应用。

在本示例中，我们定义测试类并声明伴生对象，然后访问其中的变量与方法。

第一步，我们编写测试类代码。

"TestCompanion.kt"

```kotlin
class TestCompanion {

    // 声明伴生对象
    companion object {

        // 声明变量
        val x: String = "TEST"

        // 声明方法
        fun avg(a: Int, b: Int): Double {
            return ((a + b) / 2.0)
        }
    }
}
```

第二步，我们在测试代码中访问TestCompanion伴生对象中的属性与方法。

"TestCompanion.kt":

```kotlin
// 访问伴生对象中的属性
println("访问属性：${TestCompanion.x}")

// 访问伴生对象中的方法
println("访问方法：${TestCompanion.avg(6, 4)}")
```

此时运行示例程序，并查看控制台输出信息：

```text
访问属性：TEST
访问方法：5.0
```

---

当我们在伴生对象中声明基本数据类型或String类型的常量时，可以添加 `const` 关键字，此时编译器将会进行一些优化，提高运行效率。

🔴 示例八：了解"const"关键字的作用。

在本示例中，我们以JVM平台为基础，比较 `const` 常量与普通常量的区别。

第一步，我们编写测试类代码。

"TestCompanion2.kt"

```kotlin
class TestCompanion2 {

    companion object {

        // 声明"const"常量
        const val PI: Float = 3.141593F

        // 声明普通常量
        val X: String = "TEST"
    }
}
```

第二步，我们将测试类的字节码反编译为Java代码。

"TestCompanion2.java"

```java
public final class TestCompanion2 {

    // "const"常量
    public static final float PI = 3.141593F;

    // 普通常量
    private static final String X = "TEST";

    public static final class Companion {
        public final String getX() {
            return TestCompanion2.X;
        }
    }
}
```

普通常量 `X` 在JVM中生成了私有静态常量，以及公开方法 `getX()` ，调用语句 `TestCompanion2.X` 实际上需要通过方法读取常量值； `const` 常量 `PI` 对应的则是公开静态常量，调用者可以直接读取变量值，相比前者效率更高。

### 与Java交互
当我们使用Java代码访问伴生对象中的变量与方法时，需要通过静态内部类Companion中转；例如前文“示例八”中的变量 `x` ，访问语法为 `TestCompanion.Companion.getX()` 。

如果我们为伴生对象中的属性与方法添加 `@JvmStatic` 注解，Kotlin编译器将在目标类中额外生成静态变量与静态方法，以便我们在Java代码中直接访问它们。

🟠 示例九："@JvmStatic"注解。

在本示例中，我们为变量与方法添加 `@JvmStatic` 注解，并在Java代码中访问它们。

第一步，我们编写测试类。

"TestCompanion3.kt":

```kotlin
class TestCompanion3 {

    companion object {

        @JvmStatic
        val x: String = "TEST"

        @JvmStatic
        fun avg(a: Int, b: Int): Double {
            return ((a + b) / 2.0)
        }
    }
}
```

此时我们可以查看测试类字节码对应的Java代码：

```java
public final class TestCompanion3 {

    private static final String x = "TEST";

    // 注解生成的静态方法
    public static final String getX() {
        return x;
    }

    // 注解生成的静态方法
    public static final double avg(int a, int b) {
        return Companion.avg(a, b);
    }

    public static final class Companion {

        public final String getX() {
            return TestCompanion.x;
        }

        public final double avg(int a, int b) {
            return (double)(a + b) / 2.0;
        }
    }
}
```

从上述代码可知，当我们为变量与方法添加 `@JvmStatic` 注解后，Kotlin编译器将会在类中添加静态成员变量。

第二步，我们在Java测试代码中访问上述变量与方法。

"TestCompanionJava.java":

```java
TestCompanion3.getX();
TestCompanion3.avg(2, 6);
```

---

> 🚩 提示
>
> 在JVM平台上， `const` 关键字的效果与 `@JvmStatic` 注解是相同的，因此我们不能将 `@JvmStatic` 添加到 `const` 常量上。


# 空值安全
## 简介
引用类型变量存储的是指向实际数据的内存地址，当一个引用类型变量未指向任何内存区域时，我们将它的值记作 `null` ，并将变量称为“空值对象”。以下场景可能导致变量的值为空：全局变量未经初始化、开发者主动将变量赋值为 `null` 、变量接收的方法返回值为 `null` 。我们不应当访问空值对象的属性与方法，这会导致空指针异常 `NullPointerException` ；该异常也被简称为 `NPE` ，是程序崩溃的常见因素之一。

部分变量逻辑上允许为空，例如：从数据库中查询学生信息时，返回非空Student对象表示存在记录；返回空的Student对象则表示不存在记录；我们在访问它们之前应当进行空值检验，仅当变量非空时才能访问它的属性与方法。另外的部分变量逻辑上不可为空，例如：学生的ID和姓名属性；我们应当确保在访问它们之前正确地完成了初始化。

Kotlin的类型系统要求在定义变量时指明其值是否可能为空；当我们访问可空变量时，编译器还会检查代码是否进行了空值检验，若未检验则产生错误消息，这些措施在一定程度上减少了潜在的空指针异常。

🟡 示例十：定义与访问可空变量。

在本示例中，我们定义一些可空变量，并访问它们。

"TestNullSafe.kt":

```kotlin
// 声明非空字符串 `str1`
var str1: String = "字符串内容"
// 声明可空字符串 `str2`
var str2: String? = null

// 将空值赋予非空字符串，该语句无法通过编译。
str1 = null
// 将空值赋予可空字符串，该语句可以通过编译。
str2 = null

// 调用无空变量的属性，该语句可以通过编译。
str1.length
// 调用可空变量的属性，该语句无法通过编译。
str2.length
```

默认情况下，变量的值不可为空，我们必须在声明变量时赋予有效的初始值。如果我们想要声明可空变量，需要在它的类型之后添加问号( `?` )。

当我们将 `null` 赋值给非空变量、访问可空变量前没有进行空值检验时，编译器都会产生错误消息，提示我们修正代码。

🟢 示例十一：空值检验。

在本示例中，我们对可空变量进行空值检验，仅当变量非空时访问它的属性与方法。

"TestNullSafe.kt":

```kotlin
var str: String? = null

// 判断字符串是否为空值
if (str != null) {
    // 当变量不为空时，再访问其中的属性与方法。
    println(str.length)
} else {
    println("对象为空，放弃操作！")
}
```

## 安全调用操作符
当我们访问可空变量的属性与方法时，可以使用安全调用操作符 `?.` 。在表达式 `<对象>?.<方法或属性>` 中，如果对象为空值，该表达式的结果也为空值；如果对象不为空值，则表达式的结果为属性或方法返回值。

🔵 示例十二：安全调用操作符。

在本示例中，我们使用安全调用操作符进行空值检验。

"TestNullSafe.kt":

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

// 使用安全调用操作符访问两个变量
println("str1的内容：" + str1?.length)
println("str2的内容：" + str2?.length)
```

在上述代码中，方法 `String.length()` 的返回值类型为 `Int` ，因此表达式 `str1?.length` 的返回值类型为 `Int?` 。

此时运行示例程序，并查看控制台输出信息：

```text
str1的内容：5
str2的内容：null
```

根据上述输出内容可知：

对象 `str1` 的值不为空，因此整个表达式的值为字符串长度 `5` ；对象 `str2` 的值为空，因此整个表达式的值为 `null` 。

---

安全调用操作符可以级联使用，这在某些场景中有利于减少模板代码。

🟣 示例十三：级联判空。

在本示例中，我们使用安全调用操作符进行级联判空。

假设现有一个学生对象 `student` ，我们需要依次调用方法获取“所有课程”、“最新课程”、“最新课程的学分”。前述每个步骤获取到的对象均可能为空，因此我们需要按照下文代码中的步骤逐层进行空值判断。

"TestNullSafe.kt":

```kotlin
// 获取学生的所有课程
val courses = student.getCourses()
if (courses != null) {
    // 获取最新选择的课程
    val latestCourse = courses.getLatestCourse()
    if (latestCourse != null) {
        // 获取课程的学分
        val credit = latestCourse.getCredit()
        println("学分：$credit")
    }
}
```

在此场景中，我们可以级联使用安全调用操作符，将上述代码简化为一行：

"TestNullSafe.kt":

```kotlin
val credit = student?.getCourses()?.getLatestCourse()?.getCredit()
println("学分：$credit")
```

当程序运行至级联语句时，它会从左至右依次执行每个步骤，若其中任意一个步骤的结果为空，整个表达式的结果也为空。

---

安全调用操作符可以和其他工具相结合，取代 `if (obj != null)` 形式的空值检验逻辑。

🟤 示例十四：通过安全调用操作符检验空值。

在本示例中，我们使用安全调用操作符进行空值检验。

"TestNullSafe.kt":

```kotlin
var str: String? = null

// 判断字符串是否为空值
if (str != null) {
    // 当变量不为空时，再访问其中的属性与方法。
    println(str.length)
}

// 上述逻辑的等价写法
str?.let {
    // 变量"it"等同于"str"
    println(it)
}
```

`<对象>.let{}` 是一个Kotlin标准库中的扩展函数，在其作用域内可以使用变量 `it` 访问对象。在上述示例代码中，我们结合安全调用操作符使用扩展函数，表达式为 `<对象>?.let{}` 。当对象为空时，表达式结果为 `null` ，整个语句将被忽略；当对象不为空时，将会执行 `let{}` 作用域中的语句。

## Elvis运算符
Elvis运算符的形式为 `<表达式A> ?: <表达式B>` ，当“表达式A”的结果不为空时，整个语句的结果即“表达式A”的结果；当“表达式A”的结果为空时，整个语句的结果为“表达式B”的结果。

🔴 示例十五：Elvis运算符。

在本示例中，我们了解Elvis运算符的应用场景。

"TestNullSafe.kt":

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

val length1: Int = str1?.length ?: 0
val length2: Int = str2?.length ?: 0

println("str1的长度:$length1")
println("str2的长度:$length2")
```

此时运行示例程序，并查看控制台输出信息：

```text
str1的长度:5
str2的长度:0
```

根据上述输出内容可知：

字符串 `str1` 不为空，因此表达式 `str1?.length` 也不为空，此时整个Elvis语句的结果为 `str1?.length` 的结果。字符串 `str2` 为空，因此表达式 `str2?.length` 为空，此时整个Elvis语句的结果是 `0` 。

Elvis运算符通常用于设置左侧表达式为空时的默认值，若右侧表达式包含修改其他变量的操作，则需要引起注意，仅当左侧表达式为空时，右侧表达式才会触发修改动作。

---

Elvis运算符右侧的表达式不仅可以是普通语句，还可以是 `return` 和 `throw` 语句，我们应当按需选用。

```kotlin
// 在Elvis运算符中使用 `return` 或 `throw` 语句
fun getLength1(str: String?): Int {
    str?.length ?: return 0
}

fun getLength2(str: String?): Int {
    str?.length ?: throw IllegalArgumentException("入参为空值！")
}
```

## 非空断言
非空断言运算符 `!!` 能够将可空变量引用转换为非空变量引用，在编译阶段跳过编译器的语法检查；但若运行阶段变量为空，仍会抛出空指针异常导致程序崩溃。

🟠 示例十六：非空断言。

在本示例中，我们了解非空断言的应用场景。

```kotlin
// 测试变量，值可以随意修改。
var str: String? = null
// 字符串为空时，终止进程。
runBlocking {
    if (str == null) {
        println("变量为空，终止进程！")
        exitProcess(1)
    }
}

// 该语句无法编译通过
println("字符数量：${str.length}")

// 该语句可以编译通过
println("字符数量：${str!!.length}")
```

在上述代码中， `runBlocking {}` 块对 `str` 变量进行了空值检验，如果变量为空则退出程序；若代码能够执行到后续的 `println()` 语句，则 `str` 变量必然是非空的，但编译器无法识别跨作用域的空值检验，仍然认为该变量是可空的，要求我们在空值检验后访问该变量。

对于此类可空变量在逻辑上非空的场景，我们可以使用非空断言运算符，不经过空值检验直接访问变量的属性与方法。

---

> ⚠️ 警告
>
> 非空断言只能在可空变量逻辑上非空的场景中解除Kotlin语法限制，其他任何情况下都不应当被使用。

## "requireNotNull()"方法
`requireNotNull(value: T?): T` 方法也是非空断言的一种形式，唯一参数 `value` 即需要被断言的可空变量，返回值为该变量的非空类型。该方法与 `!!` 运算符的行为是一致的，更适合在函数式风格的代码中使用。

🟡 示例十七："requireNotNull()"方法。

在本示例中，我们了解 `requireNotNull()` 方法的应用场景。

```kotlin
// 测试变量，值可以随意修改。
var str: String? = null
// 字符串为空时，终止进程。
runBlocking {
    if (str == null) {
        exitProcess(1)
    }
}

// 将变量转换为非空变量，并设置变量为空时的错误消息。
val nonNullStr = requireNotNull(str) { "预期之外的空值，请检查业务逻辑！" }
// 使用非空变量
println("字符数量：${nonNullStr.length}")
println("存在内容？：${nonNullStr.isNotEmpty()}")
```

`requireNotNull()` 方法的第二参数是一个可选的Lambda表达式，断言失败时将被执行，表达式的返回值会作为异常消息展示在控制台上，我们可以填写自定义提示语。

## 延迟加载变量
我们在声明全局变量时必须指明其是否可空，且最晚在构造方法中赋予初始值。在部分场景下，实例的创建由框架管理，开发者无法主动调用构造方法初始化非空变量，为了解决该问题，Kotlin提供了一些实用工具，允许开发者在实例创建后再初始化非空全局变量：

- `by lazy {}` : 通过委托机制将变量访问委托给 `lazy()` 函数处理，该方法的参数是一个Lambda表达式，将在变量首次被访问之前执行，并将返回值赋值给变量。
- `lateinit` 关键字 : 适用于引用数据类型的 `var` 变量，编译器将会跳过变量初始化检查。

🟢 示例十八：通过 `by lazy {}` 方法延迟加载变量。

在本示例中，我们使用 `by lazy {}` 方法延迟加载非空全局变量。

"TestNullSafe.kt":

```kotlin
class MyProvider : ContentProvider() {

    // 延迟加载非空变量
    private val cacheDir: File by lazy {
        // 该语句将在变量 `cacheDir` 首次被调用时执行。
        requireContext().cacheDir
    }

    // 此方法由系统在创建实例时调用，随后 `requireContext()` 方法可用。
    override fun onCreate() {}

    // 业务方法
    fun listCacheFiles() {
        // 此处为首次访问 `cacheDir` 变量， `by lazy {}` 中的语句被执行。
        cacheDir.list()
    }
}
```

在上述代码中，ContentProvider是Android程序的一种系统组件，用户无法自行创建实例。非空变量 `cacheDir` 由 `by lazy {}` 管理，当任意业务方法首次访问变量时， `requireContext().cacheDir` 语句被执行， `cacheDir` 被赋予初始值，随后业务方法被执行。

🔵 示例十九：通过 `lateinit` 关键字延迟加载变量。

在本示例中，我们使用 `lateinit` 关键字延迟加载非空变量。

"TestNullSafe.kt":

```kotlin
class MyProvider : ContentProvider() {

    // 声明非空变量但先不初始化
    private lateinit var mCacheDir: File

    // 此方法由系统在创建实例时调用，随后 `requireContext()` 方法可用。
    override fun onCreate() {
        // 具备条件时初始化非空变量
        mCacheDir = requireContext().cacheDir
    }

    // 业务方法
    fun listCacheFiles() {
        // `mCacheDir` 变量在系统回调 `onCreate()` 方法时已被初始化，因此可以正常使用。
        mCacheDir.list()

        // 如果不希望访问未初始化的 `lateinit` 变量导致异常，我们也可以主动判断其是否已初始化。
        if (::mCacheDir.isInitialized) {
            println("`lateinit` 变量已初始化。")
        } else {
            println("`lateinit` 变量未初始化，不可访问！")
        }
    }
}
```

对于 `lateinit` 变量，编译器不会进行初始化检查，而是将控制权完全交给开发者，我们可以自行控制初始化的时机，并确保在变量被赋予初始值之后再进行访问。

如果我们不希望意外地访问未初始化的 `lateinit` 变量导致空指针异常，也可以主动判断它们是否已经被初始化：

```kotlin
if (::mCacheDir.isInitialized) {
    println("`lateinit` 变量已初始化。")
} else {
    println("`lateinit` 变量未初始化，不可访问！")
}
```

与 `by lazy {}` 方式相比，`lateinit` 关键字所声明的变量是可变的，且初始化逻辑与变量声明不在一处，编码更为自由。我们通常不建议使用该关键字，若不得不使用时务必小心空指针异常。


# 疑难解答
## 索引

<div align="center">

|       序号        |                        摘要                         |
| :---------------: | :-------------------------------------------------: |
| [案例一](#案例一) | 对可变全局变量判空后，IDE仍然提示无法安全地调用它。 |

</div>

## 案例一
### 问题描述
当我们对可变全局变量进行空值判断后，编译器仍然提示无法安全地调用它。

```kotlin
class Test {

    // 定义一个可变的全局变量
    var text: String? = null

    // 测试方法
    fun logic() {
        // 对变量"text"进行判空
        if (text != null) {
            // 将变量"text"传入参数不可为空的方法
            // 此处IDE将会提示错误，并且无法通过编译。
            show(text)
        }
    }

    // 显示信息的方法
    private fun show(info: String) {
        println(info)
    }
}
```

在上述示例代码中，我们首先对变量 `text` 进行空值判断，当其不为空值时，将它作为非空参数传递给 `show()` 方法。

此时IDE将在 `show(text)` 处提示以下错误信息：

```text
Smart cast to 'String' is impossible, because 'text' is a mutable property that could have been changed by this time.
```

### 问题分析
全局变量 `text` 是一个可变变量，这意味着它的值可以被任何线程修改。假设线程A通过空值判断后立刻休眠，线程B将该变量修改为空值；随后线程A恢复运行，此时线程A传给 `show()` 方法的参数即为空值，与该方法的参数非空要求不符。

如果我们将判空语句改为以下写法，虽然能够消除IDE错误提示并通过编译，但未从根本上解决线程安全问题。

```kotlin
// 错误示范一
fun logic() {
    // 使用非空断言，以符合语法检查要求。
    if (text != null) {
        show(text!!)
    }
}

// 错误示范二
fun logic() {
    // 使用内置函数"let"，不直接引用变量"text"。
    text?.let { show(it) }
}
```

在错误示范一中，非空断言强制改写变量 `text` 为非空，符合 `show()` 方法的参数要求，因此能够通过语法检查，但遇到前文所述的多线程场景时，仍然会出现空指针异常。

在错误示范二中，扩展函数 `let()` 作用域内的变量 `it` 等同于变量 `text` ，当函数体执行时， `it` 所指向的内存区域仍然可能被改为空值。

### 解决方案
该问题的正确解决方法如下文代码块所示：

```kotlin
fun logic() {
    // 声明局部变量存储全局变量"text"的引用。
    val temp: String? = text
    // 使用局部变量进行后续操作
    if (temp != null) {
        show(temp)
    }
}
```

我们在空值判断之前使用局部变量 `temp` 存储变量 `text` 的引用，由于局部变量跟随当前线程（该特性被称为“线程封闭”），即使后续全局变量 `text` 被改为空值，局部变量 `temp` 仍然持有原先的非空引用，因此实现了线程安全。

> 🚩 提示
>
> 关于“线程封闭”的相关概念，可以参考以下文章： [🔗 “线程封闭”的相关概念](https://www.cnblogs.com/binghe001/p/12808419.html) 。
