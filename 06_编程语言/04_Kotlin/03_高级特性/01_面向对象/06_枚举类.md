# 简介
枚举类(Enum Class)用于描述一组预先确定的、数量有限的值，例如：季节（春、夏、秋、冬）、星期（周一至周日）、音视频播放状态（播放、暂停、缓冲、错误）等。

🔴 示例一：使用常量表示季节。

在本示例中，我们使用数字代码表示四个季节。

第一步，我们创建一个Const类，并定义四个常量：

"Const.kt":

```kotlin
object Const {
    const val SEASON_SPRING: Int = 1
    const val SEASON_SUMMER: Int = 2
    const val SEASON_AUTUMN: Int = 3
    const val SEASON_WINTER: Int = 4
}
```

第二步，我们在测试类中定义一个 `printSeason()` 方法，向控制台输出参数对应的季节名称。

"TestEnumClass.kt":

```kotlin
fun main() {
    // 传入常量类中定义的数值
    printSeason(Const.SEASON_SPRING)
}

// 根据传入的季节代号，输出季节名称。
fun printSeason(code: Int) {
    when (code) {
        Const.SEASON_SPRING -> println("现在是春天")
        Const.SEASON_SUMMER -> println("现在是夏天")
        Const.SEASON_AUTUMN -> println("现在是秋天")
        Const.SEASON_WINTER -> println("现在是冬天")
        else -> println("无效的参数！")
    }
}
```

上述方式存在以下缺点：

🔷 可读性较差

我们通常会将所有的静态常量放置在一个类中，因此表示季节的四个常量必须携带"SEASON_"前缀，以便与其他常量作区分。

这种名称在调用者的代码中文本较长，且具有冗余性，不便于阅读。

🔷 类型不安全

`printSeason()` 方法的参数类型为数字，无法约束调用者的行为。

调用者可能会传入四个有效值以外的任意数值，例如："-1", "100"等，我们需要为它们编写额外的处理逻辑，增加了工作量。

🔷 无法携带额外信息

每个季节所对应的中文名称是固定的，在 `printSeason()` 方法中我们根据数值的含义人工书写字符串，代码繁琐且不便于维护。

# 基本应用
我们不妨使用枚举来表示季节，解决前文“示例一”中所涉及的问题。

🟠 示例二：使用枚举表示季节。

在本示例中，我们使用枚举表示四个季节。

第一步，我们创建一个Season类，并定义四个枚举：

"Season.kt":

```kotlin
enum class Season {
    // 春天
    SPRING,
    // 夏天
    SUMMER,
    // 秋天
    AUTUMN,
    // 冬天
    WINTER;
}
```

枚举类与普通类的声明语法是类似的，我们需要在"class"关键字之前添加一个"enum"关键字。枚举常量应当在类的首部依次声明，不同常量之间以逗号(",")分隔。按照常量的命名规则，我们习惯将枚举常量名称中的字母全部大写；若存在多个单词，则使用下划线("_")进行连接。

第二步，我们对 `printSeason()` 方法进行修改，将参数从数字代码改为枚举类。

"TestEnumClass.kt":

```kotlin
fun main() {
    // 传入枚举常量
    printSeason(Season.SUMMER)
}

// 根据传入的季节代号，输出季节名称。
fun printSeason2(season: Season) {
    when (season) {
        Season.SPRING -> println("现在是春天")
        Season.SUMMER -> println("现在是夏天")
        Season.AUTUMN -> println("现在是秋天")
        Season.WINTER -> println("现在是冬天")
    }
}
```

枚举常量可以通过 `<枚举类>.<常量名称>` 的方式被调用，这解决了普通常量可读性较差的问题。

由于Season类型限定了调用者能够传入 `printSeason2()` 方法的参数值，我们可以移除前文的无效值处理逻辑（即"else"块），这解决了类型不安全的问题。
