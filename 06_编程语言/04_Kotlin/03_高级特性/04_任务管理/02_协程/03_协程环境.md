# 概述
截止至本节内容，我们的多数示例代码通过 `CoroutineScope(Dispatchers.Default).launch { ... }` 
语句启动协程，每次都会新建一个CoroutineScope实例，这些协程相互独立，没有产生关联。本节内容将会讨论CoroutineScope的相关知识，以结构化方式管理一组具有相关性的协程。

CoroutineScope表示协程的运行环境，通过同一个CoroutineScope实例启动的协程具有相同的配置，并且都受该CoroutineScope管理。例如：现有一个报表管理模块，其中多个接口都会启动新协程以生成不同维度的报表，这些协程应当由当前模块的CoroutineScope统一管理；如果管理员开启维护模式，需要停止所有报表生成任务，我们可以从CoroutineScope实例调用 `cancel()` 方法，所有通过该实例启动的协程都将被终止。

协程环境主要包括以下部分：

- CoroutineContext : 协程上下文，是一组指导协程运作的配置集合。上下文指明应当使用何种调度器执行任务、出现异常如何进行传递与处理等。
- CoroutineScope : 协程作用域，负责管理一组协程。每个作用域包含一份上下文，我们可以通过作用域启动新的协程或取消所有协程。


# 协程上下文
## 简介
协程上下文由一系列元素组成，它的数据结构类似于集合，每个元素都实现了 `CoroutineContext.Element` 接口，以KEY作为类型标识，我们可以对上下文中的元素进行添加、替换、删除等操作。

常见的上下文元素及其作用如下文列表所示：

- Job : 顶级协程任务，必选。用于组织内部协程的父子关系，常见的值为Job或SupervisorJob。当我们创建上下文时可以省略该元素，此时系统将会自动新建一个Job。
- ContinuationInterceptor : 调度器，可选。通常是协程库内置的CoroutineDispatcher，在JVM平台上用于控制协程任务所使用的工作线程类型。如果创建作用域时未指定调度器，当我们通过 `launch ()` 等方法开启协程时，将使用Dispatchers.Default作为默认调度器。
- CoroutineName : 作用域名称，可选。可在协程任务中获取，用于调试与日志输出。
- CoroutineExceptionHandler : 异常处理器，可选。用于统一处理作用域内协程发生的异常。

下文示例展示了构建协程作用域的基本方法：

🔴 示例一：创建协程作用域。

在本示例中，我们创建一些协程作用域，并指定上下文。

"TestScope.kt":

```kotlin
// 基本的上下文
val scopeA = CoroutineScope(Dispatchers.Default)
println("ScopeA: ${scopeA.coroutineContext}")

// 额外指定名称和SupervisorJob
val scopeB = CoroutineScope(Dispatchers.IO + CoroutineName("A") + SupervisorJob())
println("ScopeB: ${scopeB.coroutineContext}")

// EmptyCoroutineContext
val scopeC = CoroutineScope(EmptyCoroutineContext)
println("ScopeC: ${scopeC.coroutineContext}")
```

此时运行示例程序，并查看控制台输出信息：

```text
ScopeA: [JobImpl{Active}@255316f2, Dispatchers.Default]
ScopeB: [CoroutineName(A), SupervisorJobImpl{Active}@14514713, Dispatchers.IO]
ScopeC: JobImpl{Active}@69663380
```

根据上述输出内容可知：

当我们使用常见的 `CoroutineScope(Dispatchers.Default)` 方式创建协程作用域时，并未指明Job，此时系统自动生成了一个Job `JobImpl{Active}@255316f2` 作为上下文元素。

EmptyCoroutineContext表示所有元素均使用默认值，此时系统只会自动创建Job元素。

---

下文示例展示了修改与访问上下文的基本方法：

🟠 示例二：修改协程上下文。

在本示例中，我们创建协程作用域，并对上下文进行修改。

"TestScope.kt":

```kotlin
val scope = CoroutineScope(Dispatchers.IO + CoroutineName("A") + SupervisorJob())
println("Scope: ${scope.coroutineContext}")

// 通过KEY获取Context中的元素
val job = scope.coroutineContext[Job]
println("获取元素：$job")

// 替换同KEY元素生成新的Context
val newContext1 = scope.coroutineContext + Dispatchers.Default
println("替换元素：$newContext1")

// 添加元素生成新的Context
val newContext2 = scope.coroutineContext + CoroutineExceptionHandler { _: CoroutineContext, e: Throwable ->
    println("捕获到异常：${e.message}")
}
println("新增元素：$newContext2")

// 移除元素生成新的Context
val newContext3 = scope.coroutineContext.minusKey(CoroutineName)
println("移除元素：$newContext3")
```

此时运行示例程序，并查看控制台输出信息：

```text
Scope: [CoroutineName(A), SupervisorJobImpl{Active}@30946e09, Dispatchers.IO]
获取元素：SupervisorJobImpl{Active}@30946e09
替换元素：[CoroutineName(A), SupervisorJobImpl{Active}@30946e09, Dispatchers.Default]
新增元素：[CoroutineName(A), SupervisorJobImpl{Active}@30946e09, net.bi4vmr.study.scope.TestScopeKt$example02$$inlined$CoroutineExceptionHandler$1@69663380, Dispatchers.IO]
移除元素：[SupervisorJobImpl{Active}@30946e09, Dispatchers.IO]
```

根据上述输出内容可知：

上下文与集合类似，它重写了 `+` 、 `[]` 等操作符，我们可以使用 `<协程作用域>[KEY]` 语法获取元素；使用 `<作用域A> + <作用域B>` 合并两个上下文（或向“作用域A”添加元素）。

上下文中具有相同KEY的元素不能共存，当我们向已有Dispatchers.IO的上下文添加Dispatchers.Default后，最终生成的上下文只包括Dispatchers.Default，旧的调度器被替换了。

## Dispatcher
CoroutineDispatcher用于控制协程任务的工作线程，为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测。该调度器仅用于测试，我们通常不会在业务代码中使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。

## Job与SupervisorJob

SupervisorJob

一、异常传播机制：Job的“连坐”之道
在 Kotlin 协程中，Job 的异常处理机制遵循一种严格的父子关系。当一个子协程因未捕获的异常而失败时，它会执行以下两个关键操作：

向上传播异常：子协程会将异常向其父协程传播。
触发父协程的取消：父协程在接收到异常后，会立即将自己标记为“失败”，并进入取消状态。
递归取消：一旦父协程被取消，它会递归地取消所有其他子协程。

正是这种“异常向上，取消向下”的传播机制，导致了“连坐制”：一个子协程的失败会像多米诺骨牌一样，导致整个协程家族的崩溃。这种行为模式适用于那些所有子任务都必须成功的场景，一个失败就意味着整个任务的失败。

二、责任隔离：SupervisorJob的“拦截”策略
SupervisorJob 旨在打破 Job 的异常传播规则。它的核心思想是**“谁犯错，谁负责”**。

核心机制：SupervisorJob 会拦截子协程的异常，阻止其向上传播给父协程。
独立失败：当一个子协程失败时，它只会取消自己，而不会影响其兄弟协程或父协程。这使得开发者可以独立处理每个协程的错误，而不会导致整个协程作用域的崩溃。
手动捕获：需要注意的是，SupervisorJob 并不会自动处理异常。未捕获的异常仍然会从协程的根部抛出，如果无人处理，最终仍会导致应用崩溃。因此，必须手动捕获异常（使用 try-catch 或 CoroutineExceptionHandler）。


三、实践中的选择：何时使用哪种Job？
选择使用 Job 还是 SupervisorJob，取决于任务之间的关联性。





选择场景示例Job多个任务之间存在强依赖关系，任何一个失败都意味着整个流程失败。用户注册流程：创建用户 -> 发送验证邮件 -> 跳转主页。如果发送邮件失败，整个注册流程都应回滚或取消。SupervisorJob多个任务之间相互独立，一个任务的失败不应该影响其他任务。主页数据加载：加载用户信息、加载推荐列表、加载广告。如果广告加载失败，用户和推荐列表仍然可以正常显示。



## CoroutineExceptionHandler

无论是 Job 还是 SupervisorJob，CoroutineExceptionHandler 都是处理未捕获异常的最后一道防线。

如何使用：CoroutineExceptionHandler 可以作为一个元素添加到 CoroutineContext 中。当协程中抛出未捕获异常时，它会被 CoroutineExceptionHandler 拦截并处理。
最佳实践：在 Android 开发中，通常将 CoroutineExceptionHandler 添加到全局的 CoroutineScope 中，用于记录崩溃日志或执行其他清理操作，从而防止应用崩溃。



## CoroutineName
CoroutineName用于标识当前作用域，不影响协程的行为，通常用于调试。

🟠 示例三：作用域名称。

在本示例中，我们创建协程作用域并指定名称，然后在协程中获取并输出消息。

"TestScope.kt":

```kotlin
// 未指定CoroutineName的作用域
CoroutineScope(EmptyCoroutineContext).launch {
    val name = coroutineContext[CoroutineName]?.name
    println("默认的作用域名称：[$name]")
}

// 指定了CoroutineName的作用域
CoroutineScope(CoroutineName("BusinessA")).launch {
    val name = coroutineContext[CoroutineName]?.name
    println("指定的作用域名称：[$name]")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
默认的作用域名称：[null]
指定的作用域名称：[BusinessA]
```



<!-- TODO


# 预设作用域

GlobalScope

GlobalScope没有Job，因此其中的协程无法通过GlobalScope统一取消，一般不推荐使用。

public object GlobalScope : CoroutineScope {
    /**
     * Returns [EmptyCoroutineContext].
     */
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext
}

这是一个 微妙的 API。使用 GlobalScope 时很容易意外造成资源或内存泄漏。启动的 GlobalScope 协程不受结构化并发原则约束，因此如果因问题（如网络缓慢）导致卡顿或延迟，仍能持续工作并消耗资源。例如，考虑以下代码：


MainScope

public fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)


class MyAndroidActivity {
    private val scope = MainScope()

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel()
    }
}


# 常用方法

## 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


有时候我们需要在同一个协程中切换线程，比如先在 IO 线程读数据，再切回 Main 线程更新 UI。这时就要用到 withContext：

withContext如果只定义了调度器，那么其他上下文会被保留，只替换调度器。不用担心切换后异常处理等丢失



withTimeout 会抛出 TimeoutCancellationException




coroutineScope{} 可以访问当前上下文的调度器，在此处启动协程后外部将会等待内部协程执行完毕再运行，如果新建作用域则不会等待。

coroutineScope 提供的是继承了外部作用域的 coroutineContext 的上下文作用域，但它覆盖了来自父节点上下文的 Job。因此，coroutineScope 将和其父节点建立下面这些规则：

    从父节点那里继承上下文
    在完成自己之前等待所有的子节点
    当父节点被取消时，所有子节点也会被取消


supervisorScope 函数的行为也很像 coroutineScope：它创建了一个 CoroutineScope，从外部作用域继承而来，并在其中调用指定的挂起块。不同的是，它用 SupervisorJob 重写了来自上下文的 Job，所以当子协程发生异常时，它不会被取消。



# 结构化并发

在结构化并发一章中，我们提到父子关系会有以下影响：

    子协程从父协程那里继承上下文
    父协程会挂起，直到所有子协程都完成
    当父协程被取消时，所有子协程都将取消
    当一个子协程被销毁时，它也会销毁父协程


当你在一个协程内部启动另一个协程，默认会继承父协程的上下文，且新协程的 Job 成为父 Job 的子 Job：

launch {
    val child = launch {
        delay(1000L)
        println("Child executed")
    }
    child.join()
}

这种结构的好处是：

    父协程取消时，所有子协程自动级联取消
    结构化并发得以保障

但如果你希望协程独立运行（不受父协程影响），有两种方式打破父子关系：

    指定不同的作用域

    GlobalScope.launch { ... }

传入独立的 Job

launch(coroutineContext + Job()) { ... }

✅ 应用场景举例：

    启动后台心跳任务，即使页面销毁也不中断
    日志上报等“火后即忘”型任务


-->


# 实用技巧
## 编码风格
有时我们会看到下文代码块所展示的协程启动方式，这种写法仅适用于简单的示例代码，对于完整的业务模块并不合理。

```kotlin
class UserManager {

    fun updateCurrentUID() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }
}
```

以UserManager为例， `updateCurrentUID()` 和 `updateCurrentName()` 方法都创建了新的协程作用域并启动协程，这使得任务之间没有产生关联，无法实现结构化并发。业务组件中的协程应当跟随组件生命周期，若组件使用完毕而被销毁，其所关联的协程也应当被取消。

除此之外，由于协程作用域直接引用了SDK内置的 `Dispatchers.IO` 调度器，任务执行时机将会变得不可控，在测试环境中，我们难以确保任务执行完毕后再进行断言。

针对不同的场景，我们提供以下两种推荐的编码风格。

对于功能较为简单的底层模块，例如：数据库接口、HTTP接口等，我们可以不创建协程环境，而是将所有方法作为挂起函数，由上层调用者（可能是UI组件或业务聚合组件）自行决定需要在何种协程环境中执行这些方法。

```kotlin
class UserManagerV1 {

    suspend fun updateCurrentUID(): String = "1"

    suspend fun updateCurrentName(): String = "User1"
}
```

以Android平台为例，我们可以使用界面组件提供的LifecycleScope调用挂起函数，一旦界面被用户关闭，对应的协程任务都会被自动取消。

对于功能较为复杂的业务聚合组件，我们可以使用统一的协程作用域新建协程，或者按照功能划分少量的作用域，不必在每个业务方法内部都创建新的作用域。

```kotlin
class UserManagerV2(
    // 使用外部传入的调度器，或提供默认的调度器。
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) {

    // 所有业务使用统一的作用域
    private val scope = CoroutineScope(dispatcher)

    fun updateCurrentUID() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    // 提供组件销毁方法，取消当前作用域的所有协程。
    fun destroy() {
        scope.cancel()
    }
}
```

协程调度器用于控制任务的执行进度，在测试代码中我们需要确保任务执行完毕再检查结果，因此我们将调度器作为构造方法参数，并提供默认值。业务代码构造该实例时无需指定调度器，此时使用预设调度器，测试代码构造该实例时应当传入测试调度器，以便控制协程任务。

我们还可以提供一个 `destroy()` 方法用于取消所有任务，它对可动态加载业务是必要的，若当前模块被卸载，相关任务也应当终止。
