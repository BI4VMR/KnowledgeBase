# 概述
截止至本节内容，我们的多数示例代码通过 `CoroutineScope(Dispatchers.Default).launch { ... }` 
语句启动协程，每次都会新建一个CoroutineScope实例，这些协程相互独立，没有产生关联。本节内容将会讨论CoroutineScope的相关知识，以结构化方式管理一组具有相关性的协程。

CoroutineScope表示协程的运行环境，通过同一个CoroutineScope实例启动的协程具有相同的配置，并且都受该CoroutineScope管理。例如：现有一个报表管理模块，其中多个接口都会启动新协程以生成不同维度的报表，这些协程应当由当前模块的CoroutineScope统一管理；如果管理员开启维护模式，需要停止所有报表生成任务，我们可以从CoroutineScope实例调用 `cancel()` 方法，所有通过该实例启动的协程都将被终止。

协程环境主要包括以下部分：

- CoroutineContext : 协程上下文，是一组指导协程运作的配置集合。上下文指明应当使用何种调度器执行任务、出现异常如何进行传递与处理等。
- CoroutineScope : 协程作用域，负责管理一组协程。每个作用域包含一份上下文，我们可以通过作用域启动新的协程或取消所有协程。


# 协程上下文
## 简介
协程上下文由一系列元素组成，它的数据结构类似于集合，每个元素都实现了 `CoroutineContext.Element` 接口，以KEY作为类型标识，我们可以对上下文中的元素进行添加、替换、删除等操作。

常见的上下文元素及其作用如下文列表所示：

- Job : 顶级协程任务，必选。用于组织内部协程的父子关系，常见的值为Job或SupervisorJob。当我们创建上下文时可以省略该元素，此时系统将会自动新建一个Job。
- ContinuationInterceptor : 调度器，可选。通常是协程库内置的CoroutineDispatcher，在JVM平台上用于控制协程任务所使用的工作线程类型。如果创建作用域时未指定调度器，当我们通过 `launch ()` 等方法开启协程时，将使用Dispatchers.Default作为默认调度器。
- CoroutineName : 作用域名称，可选。可在协程任务中获取，用于调试与日志输出。
- CoroutineExceptionHandler : 异常处理器，可选。用于统一处理作用域内协程发生的异常。

下文示例展示了构建协程作用域的基本方法：

🔴 示例一：创建协程作用域。

在本示例中，我们创建一些协程作用域，并指定上下文。

"TestScope.kt":

```kotlin
// 基本的上下文
val scopeA = CoroutineScope(Dispatchers.Default)
println("ScopeA: ${scopeA.coroutineContext}")

// 额外指定名称和SupervisorJob
val scopeB = CoroutineScope(Dispatchers.IO + CoroutineName("A") + SupervisorJob())
println("ScopeB: ${scopeB.coroutineContext}")

// EmptyCoroutineContext
val scopeC = CoroutineScope(EmptyCoroutineContext)
println("ScopeC: ${scopeC.coroutineContext}")
```

此时运行示例程序，并查看控制台输出信息：

```text
ScopeA: [JobImpl{Active}@255316f2, Dispatchers.Default]
ScopeB: [CoroutineName(A), SupervisorJobImpl{Active}@14514713, Dispatchers.IO]
ScopeC: JobImpl{Active}@69663380
```

根据上述输出内容可知：

当我们使用常见的 `CoroutineScope(Dispatchers.Default)` 方式创建协程作用域时，并未指明Job，此时系统自动生成了一个Job `JobImpl{Active}@255316f2` 作为上下文元素。

EmptyCoroutineContext表示所有元素均使用默认值，此时系统只会自动创建Job元素。

---

下文示例展示了修改与访问上下文的基本方法：

🟠 示例二：修改协程上下文。

在本示例中，我们创建协程作用域，并对上下文进行修改。

"TestScope.kt":

```kotlin
val scope = CoroutineScope(Dispatchers.IO + CoroutineName("A") + SupervisorJob())
println("Scope: ${scope.coroutineContext}")

// 通过KEY获取Context中的元素
val job = scope.coroutineContext[Job]
println("获取元素：$job")

// 替换同KEY元素生成新的Context
val newContext1 = scope.coroutineContext + Dispatchers.Default
println("替换元素：$newContext1")

// 添加元素生成新的Context
val newContext2 = scope.coroutineContext + CoroutineExceptionHandler { _: CoroutineContext, e: Throwable ->
    println("捕获到异常：${e.message}")
}
println("新增元素：$newContext2")

// 移除元素生成新的Context
val newContext3 = scope.coroutineContext.minusKey(CoroutineName)
println("移除元素：$newContext3")
```

此时运行示例程序，并查看控制台输出信息：

```text
Scope: [CoroutineName(A), SupervisorJobImpl{Active}@30946e09, Dispatchers.IO]
获取元素：SupervisorJobImpl{Active}@30946e09
替换元素：[CoroutineName(A), SupervisorJobImpl{Active}@30946e09, Dispatchers.Default]
新增元素：[CoroutineName(A), SupervisorJobImpl{Active}@30946e09, net.bi4vmr.study.scope.TestScopeKt$example02$$inlined$CoroutineExceptionHandler$1@69663380, Dispatchers.IO]
移除元素：[SupervisorJobImpl{Active}@30946e09, Dispatchers.IO]
```

根据上述输出内容可知：

上下文与集合类似，它重写了 `+` 、 `[]` 等操作符，我们可以使用 `<协程作用域>[KEY]` 语法获取元素；使用 `<作用域A> + <作用域B>` 合并两个上下文（或向“作用域A”添加元素）。

上下文中具有相同KEY的元素不能共存，当我们向已有Dispatchers.IO的上下文添加Dispatchers.Default后，最终生成的上下文只包括Dispatchers.Default，旧的调度器被替换了。

## Dispatcher
CoroutineDispatcher用于控制协程任务的工作线程，为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测。该调度器仅用于测试，我们通常不会在业务代码中使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。

## Job与SupervisorJob
普通Job将所有子协程与自身视为一个整体，一旦任意子协程抛出异常，就会递归取消其他分支的所有子协程。

<!-- TODO 插入图片 -->

普通Job适用于具有依赖关系的一组任务，可以保证原子性，通常用于执行具体的业务流程。例如：新用户注册时需要验证“用户名称是否被占用”以及“用户密码是否符合复杂度要求”，其中任一操作失败都应当视为注册失败。

SupervisorJob将子协程视为相互独立的个体，当某个子协程抛出异常后，只会终止其所在分支的相关协程，SupervisorJob不会终止其他分支的任何协程。

<!-- TODO 插入图片 -->

SupervisorJob适用于没有依赖关系的一组任务，通常作为一系列业务流程的管理者。例如：报表管理模块的“生成报表A”任务和“生成报表B”任务并无依赖，即使其中之一失败也不影响其他任务，此时我们可以将该模块作用域的上下文指定为SupervisorJob。

🟠 示例三：SupervisorJob和普通Job的区别。

在本示例中，我们使用SupervisorJob和普通Job分别创建协程作用域，并比较二者的异常处理行为。

我们首先创建一个以普通Job作为根Job的协程作用域，并开启两个协程，其中一个协程运行50毫秒后将抛出异常。

"TestScope.kt":

```kotlin
// 创建作用域但未使用SupervisorJob，默认为普通Job。
val scope = CoroutineScope(Dispatchers.Default)
val job1 = scope.launch {
    println("Normal task start.")
    delay(100L)
    println("Normal task end.")
}

val job2 = scope.launch {
    println("Exception task start.")
    delay(50L)
    throw IllegalStateException("Mock Error!")
}

job1.join()
job2.join()
println("Root task end. Normal job cancelled:[${job1.isCancelled}]")
```

此时运行示例程序，并查看控制台输出信息：

```text
Normal task start.
Exception task start.
Root task end. Normal job cancelled:[true]
```

当 `job1` 抛出IllegalStateException异常时，错误向上传递给根Job，此时根Job是普通Job，递归取消了所有任务，因此 `job2` 未执行完成就终止了。

接下在，我们将协程作用域的普通Job替换为SupervisorJob，其他代码保持不变，比较二者行为的差异。

"TestScope.kt":

```kotlin
// 创建作用域且使用SupervisorJob
val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

// 此处已省略部分代码...
```

此时运行示例程序，并查看控制台输出信息：

```text
Normal task start.
Exception task start.
Normal task end.
Root task end. Normal job cancelled:[false]
```

当 `job1` 抛出IllegalStateException异常时，错误向上传递给根Job，此时根Job是SupervisorJob，不会影响其他任务，因此 `job2` 能够执行完毕。

## CoroutineExceptionHandler
协程任务遇到未被捕获的异常时将静默终止，控制台不会输出任何有效信息。为了便于追踪问题，我们可以在协程作用域中注册CoroutineExceptionHandler，一但作用域中的任何协程抛出异常，就会触发Handler的回调方法，我们可以在此处进行日志记录等操作。

🟠 示例四：全局异常处理器。

在本示例中，我们为作用域注册全局异常处理器，并在此处记录日志。

"TestScope.kt":

```kotlin
// 异常处理器实现
val exceptionHandler = CoroutineExceptionHandler { context, exception ->
    println("捕获到协程异常：[${exception.message}]")
}

// 创建作用域并注册异常处理器
val scope = CoroutineScope(Dispatchers.Default + SupervisorJob() + exceptionHandler)
val job = scope.launch {
    println("Exception task start.")
    delay(50L)
    throw IllegalStateException("Mock Error!")
}

job.join()
println("Root task end.")
```

此时运行示例程序，并查看控制台输出信息：

```text
Exception task start.
捕获到协程异常：[Mock Error!]
Root task end.
```

根据上述输出内容可知：

协程任务 `job` 开始运行50毫秒后，抛出IllegalStateException异常，接着异常处理器的回调方法被触发，第二参数 `exception` 即为我们在协程中抛出的模拟异常。

---

> 🚩 提示
>
> CoroutineExceptionHandler在协程抛出异常后接收回调事件，而不是在协程中捕获异常，因此不会改变根Job的行为，异常是否会导致整个协程树递归取消仍由根Job类型决定。

## CoroutineName
CoroutineName用于标识当前作用域，不影响协程的行为，通常用于调试。

🟠 示例五：作用域名称。

在本示例中，我们创建协程作用域并指定名称，然后在协程中获取并输出消息。

"TestScope.kt":

```kotlin
// 未指定CoroutineName的作用域
CoroutineScope(EmptyCoroutineContext).launch {
    val name = coroutineContext[CoroutineName]?.name
    println("默认的作用域名称：[$name]")
}

// 指定了CoroutineName的作用域
CoroutineScope(CoroutineName("BusinessA")).launch {
    val name = coroutineContext[CoroutineName]?.name
    println("指定的作用域名称：[$name]")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
默认的作用域名称：[null]
指定的作用域名称：[BusinessA]
```



<!-- TODO


# 预设作用域

GlobalScope

GlobalScope没有Job，因此其中的协程无法通过GlobalScope统一取消，一般不推荐使用。

public object GlobalScope : CoroutineScope {
    /**
     * Returns [EmptyCoroutineContext].
     */
    override val coroutineContext: CoroutineContext
        get() = EmptyCoroutineContext
}

这是一个 微妙的 API。使用 GlobalScope 时很容易意外造成资源或内存泄漏。启动的 GlobalScope 协程不受结构化并发原则约束，因此如果因问题（如网络缓慢）导致卡顿或延迟，仍能持续工作并消耗资源。例如，考虑以下代码：


MainScope

public fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)


class MyAndroidActivity {
    private val scope = MainScope()

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel()
    }
}


# 常用方法

## 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


有时候我们需要在同一个协程中切换线程，比如先在 IO 线程读数据，再切回 Main 线程更新 UI。这时就要用到 withContext：

withContext如果只定义了调度器，那么其他上下文会被保留，只替换调度器。不用担心切换后异常处理等丢失



withTimeout 会抛出 TimeoutCancellationException




coroutineScope{} 可以访问当前上下文的调度器，在此处启动协程后外部将会等待内部协程执行完毕再运行，如果新建作用域则不会等待。

coroutineScope 提供的是继承了外部作用域的 coroutineContext 的上下文作用域，但它覆盖了来自父节点上下文的 Job。因此，coroutineScope 将和其父节点建立下面这些规则：

    从父节点那里继承上下文
    在完成自己之前等待所有的子节点
    当父节点被取消时，所有子节点也会被取消


supervisorScope 函数的行为也很像 coroutineScope：它创建了一个 CoroutineScope，从外部作用域继承而来，并在其中调用指定的挂起块。不同的是，它用 SupervisorJob 重写了来自上下文的 Job，所以当子协程发生异常时，它不会被取消。



# 结构化并发

在结构化并发一章中，我们提到父子关系会有以下影响：

    子协程从父协程那里继承上下文
    父协程会挂起，直到所有子协程都完成
    当父协程被取消时，所有子协程都将取消
    当一个子协程被销毁时，它也会销毁父协程


当你在一个协程内部启动另一个协程，默认会继承父协程的上下文，且新协程的 Job 成为父 Job 的子 Job：

launch {
    val child = launch {
        delay(1000L)
        println("Child executed")
    }
    child.join()
}

这种结构的好处是：

    父协程取消时，所有子协程自动级联取消
    结构化并发得以保障

但如果你希望协程独立运行（不受父协程影响），有两种方式打破父子关系：

    指定不同的作用域

    GlobalScope.launch { ... }

传入独立的 Job

launch(coroutineContext + Job()) { ... }

✅ 应用场景举例：

    启动后台心跳任务，即使页面销毁也不中断
    日志上报等“火后即忘”型任务


-->


# 实用技巧
## 编码风格
有时我们会看到下文代码块所展示的协程启动方式，这种写法仅适用于简单的示例代码，对于完整的业务模块并不合理。

```kotlin
class UserManager {

    fun updateCurrentUID() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }
}
```

以UserManager为例， `updateCurrentUID()` 和 `updateCurrentName()` 方法都创建了新的协程作用域并启动协程，这使得任务之间没有产生关联，无法实现结构化并发。业务组件中的协程应当跟随组件生命周期，若组件使用完毕而被销毁，其所关联的协程也应当被取消。

除此之外，由于协程作用域直接引用了SDK内置的 `Dispatchers.IO` 调度器，任务执行时机将会变得不可控，在测试环境中，我们难以确保任务执行完毕后再进行断言。

针对不同的场景，我们提供以下两种推荐的编码风格。

对于功能较为简单的底层模块，例如：数据库接口、HTTP接口等，我们可以不创建协程环境，而是将所有方法作为挂起函数，由上层调用者（可能是UI组件或业务聚合组件）自行决定需要在何种协程环境中执行这些方法。

```kotlin
class UserManagerV1 {

    suspend fun updateCurrentUID(): String = "1"

    suspend fun updateCurrentName(): String = "User1"
}
```

以Android平台为例，我们可以使用界面组件提供的LifecycleScope调用挂起函数，一旦界面被用户关闭，对应的协程任务都会被自动取消。

对于功能较为复杂的业务聚合组件，我们可以使用统一的协程作用域新建协程，或者按照功能划分少量的作用域，不必在每个业务方法内部都创建新的作用域。

```kotlin
class UserManagerV2(
    // 使用外部传入的调度器，或提供默认的调度器。
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) {

    // 所有业务使用统一的作用域
    private val scope = CoroutineScope(dispatcher)

    fun updateCurrentUID() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    // 提供组件销毁方法，取消当前作用域的所有协程。
    fun destroy() {
        scope.cancel()
    }
}
```

协程调度器用于控制任务的执行进度，在测试代码中我们需要确保任务执行完毕再检查结果，因此我们将调度器作为构造方法参数，并提供默认值。业务代码构造该实例时无需指定调度器，此时使用预设调度器，测试代码构造该实例时应当传入测试调度器，以便控制协程任务。

我们还可以提供一个 `destroy()` 方法用于取消所有任务，它对可动态加载业务是必要的，若当前模块被卸载，相关任务也应当终止。
