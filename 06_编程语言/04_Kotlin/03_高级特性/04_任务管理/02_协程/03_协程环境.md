<!-- TODO
# 简介

在结构化并发一章中，我们提到父子关系会有以下影响：

    子协程从父协程那里继承上下文
    父协程会挂起，直到所有子协程都完成
    当父协程被取消时，所有子协程都将取消
    当一个子协程被销毁时，它也会销毁父协程

事实上，子协程从父协程继承上下文是协程构建器行为的基本组成部分。


CoroutineContext即协程上下文。它是一个包含了用户定义的一些各种不同元素的Element对象集合。其中主要元素是Job、协程调度器CoroutineDispatcher、还有包含协程异常CoroutineExceptionHandler、拦截器ContinuationInterceptor、协程名CoroutineName等。这些数据都是和协程密切相关的，每一个Element都一个唯一key。

CoroutineContext：是协程运行时的“配置”，包含了线程调度、异常处理、父子关系等元素。
CoroutineScope：是“持有”这份配置的容器，并以此来启动、管理和取消一组协程。

这种分离设计，使得协程能够在保持层次结构和生命周期可控的同时，灵活指定执行线程与异常策略。

context中的同类元素不可共存，重新设置会取代旧的元素，不同类元素可以共存


-->

# 调度器
为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测，我们通常不使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。

<!-- TODO
# 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


不用小明思考了，我们直接开撸源码。协程使用过程中除了launch/asyc/runBlocking/delay 之外，想必还有一个函数比较熟悉：withContext。
刚接触时大家都使用它来切换线程用以执行新的协程(子协程)，而原来的协程(父协程)则被挂起。当子协程执行完毕后将会恢复父协程的运行。



withTimeout 会抛出 TimeoutCancellationException




coroutineScope{} 可以访问当前上下文的调度器，在此处启动协程后外部将会等待内部协程执行完毕再运行，如果新建作用域则不会等待。

coroutineScope 提供的是继承了外部作用域的 coroutineContext 的上下文作用域，但它覆盖了来自父节点上下文的 Job。因此，coroutineScope 将和其父节点建立下面这些规则：

    从父节点那里继承上下文
    在完成自己之前等待所有的子节点
    当父节点被取消时，所有子节点也会被取消


supervisorScope 函数的行为也很像 coroutineScope：它创建了一个 CoroutineScope，从外部作用域继承而来，并在其中调用指定的挂起块。不同的是，它用 SupervisorJob 重写了来自上下文的 Job，所以当子协程发生异常时，它不会被取消。



## 实用技巧


不推荐的做法：

class A{

    fun A1(){
        CoroutineScope(Dispachers.Default).launch {
            ....
        }
    }

    fun A2(){
        CoroutineScope(Dispachers.Default).launch {
            ....
        }
    }
}

这种写法每个方法被调用时都会创建新的协程环境，每个任务之间没有产生关联，无法实现结构化并发，理论上A的子功能跟随对象，如果对象需要销毁，子协程都应当被撤销。
这种写法也导致测试困难，因为协程环境无法统一被管理。


如果不关心运行环境，可以只保留suspend 方法并使用coroutineScope{}获取协程上下文，像工具类一样作为最小的功能模块，由上层控制用什么协程环境执行。
提供最小能力，方法之间没有什么关联，比如数据库：查询用户信息，查询用户数量等，可以由调用者自行控制环境，例如界面可以使用lifecyclescope，当界面关闭时任务自动取消。
class A{
    suspend fun A1(){}
    suspend fun A2(){}
}

或者将协程环境作为构造方法的一个参数，若外部指定了协程环境则进行使用，若未指定则内部创建一个协程环境，这种方式兼容了多种场景，并且利于测试。

class A (
    // 使用外部传入的调度器，或使用默认的调度器
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
){
private val scope : = CoroutineScope(dispatcher)
    fun A1(){
        scope.launch{
            ...
        }
    }
    fun A2(){
        scope.launch{
            ...
        }
    }
}

实现了可注入的协程调度器，便于测试代码控制协程，内部提供了统一的环境，可以实现结构化并发与统一取消。

对于测试代码：

@Test

    fun testFetchData() = runTest {

        // 使用 TestDispatcher 替换真实调度器

        val testDispatcher = StandardTestDispatcher(testScheduler)

        val useCase = MyUseCase(testDispatcher)


        val result = useCase.fetchData()


        assertEquals("data", result)

        // runTest 会自动等待所有协程完成（包括 delay）

    }

runTest相当于runBlocking，会自动等待其他协程执行完毕。

testScheduler是runTest提供的环境，只有通过它创建的TestDispatcher，才会被advanceUntilIdle()识别。因此测试时需要注入测试Dispatcher，才能可控执行。

-->
