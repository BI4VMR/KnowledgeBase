<!-- TODO
# 简介
到目前为止示例代码中的协程相互独立，相互之间没有关联，在实际业务中我们会通过协程环境管理协程，例如订单管理与报表查询各自使用独立的环境，如果报表查询任务关联的页面被关闭，可以取消其所关联的协程，而订单模块的任务仍然继续运行。

协程环境主要包括以下部分：

- CoroutineContext : 协程上下文，配置应当使用何种调度器执行协程、如何进行异常处理、父子协程的关系等。
- CoroutineScope : 协程作用域，作用域包含上下文，我们可以通过作用域启动与取消协程，这些协程的行为将按照上下文配置进行操作。


CoroutineContext.Element
一个 Job（或 SupervisorJob），用以组织该 Scope 下所有协程的父子关系；如果创建时未指定job则会自动新建一个
至少一个 ContinuationInterceptor，决定默认的调度器；
其他可选元素，如 CoroutineName、CoroutineExceptionHandler 等。


context中的同类元素不可共存，重新设置会取代旧的元素，不同类元素可以共存


EmptyCoroutineContext表示所有都采用默认值，因为构建CoroutineScope时CoroutineContext不能为Null，所以通过专门的类表示默认

-->

# 调度器
为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测，我们通常不使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。

<!-- TODO
# 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


有时候我们需要在同一个协程中切换线程，比如先在 IO 线程读数据，再切回 Main 线程更新 UI。这时就要用到 withContext：

withContext如果只定义了调度器，那么其他上下文会被保留，只替换调度器。不用担心切换后异常处理等丢失



withTimeout 会抛出 TimeoutCancellationException




coroutineScope{} 可以访问当前上下文的调度器，在此处启动协程后外部将会等待内部协程执行完毕再运行，如果新建作用域则不会等待。

coroutineScope 提供的是继承了外部作用域的 coroutineContext 的上下文作用域，但它覆盖了来自父节点上下文的 Job。因此，coroutineScope 将和其父节点建立下面这些规则：

    从父节点那里继承上下文
    在完成自己之前等待所有的子节点
    当父节点被取消时，所有子节点也会被取消


supervisorScope 函数的行为也很像 coroutineScope：它创建了一个 CoroutineScope，从外部作用域继承而来，并在其中调用指定的挂起块。不同的是，它用 SupervisorJob 重写了来自上下文的 Job，所以当子协程发生异常时，它不会被取消。



# 结构化并发

在结构化并发一章中，我们提到父子关系会有以下影响：

    子协程从父协程那里继承上下文
    父协程会挂起，直到所有子协程都完成
    当父协程被取消时，所有子协程都将取消
    当一个子协程被销毁时，它也会销毁父协程


当你在一个协程内部启动另一个协程，默认会继承父协程的上下文，且新协程的 Job 成为父 Job 的子 Job：

launch {
    val child = launch {
        delay(1000L)
        println("Child executed")
    }
    child.join()
}

这种结构的好处是：

    父协程取消时，所有子协程自动级联取消
    结构化并发得以保障

但如果你希望协程独立运行（不受父协程影响），有两种方式打破父子关系：

    指定不同的作用域

    GlobalScope.launch { ... }

传入独立的 Job

launch(coroutineContext + Job()) { ... }

✅ 应用场景举例：

    启动后台心跳任务，即使页面销毁也不中断
    日志上报等“火后即忘”型任务


-->


# 实用技巧
## 编码风格
有时我们会看到下文代码块所展示的协程启动方式，这种写法仅适用于简单的示例代码，对于完整的业务模块并不合理。

```kotlin
class UserManager {

    fun updateCurrentUID() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        CoroutineScope(Dispatchers.IO).launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }
}
```

以UserManager为例， `updateCurrentUID()` 和 `updateCurrentName()` 方法都创建了新的协程作用域并启动协程，这使得任务之间没有产生关联，无法实现结构化并发。业务组件中的协程应当跟随组件生命周期，若组件使用完毕而被销毁，其所关联的协程也应当被取消。

除此之外，由于协程作用域直接引用了SDK内置的 `Dispatchers.IO` 调度器，任务执行时机将会变得不可控，在测试环境中，我们难以确保任务执行完毕后再进行断言。

针对不同的场景，我们提供以下两种推荐的编码风格。

对于功能较为简单的底层模块，例如：数据库接口、HTTP接口等，我们可以不创建协程环境，将所有方法都作为挂起方法，由上层调用者（可能是UI组件或业务聚合组件）自行决定需要在何种协程环境中执行这些方法。

```kotlin
class UserManagerV1 {

    suspend fun updateCurrentUID(): String = "1"

    suspend fun updateCurrentName(): String = "User1"
}
```

以Android平台为例，我们可以使用界面组件提供的LifecycleScope调用挂起函数，一旦界面被用户关闭，对应的协程任务都会被自动取消。

对于功能较为复杂的业务聚合组件，我们可以使用统一的协程作用域新建协程，或者按照功能划分少量的作用域，不必在每个业务方法内部都创建新的作用域。

```kotlin
class UserManagerV2(
    // 使用外部传入的调度器，或提供默认的调度器。
    dispatcher: CoroutineDispatcher = Dispatchers.IO
) {

    // 所有业务使用统一的作用域
    private val scope = CoroutineScope(dispatcher)

    fun updateCurrentUID() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    fun updateCurrentName() {
        // 方法内部不要单独创建作用域
        scope.launch {
            // 模拟耗时操作...
            delay(1000L)
        }
    }

    // 提供组件销毁方法，取消当前作用域的所有协程。
    fun destroy() {
        scope.cancel()
    }
}
```

协程调度器用于控制任务的执行进度，在测试代码中我们需要确保任务执行完毕再检查结果，因此我们将调度器作为构造方法参数，并提供默认值。业务代码构造该实例时无需指定调度器，此时使用预设调度器，测试代码构造该实例时应当传入测试调度器，以便控制协程任务。

我们还可以提供一个 `destroy()` 方法用于取消所有任务，它对支持动态加载的业务是有必要的，若当前模块被卸载，相关任务也应当终止。
