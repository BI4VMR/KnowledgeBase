<!-- TODO
# 简介
-->

# 调度器
为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测，我们通常不使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。

<!-- TODO
# 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


不用小明思考了，我们直接开撸源码。协程使用过程中除了launch/asyc/runBlocking/delay 之外，想必还有一个函数比较熟悉：withContext。
刚接触时大家都使用它来切换线程用以执行新的协程(子协程)，而原来的协程(父协程)则被挂起。当子协程执行完毕后将会恢复父协程的运行。

coroutineScope{} 可以访问当前上下文的调度器，在此处启动协程后外部将会等待内部协程执行完毕再运行，如果新建作用域则不会等待。
-->
