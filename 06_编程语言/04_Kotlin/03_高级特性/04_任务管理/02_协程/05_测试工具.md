<!-- TODO


org.jetbrains.kotlinx", name = "kotlinx-coroutines-test 1.7.3

dependencies {
    // 协程测试工具
    testImplementation(libKotlin.ktx.coroutines.test)
}

JUnit测试环境与普通命令行程序一样，测试方法为主线程，运行完毕后其他非守护线程都会被杀死。在测试协程代码时，我们需要使用一些特殊的技巧，防止协程未结束就终止，无法得到预期结果。

延时等待协程操作完毕再检查任务结果


runtest{}

同runBlocking{}，提供协程环境，我们可以在其中调用suspend函数，会阻塞测试线程等待协程语句执行完毕再退出，但它有一个特性，delay方法延时会提前，节约测试时间。



runtest内部提供了两个变量：

testScheduler：协程调度器，可以控制协程的执行时间点。
配合 advanceTimeBy(ms: Long) advanceUntilIdle() 使用，可以手动控制测试代码与其他协程的执行顺序。

backgroundScope: 协程作用域，可以在测试方法中启动后台协程，测试用例结束后自动取消，可以模拟全局任务，不受advanceTimeBy(ms: Long) advanceUntilIdle()的影响，错误也不会阻断测试。


testScheduler是runTest提供的环境，只有通过它创建的TestDispatcher，才会被advanceUntilIdle()识别。因此测试时需要向测试对象注入测试Dispatcher，才能可控执行。

首先要求被测代码按照前文章节 中的推荐写法进行组织，将作用域通过构造方法或可写变量注入，然后可以使用advanceUntilIdle()


如果被测代码直接引用调度器创建协程环境，则无法通过runtest{}与advanceUntilIdle()测试，此时我们只能通过预估任务执行时长并使主线程休眠的方法进行测试。




Test task end.
UpdateCurrentUID start.


UpdateCurrentUID start.
UpdateCurrentUID end.
Test task end.

-->
