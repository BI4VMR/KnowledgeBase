# 简介
协程(Coroutine)是一种异步任务调度工具，具有语法简洁、使用方便的特点，在很多编程语言中都有实现。Kotlin协程定义了“挂起”的概念，任务可以暂停并根据条件自动恢复，相比线程与接口回调更为直观。

CPU与OS领域只有“线程”这一概念，“协程”是编程语言领域所定义的概念，CPU与OS无法理解“协程”。在JVM平台中，Kotlin协程基于线程实现，协程代码编译后生成的字节码实际上就是在调度线程。由于Kotlin语言是跨平台的，不同目标平台上的协程实现可能有所差异，本文内容主要以JVM平台为基础。

本章内容的前置知识可以参考以下链接：

- [🧭 线程 - 概述](../01_线程/01_概述.md)

本章示例工程详见以下链接：

- [🔗 示例工程：协程](https://github.com/BI4VMR/Study-Kotlin/tree/master/M03_Advance/C03_Parallelism/S02_Coroutine)

# 基本应用
下文示例展示了协程的基本用法，我们创建协程环境并提交任务，延时片刻模拟耗时操作，并输出一些日志信息。

"TestCoroutine.kt":

```kotlin
fun main() {
    // 使用Default调度器，提交任务并启动协程。
    CoroutineScope(Dispatchers.Default).launch {
        println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
        // 延时2秒，模拟耗时操作。
        delay(2000)
        println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
    }

    // 阻塞主线程5秒，避免协程提前终止。
    Thread.sleep(5000L)
}
```

`CoroutineScope()` 方法用于创建协程环境， `Dispatchers.Default` 是框架内置的调度器，指定了协程任务将在子线程中运行， `launch()` 方法也被称为协程构建器，用于提交任务并开始执行任务。

日志输出语句中的 `getThread()` 方法用于获取工作线程名称， `getTime()` 方法则用于获取当前时间，此处省略具体实现，详见本章示例工程。

此处的实验环境为Java SE平台，我们需要在启动协程后使用 `Thread.sleep()` 方法阻塞主线程等待协程任务完成，这是因为JVM平台中的协程基于线程实现，主线程执行完毕则整个进程结束，所有非守护线程（包括协程任务）都会立刻终止。如果我们使用Web Server、Android等主线程无限循环的环境进行实验，则无需调用 `Thread.sleep()` 方法。为了减少篇幅，本章后续示例代码均省略 `Thread.sleep()` 方法调用。

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Name:[DefaultDispatcher-worker-1] Time:[15:22:06.914]
Task end. Name:[DefaultDispatcher-worker-1] Time:[15:22:08.936]
```

根据上述输出内容可知：

协程任务在Default调度器所分配的工作线程"worker-1"中运行，遇到 `delay(2000)` 方法时暂停运行；2秒后计时结束，任务再次恢复运行。

# 挂起与恢复
“挂起”是Kotlin协程的一种特性，当协程任务由于某些原因（开发者主动请求延时、等待服务器响应等）被“挂起”时，该任务进入暂停状态，并与工作线程脱离，此时协程不会阻塞工作线程，工作线程可以继续为其他协程服务。一段时间后，延时结束或收到服务器的响应，当前协程任务解除“挂起”，从暂停状态中恢复，调度器将会重新为它分配工作线程，继续执行剩余的语句。

对于可复用的代码片段，我们通常会将其定义为方法，例如前文示例协程任务中的延时与日志输出逻辑：

```kotlin
fun task() {
    println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(2000)
    println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
}
```

上述方法定义语句将会导致编译错误，这是因为“挂起”特性是Kotlin协程专有的，非协程部分无法使用该特性，此处的延时方法 `delay()` 就是一个会导致“挂起”的语句。

如果一个方法中含有可能导致“挂起”的语句，我们必须在方法声明语句中添加"suspend"关键字，标识本方法只能在协程任务中使用。

"TestCoroutine.kt":

```kotlin
suspend fun task(): Int {
    println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(2000)
    println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
    return 0
}

CoroutineScope(Dispatchers.Default).launch {
    // 开启任务并获取返回值
    val value = task()
    println("Task return value is $value")
}.join()
```

被"suspend"关键字修饰的方法也叫“挂起函数”，挂起函数不仅可以被协程任务调用，还可以被嵌套在其他挂起函数中。协程库的内置方法 `delay()` 就是一个挂起函数，因此它可以出现在CoroutineScope实例的 `launch()` 方法中，也可以出现在挂起函数 `task()` 的方法体中。

挂起函数可以拥有返回值，当程序运行至"return"语句时，挂起函数执行完毕，调用者可以声明一个变量接收该值。

在JVM平台中，协程的“挂起”特性由回调机制实现。以协程任务语句 `val value = task()` 为例，当挂起函数 `task()` 开始执行时，调用者注册了结果回调；当延时语句 `delay(2000)` 结束并运行至"return"语句时，调用者通过结果回调接收返回值，并赋值给变量 `value` 。这就是协程代码表现形式为同步，执行效果却为异步的原理。

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Name:[DefaultDispatcher-worker-1] Time:[20:49:56.009]
Task end. Name:[DefaultDispatcher-worker-1] Time:[20:49:58.035]
Task return value is 0
```

我们可以同时开启多个协程任务，以便测试协程任务与工作线程之间的关系。

"TestCoroutine.kt":

```kotlin
suspend fun task(name: String, time: Long) {
    println("Task $name start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(time)
    println("Task $name end. Name:[${getThread()}] Time:[${getTime()}]")
}

val scope = CoroutineScope(Dispatchers.Default)
// 开启第一个任务
scope.launch {
    task("1", 2000)
}
// 开启第二个任务
scope.launch {
    task("2", 3000)
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 1 start. Name:[DefaultDispatcher-worker-1] Time:[21:07:19.332]
Task 2 start. Name:[DefaultDispatcher-worker-2] Time:[21:07:19.332]
Task 1 end. Name:[DefaultDispatcher-worker-2] Time:[21:07:21.368]
Task 2 end. Name:[DefaultDispatcher-worker-2] Time:[21:07:22.376]
```

根据上述输出内容可知：

Task1和Task2依次启动，Default调度器分别为它们分配了工作线程"worker-1"和"worker-2"；Task1执行挂起函数 `delay()` 后进入暂停状态，与工作线程分离，Task2亦然。

2秒之后，Task1首先从暂停状态中恢复，调度器将先前分配给Task2的工作线程"worker-2"分配给Task1，使其继续执行日志输出语句，该现象说明Task2在挂起刻时已经与工作线程"worker-2"分离，而不会使工作线程阻塞，在此期间工作线程可以处理其他任务。



# 协程的生命周期


<div align="center">

![生命周期](./Assets_概述/协程的生命周期_生命周期.jpg)

</div>


| **State**                        | [isActive] | [isCompleted] | [isCancelled] |
| -------------------------------- | ---------- | ------------- | ------------- |
| _New_ (optional initial state)   | `false`    | `false`       | `false`       |
| _Active_ (default initial state) | `true`     | `false`       | `false`       |
| _Completing_ (transient state)   | `true`     | `false`       | `false`       |
| _Cancelling_ (transient state)   | `false`    | `false`       | `true`        |
| _Cancelled_ (final state)        | `false`    | `true`        | `true`        |
| _Completed_ (final state)        | `false`    | `true`        | `false`       |


# 取消协程任务



"TestCoroutine.kt":

```kotlin
// 启动一个协程，循环输出日志信息。
val job: Job = CoroutineScope(Dispatchers.Default).launch {
    for (i in 1..10_000) {
        println("Task start. Index:[$i]")
    }
}

// 主线程等待25毫秒，然后取消协程任务。
Thread.sleep(25L)
job.cancel()
println("Try to cancel task.")
```

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Index:[1]
Task start. Index:[2]

此处省略部分输出内容 ...

Task start. Index:[10000]
```

根据上述输出内容可知：




## 取消非挂起任务

"TestCoroutine.kt":

```kotlin
// 启动一个协程，循环输出日志信息。
val job: Job = CoroutineScope(Dispatchers.Default).launch {
    for (i in 1..10_000) {
        // 每轮循环开始前，先判断当前任务是否已被取消。
        if (!isActive) {
            // 任务被取消时，终止后续任务。
            println("Task was canceled!")
            return@launch
        }

        println("Task start. Index:[$i]")
    }
}

// 主线程等待25毫秒，然后取消协程任务。
Thread.sleep(25L)
println("Try to cancel task.")
job.cancel()
```

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Index:[1]
Task start. Index:[2]
Try to cancel task.

此处省略部分输出内容 ...

Task start. Index:[2689]
Task was canceled!
```

根据上述输出内容可知：



## 取消已挂起任务

"TestCoroutine.kt":

```kotlin
// 启动一个协程，循环输出日志信息。
val job: Job = CoroutineScope(Dispatchers.Default).launch {
    try {
        println("Task start.")
        delay(2000L)
        println("Task end.")
    } catch (e: CancellationException) {
        println("Catch cancellation exception!")
    }
}

// 主线程等待25毫秒，然后取消协程任务。
Thread.sleep(25L)
println("Try to cancel task.")
job.cancel()
```

此时运行示例程序，并查看控制台输出信息：

```text
Task start.
Try to cancel task.
Catch cancellation exception!
```

根据上述输出内容可知：
