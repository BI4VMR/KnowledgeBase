# 顺序执行任务
协程任务中的语句默认按照书写顺序执行，当前一个语句执行完毕后，才会开始执行后一个语句。

"TestCooperation.kt":

```kotlin
// 测试方法：延时特定秒数。
suspend fun task(name: String, time: Long) {
    println("Task $name start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(time)
    println("Task $name end. Name:[${getThread()}] Time:[${getTime()}]")
}

CoroutineScope(Dispatchers.Default).launch {
    // 先执行第一个任务
    task("1", 2000)
    // 第一个任务执行完毕后，再执行第二个任务。
    task("2", 2000)
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 1 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:18.351]
Task 1 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:22.397]
```

对于多个具有顺序依赖关系的异步任务，协程代码相比方法回调代码缩进层次更少、更加简洁。

在下文示例中，我们已知学生ID，需要先通过“查询学生详情”异步接口获取学生信息，再从学生信息中同步获取班级ID，最后通过“查询班级详情”异步接口获取班级详情。

下文代码块展示了方法回调风格的伪代码：

```kotlin
val studentID: Long = 1

// 首先根据ID查询学生信息
queryStudent(studentID, object : OnResult() {
    override fun onSuccess(student: Student) {
        // 获取班级ID
        val classID: Long = student.classID
        // 然后根据班级ID查询班级信息
        queryClass(classID, object : OnResult() {
            override fun onSuccess(classInfo: ClassInfo) {
                // 显示班级信息
                println(classInfo)
            }
        })
    }
})
```

下文代码块则展示了协程风格的伪代码：

```kotlin
val studentID: Long = 1

CoroutineScope(Dispatchers.Default).launch {
    // 首先根据ID查询学生信息
    val student: Student = queryStudent(studentID)
    // 获取班级ID
    val classID: Long = student.classID
    // 然后根据班级ID查询班级信息
    val classInfo: ClassInfo = queryClass(classID)
    // 显示班级信息
    println(classInfo)
}
```

# 并发执行任务
我们可以在协程任务中使用协程构建器再次开启新的任务，这些任务将将与开启它们的任务并发执行，不会互相等待。





在下文示例中，





"TestCoroutine.kt":

```kotlin
CoroutineScope(Dispatchers.Default).launch {
    // 使用"launch()"方法开启任务，不接收返回值。
    launch { task("1", 2000) }

    // 使用"async()"方法开启任务，并通过变量保存任务实例，以便后续获取返回值。
    val job: Deferred<Int> = async {
        task("2", 2000)
        114514
    }
    // 异步等待任务结束，并接收返回值。
    val result: Int = job.await()
    println("Task 2 is end, result is $result.")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 2 start. Name:[DefaultDispatcher-worker-3] Time:[17:36:44.620]
Task 1 start. Name:[DefaultDispatcher-worker-2] Time:[17:36:44.620]
Task 2 end. Name:[DefaultDispatcher-worker-3] Time:[17:36:46.656]
Task 1 end. Name:[DefaultDispatcher-worker-2] Time:[17:36:46.656]
Task 2 is end, result is 114514.
```

根据上述输出内容可知：


# 等待多个任务的结果

