# 顺序执行任务
协程任务中的语句默认按照书写顺序执行，当前一个语句执行完毕后，才会开始执行后一个语句。

"TestCoroutine.kt":

```kotlin
CoroutineScope(Dispatchers.Default).launch {
    // 先执行第一个任务
    task("1", 2000)
    // 第一个任务执行完毕后，再执行第二个任务。
    task("2", 2000)
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 1 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:18.351]
Task 1 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:22.397]
```

对于多个串行化的异步任务，协程代码相比方法回调代码缩进层次更少、更加简洁。

假设我们已知学生ID，需要先通过“查询学生详情”异步接口获取学生信息，再从学生信息中同步获取班级ID，最后通过“查询班级详情”异步接口获取班级详情。

对于该场景，下文代码块展示了方法回调风格的伪代码：

```kotlin
val studentID: Long = 1

// 首先根据ID查询学生信息
queryStudent(studentID, object : OnResult() {
    override fun onSuccess(student: Student) {
        // 获取班级ID
        val classID: Long = student.classID
        // 然后根据班级ID查询班级信息
        queryClass(classID, object : OnResult() {
            override fun onSuccess(classInfo: ClassInfo) {
                // 显示班级信息
                println(classInfo)
            }
        })
    }
})
```

下文代码块则提供了协程风格的伪代码：

```kotlin
val studentID: Long = 1

CoroutineScope(Dispatchers.Default).launch {
    // 首先根据ID查询学生信息
    val student: Student = queryStudent(studentID)
    // 获取班级ID
    val classID: Long = student.classID
    // 然后根据班级ID查询班级信息
    val classInfo: ClassInfo = queryClass(classID)
    // 显示班级信息
    println(classInfo)
}
```
