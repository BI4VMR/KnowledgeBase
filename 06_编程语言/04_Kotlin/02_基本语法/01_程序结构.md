# 最小代码片段
我们新建一个文本文件，名称为 `TestFirst.kt` ，内容如下文代码块所示：

"TestFirst.kt":

```kotlin
// "main"方法，是程序的入口。
fun main(args: Array<String>) {
    // 在控制台上显示文字
    println("Hello World!")
}
```

这是一个Kotlin应用程序的基本结构，Kotlin支持以脚本方式运行，所以我们可以直接书写方法，不必书写类的结构。 `main()` 方法是程序的入口，程序开始运行时，将会从此处开始执行代码语句；其中的语句都执行完毕时，程序运行结束。

为节约篇幅与缩进，后文的示例代码若无特殊说明，均省略类与 `main()` 方法定义，只展示关键内容。

# 注释
注释(Comment)是对代码的解释和说明，其目的是让人们能够更加轻松地理解代码。在编译过程中，注释语句会被编译器忽略并移除，最终生成的程序中不会包含任何注释语句。

Kotlin中的注释有三种类型：

- 单行注释以 `//` 开头，行末自然结束，正如前文示例中的描述文本。
- 多行注释以 `/*` 开头，以 `*/` 结尾，中间的行都被视为注释文本。
- 文档注释以 `/**` 开头，以 `*/` 结尾，允许多行，通常用于描述类与方法的详细信息。

我们可以在文档注释中使用一些KDoc标记，以便通过Dokka等工具生成详细的程序说明文档。

🔷 `@version <版本号>`

声明类的版本。

🔷 `@author <作者>`

声明类或方法的作者。

🔷 `@see <类或方法名称>`

表示另请参见类或方法。

🔷 `@param <参数名称> <参数含义>`

说明方法的参数及其含义。

为了更明显的标记参数，我们也可以使用以下语法书写参数说明： `@param[<参数名称>] <参数含义>` 。

🔷 `@return <返回值含义>`

说明方法的返回值含义。

🔷 `@exception <异常名称> <异常说明>`

说明方法可能抛出的异常信息。

🔷 `@since <版本号>`

说明方法首次创建时程序的版本号。

<br/>

文档注释中所有非"@"标记开头的行、"@"标记中的说明文本都属于描述信息，我们可以在其中添加以下特殊符号：

🔷 `[显示名称] [<类或方法>]`

指向类或方法的链接。

该标记在文档中显示为可以点击跳转的链接，下文列表提供了一些示例：

- `[BigDecimal]` : 链接到BigDecimal类。
- `[BigDecimal.ZERO]` : 链接到BigDecimal类的属性 `ZERO` 。
- `[BigDecimal.add]` : 链接到BigDecimal类的方法 `add(BigDecimal augend)` 。

KDoc与JavaDoc不同，指向方法时也需要使用"."进行连接，而不是“#+方法名称”；并且不支持通过参数列表指向某个重载方法。

如果类已经在当前文件首部通过 `import` 语句导入，则链接中可以直接书写类名；否则需要书写为完全限定名称。

若我们需要指向某个URL，则应当使用Markdown语法书写：

```md
[外部网站](https://www.example.com)
```

🔷 `<空行>`

换行标记。

在Dokka工具生成的文档中，换行符将会显示为空格；为了实现换行显示，我们需要在两行文本之间添加一个空行。

"@"标记开头的行将会自动换行，我们无需手动添加换行标记。

# 关键字与标识符
<!-- TODO -->


# 变量
## 简介



## 数据类型



# 常量



# 空值安全
## 简介
在Java等面向对象语言中，我们无法从对象的类型判断出对象是否可能为空值。若一个对象为空值，此时访问它的属性或方法，将导致空指针异常"NullPointerException"；如果处理不当更会导致程序崩溃等严重后果。

Kotlin的类型系统能够标明对象是否可能为空值，当我们访问可空对象时，编译器将会检查代码是否进行了空值检查，以便提前发出错误提示，在一定程度上减少空指针异常。

默认情况下，变量是不可为空的，我们必须在声明变量时赋予有效的初始值。如果一个变量的值可以为空，我们需要在它的类型之后添加一个问号("?")作为标识。

```kotlin
// 声明非空字符串"str1"
var str1: String = "字符串内容"
// 声明可空字符串"str2"
var str2: String? = null

// 将空值赋予非空字符串，该语句无法通过编译。
str1 = null
// 将空值赋予可空字符串，该语句可以通过编译。
str2 = null

// 调用无空变量的属性，该语句可以通过编译。
str1.length
// 调用可空变量的属性，该语句无法通过编译。
str2.length
```

在上述示例代码中，当我们将"null"赋值给非空变量、未经判空直接访问可空变量时，编译器都会产生错误提示，提示我们修正代码。

## 安全调用操作符
当我们访问可空变量中的属性与方法时，可以使用安全调用操作符 `?.` 。

在表达式 `<对象>?.<方法或属性>` 中，如果对象为空值，该表达式的结果也为空值；如果对象不为空值，则表达式的结果为方法返回值或属性。

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

// 使用安全调用操作符访问两个变量
println("str1的内容：" + str1?.length)
println("str2的内容：" + str2?.length)
```

在上述示例代码中，方法 `String.length()` 的返回值类型为 `Int` ，因此表达式 `str1?.length` 的返回值类型为 `Int?` 。

此时运行示例程序，并查看控制台输出信息：

```text
str1的内容：5
str2的内容：null
```

根据上述输出内容可知：

对象 `str1` 的值不为空，因此整个表达式的值为字符串长度"5"；对象 `str2` 的值为空，因此整个表达式的值为"null"。

## 判断空值
当我们需要判断对象是否为空时，可以采用所有语言通用的等值判断语法，也可以使用安全调用操作符，后者比前者更为简洁。

```kotlin
var str: String? = null

// 判断字符串是否为空值
if (str != null) {
    // 当变量不为空时，再访问其中的属性与方法。
    println(str.length)
}

// 上述逻辑的等价写法
str?.let {
    // 变量"it"等同于"str"
    println(it)
}
```

`<对象>.let{}` 是一个Kotlin标准库中的扩展函数，在其作用域内可以使用变量 `it` 访问对象。在上述示例代码中，我们结合安全调用操作符使用扩展函数，表达式为 `<对象>?.let{}` 。当对象为空时，表达式结果为"null"，整个语句将被忽略；当对象不为空时，将会执行 `let{}` 作用域中的语句。

当我们使用安全调用操作符时，扩展函数中的逻辑只在对象不为空值时执行，如果对象为空和非空时都需要执行一些逻辑，我们就无法使用安全调用操作符了。

## 级联判空
安全调用操作符可以级联使用，这有利于减少模板代码。

假设现有一个学生对象 `student` ，我们需要依次调用方法获取“所有课程”、“最新课程”、“最新课程的学分”。前述每个步骤获取到的对象均可能为空，因此我们需要按照如下步骤逐层进行空值判断。

```kotlin
// 获取学生的所有课程
val courses = student.getCourses()
if (courses != null) {
    // 获取最新选择的课程
    val latestCourse = courses.getLatestCourse()
    if (latestCourse != null) {
        // 获取课程的学分
        val credit = latestCourse.getCredit()
        println("学分：$credit")
    }
}
```

我们可以级联使用安全调用操作符，将上述代码简化为一行。

```kotlin
val credit = student?.getCourses()?.getLatestCourse()?.getCredit()
println("学分：$credit")
```

当程序运行至级联语句时，它会从左至右依次执行每个步骤，只要其中任意一个步骤的结果为空，整个表达式的结果即为空。

## Elvis运算符
Elvis运算符的形式为 `<表达式A> ?: <表达式B>` ，当表达式A的结果不为"null"时，整个语句的结果即表达式A的结果；当表达式A的结果为"null"时，整个语句的结果为表达式B的结果；

```kotlin
var str1: String? = "字符串内容"
var str2: String? = null

val length1: Int = str1?.length ?: 0
val length2: Int = str2?.length ?: 0

println("str1的长度:$length1")
println("str2的长度:$length2")
```

此时运行示例程序，并查看控制台输出信息：

```text
str1的长度:5
str2的长度:0
```

根据上述输出内容可知：

字符串 `str1` 不为空，因此表达式 `str1?.length` 也不为空，此时整个Elvis语句的结果为 `str1?.length` 的结果。字符串 `str2` 为空，因此表达式 `str2?.length` 为空，此时整个Elvis语句的结果是"0"。

Elvis运算符通常用于设置左侧表达式为空时的默认值，此时右侧表达式将被直接填写为默认值。若右侧表达式包含修改其他变量的操作，则需要引起注意，仅当左侧表达式为空时，右侧表达式才会触发修改动作。

Elvis运算符的右侧表达式不仅支持普通数值运算，还能使用"return"和"throw"语句，我们可以按需使用。

```kotlin
// 在Elvis运算符中使用"return"和"throw"语句
fun getLength(str: String?): Int {
    str?.length ?: return 0
    str?.length ?: throw IllegalArgumentException("入参为空值！")
}
```

## 非空断言
非空断言运算符 `!!` 能够使未经判空的语句通过编译器检查，但程序运行至此处时仍会产生NPE而崩溃。

```kotlin
var str: String? = null

// 该语句无法通过编译。
println(str.length)

// 该语句可以通过编译，但运行时将会出现NPE。
println(str!!.length)
```

非空断言只能用来解除Kotlin语法限制，其他情况下都不应当被使用。

如果一个变量初始化前为空，初始化后必不为空，我们就会将它的"get"方法返回值设为非空，一种典型的情况为懒汉式单例类。

```kotlin
@Volatile
private var instance: Singleton? = null

@JvmStatic
fun getInstance(arg1: Any): Singleton {
    if (instance == null) {
        synchronized(this) {
            if (instance == null) {
                instance = Singleton(arg1)
            }
        }
    }
    return instance!!
}
```

单例变量 `instance` 默认为空，实例化语句在同步块之内， `getInstance()` 方法执行结束时不可能为空，因此返回值为非空；Kotlin编译器无法识别这种情况，因此我们需要在"return"语句中使用非空断言解除语法限制。
