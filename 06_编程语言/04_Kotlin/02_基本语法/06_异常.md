# 简介
当程序运行时，外部环境不一定总能满足条件，例如：我们准备向磁盘中写入一些数据，但磁盘的剩余空间可能不足，即使我们在写入前已检查剩余空间，写入过程中磁盘仍然可能被其他程序填满，从而导致写入失败。

阻止程序正确运行的问题被统称为“异常(Exception)”，我们可以在编码阶段对常见的异常进行处理，最大程度上确保程序运行稳定。

Kotlin中的异常继承自Throwable类，随后可以分为两个大类：Error和Exception。Error表示系统级错误，通常由JVM汇报，包括：虚拟机错误、内存溢出、线程死锁等，开发者在编码阶段无需处理此类错误，因为它们出现之后当前程序甚至整个系统可能崩溃，需要重启系统、扩充物理内存或调整代码逻辑才能解决。Exception则表示用户态错误，包括：网络不可用、磁盘已满、用户输入参数错误等，此类错误仅影响程序正在执行的语句，开发者可以提醒用户解决问题后重试。

Kotlin中常见的异常如下文表格所示：

<div align="center">

|            异常类名            |       含义       |                             示例                              |
| :----------------------------: | :--------------: | :-----------------------------------------------------------: |
|      NullPointerException      |    空指针异常    |          `val text: String? = null; text!!.length;`           |
|       ClassCastException       |   类型转换异常   |                    `Any a = "A"; (Int) a;`                    |
| ArrayIndexOutOfBoundsException | 数组下标越界异常 | `val array = intArrayOf(0, 1, 2); val item: Int = array[10];` |
|      ArithmeticException       |     算术异常     |            `val a = 10; val b = 0; val z = a / b`             |
|          IOException           |     I/O异常      |                    写入数据时目标磁盘已满                     |
|          SQLException          |     SQL异常      |                          SQL语法错误                          |

</div>


# 捕获异常





# 自定义异常
当我们编写业务代码时，如果系统内置异常的语义能够满足要求，可以直接使用它们；如果内置异常无法满足要求，我们则需要自定义新的异常。

异常以类的形式存在，自定义异常需要继承系统中已有的异常类，我们通常继承Exception类，并按需添加其他属性与方法。

🟤 示例七：定义并使用自定义异常。

在本示例中，我们创建一个自定义异常类，在测试方法中抛出并捕获该异常。

第一步，我们创建CustomException类，它就是自定义异常类，拥有错误码属性。

"CustomException.kt":

```kotlin
class CustomException(

    // 错误码
    private val code: Int,

    // 错误信息
    info: String
) : Exception(info) {

    // 获取错误码
    fun getCode(): Int {
        return code
    }
}
```

第二步，我们在 `raiseException()` 方法中抛出CustomException，并设置错误码为 `100` ，消息为“自定义异常”，然后以 `main()` 方法模拟调用者，捕获异常并向控制台输出异常信息。

"TestException.kt":

```kotlin
fun main() {
    try {
        raiseException()
    } catch (e: CustomException) {
        println("遇到异常：${e.message}")
        println("错误码：${e.getCode()}")
    }
}

fun raiseException() {
    throw CustomException(100, "自定义异常")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
遇到异常：自定义异常
错误码：100
```


# 异常链
我们在编写库或者中间件时，可能需要将底层发生的异常转换为另一种异常，向调用者描述更加详细的原因，同时保留原始异常信息以便调用者进行分析。例如：在加载图片时，系统汇报文件未找到异常，我们可以将该异常包装在自定义异常中，添加状态码和图片路径，以便上层进一步处理。

将原始异常封装在另一个异常中再抛出的功能，被称为“异常链”，这是一种面向对象的编程方法。

🔴 示例八：异常链的基本应用。

在本示例中，我们故意制造一个算术异常，并将其捕获后转为前文“示例七”中的CustomException，再向调用者抛出。

"TestException.kt":

```kotlin
fun main() {
    try {
        convertException()
    } catch (e: Exception) {
        e.printStackTrace()
    }
}

fun convertException() {
    try {
        10 / 0
    } catch (ae: ArithmeticException) {
        println("捕获算术异常，将其转换为自定义异常再向上层抛出。")
        val customException = CustomException(100, "自定义异常")
        // 使用 `initCause()` 方法指明引起CustomException的原始异常
        customException.initCause(ae)
        // 抛出新建的CustomException
        throw customException
    }
}
```

此处的 `convertException()` 方法实现了异常转换，它会抛出CustomException异常，我们以 `main()` 方法模拟调用者，捕获异常并向控制台输出异常信息。

在 `convertException()` 方法中，我们使用CustomException对象的 `initCause()` 方法设置原始异常信息，随后将其抛出给调用者。

此时运行示例程序，并查看控制台输出信息：

```text
捕获算术异常，将其转换为自定义异常再向上层抛出。
net.bi4vmr.study.exception.CustomException: 自定义异常
	at net.bi4vmr.study.TestExceptionKt.convertException(TestException.kt:71)
	at net.bi4vmr.study.TestExceptionKt.main(TestException.kt:13)
	at net.bi4vmr.study.TestExceptionKt.main(TestException.kt)
Caused by: java.lang.ArithmeticException: / by zero
	at net.bi4vmr.study.TestExceptionKt.convertException(TestException.kt:68)
	... 2 more
```

根据上述输出内容可知：

堆栈信息中的 `Caused by:` 部分即表示引起该异常的原始异常信息。
