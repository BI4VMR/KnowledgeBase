# Java - 基本语法 - 方法

# 可变参数
<!-- TODO -->



# 回调方法
<!-- TODO -->


---

# Java - 高级特性 - 泛型

# 简介











```text
class <类名><泛型占位符I，泛型占位符II，...>{

}

```





Object类可以表示任何实例，但这样并不安全，使用时需要增加很多类型判断，所以引入了泛型。

泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。

什么是泛型？为什么要使用泛型？
复制代码

泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？

顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），

然后在使用/调用时传入具体的类型（类型实参）。

泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，

操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。



在下文示例中，我们定义了一个类用于表示二维平面上的坐标，坐标可以支持整数、小数、文本等多种格式。

首先，我们尝试在不使用泛型特性的情况下实现该类。

"Location1.java":

```java
public class Location1 {

    private Object x, y;

    // 构造实例并设置坐标
    public Location1(Object x, Object y) {
        this.x = x;
        this.y = y;
    }

    // 获取坐标(X)
    public Object getX() {
        return x;
    }

    // 获取坐标(Y)
    public Object getY() {
        return y;
    }
}
```

由于每个变量只能被声明为一个类型，若定义为Integer就无法传入文本，若定义为String则无法传入数字，因此我们只能将坐标的数据类型定义为所有类的顶级父类Object。

在测试方法中，我们创建一个Location1实例，然后调用获取坐标的 `getX()` 和 `getY()` 方法，读取坐标值并比较其是否与指定的值相等。

"TestBase.java":

```java
// 使用数字类型数据创建实例
Location1 i1 = new Location1();
i1.setXY(100, 25.1082);

// 读取数据时需要判断具体的类型
Object xRaw = i1.getX();
if (xRaw instanceof Integer) {
    // 将数据转换为具体类型再操作
    boolean resultX = ((Integer) xRaw).compareTo(100) == 0;
    System.out.println("x = 100? " + resultX);
} else if (xRaw instanceof Double) {
    boolean resultX = ((Double) xRaw).compareTo(100.0) == 0;
    System.out.println("x = 100? " + resultX);
} else {
    throw new IllegalArgumentException("参数类型错误！");
}
// 比较Y轴的数据时也需要判断类型，此处省略相关代码。
```

由于坐标的数据类型为Object，我们首先需要判断其具体类型，然后才能进行比较操作，并且在数据类型不合法时抛出异常。

上述示例代码中的判断逻辑非常繁琐，降低了程序的可维护性；并且调用者在构造Location1实例时可以传入任何类型的数据，需要到程序运行阶段才会发现错误，降低了程序的稳定性：

"TestBase.java":

```java
// 创建实例时随便传入非法数据也不会出错，只在读取数据时才能发现错误。
Location1 i2 = new Location1(TestBase.class, Thread.currentThread());
```

# 基本应用
我们可以使用泛型来表示坐标值的类型，使得调用者自行决定需要使用何种数据类型，以解决前文示例中的部分问题。

"Location2.java":

```java
public class Location2<T1, T2> {

    // 变量"x"和"y"的类型由外部调用者决定
    private T1 x;
    private T2 y;

    // 构造实例并设置坐标
    public Location2(T1 x, T2 y) {
        this.x = x;
        this.y = y;
    }

    // 获取坐标(X)
    public T1 getX() {
        return x;
    }

    // 获取坐标(Y)
    public T2 getY() {
        return y;
    }
}
```

上述示例代码中的坐标变量 `x` 和 `y` 类型为两个泛型类型，而不是某种具体的数据类型，此时构造方法的参数与获取坐标方法的返回值也被设为对应的泛型类型，不再是宽泛的Object类型。

在测试方法中，我们创建一个Location2实例，然后调用获取坐标的 `getX()` 和 `getY()` 方法，读取坐标值并比较其是否与指定的值相等。

"TestBase.java":

```java
// 使用数字类型数据创建实例
Location2<Integer, Double> i1 = new Location2<>(100, 25.1082);

// 读取数据时无需判断类型，与创建实例时的类型一致。
Integer x = i1.getX();
boolean resultX = x.compareTo(100) == 0;
System.out.println("x = 100? " + resultX);
// 比较Y轴的数据时无需判断类型，此处省略相关代码。
```

当我们构建Location2实例时，已经在类名后的尖括号内指明了两个方向坐标变量的数据类型，因此 `getX()` 与 `getY()` 方法也会返回对应类型的数据，无需再进行类型判断。

此时如果我们创建一个Location2实例，并传入一些类型与泛型不一致的数据，编译时编译器将会提示数据类型不匹配，使我们提早发现错误。

"TestBase.java":

```java
// 构造方法参数与声明实例时的泛型类型不一致，编译时将会报错。
Location2<Integer, Double> i2 = new Location2<>(TestBase.class, Thread.currentThread());
```






---

# Java - 高级特性 - 注解

<!-- TODO -->

---

# Java - 高级特性 - 反射

# 简介


Java反射（Reflection）机制允许程序在运行时动态地访问、检查和修改类或对象的信息。这一特性为Java程序提供了更强的灵活性和扩展性。Java反射的主要作用包括：


动态类加载：可以在程序运行时动态地加载类，而不需要在编译时就确定所有使用的类。这使得应用程序能够根据需求加载不同类，提高灵活性。

获取类的信息：反射可以用来获取类的名称、修饰符、包信息、父类、实现的接口、构造方法、方法和字段等元数据信息。这对于编写需要分析或操作类结构的工具或框架非常有用。

创建和操作对象：即使不知道类名，也可以在运行时创建对象实例，调用其构造函数，并为对象的属性赋值。这对于实现插件系统、工厂模式等设计模式特别有帮助。

调用方法：可以动态地调用对象的方法，包括私有方法，只需知道方法的名称和参数类型。这对于编写需要执行未知行为的代码（如脚本引擎）非常有用。

访问和修改字段值：能够访问和修改对象的字段值，包括私有字段，只要知道字段名称。这对于进行对象状态的检查和修改，或者实现序列化/反序列化等功能很有帮助。

实现泛型编程：虽然Java的泛型在编译后会进行类型擦除，但通过反射可以在运行时获取到实际的类型信息，从而实现更灵活的泛型处理。


反射的作用

第一种是调用隐藏接口，例如Android SDK中存在一些不对应用程序开放的接口，有时应用需要实现某种功能，我们就可以通过反射调用这些隐藏接口。

第二种是用于开发框架，框架只定义了接口，无法提前预知框架使用者的具体实现，因此需要通过反射扫描类种的接口、方法与注解信息，调用接口的实现类或自动生成实现类。例如JDBC，数据库驱动有很多种，JDK内部只定义了JDBC接口，需要通过反射来加载具体的实现类。

尽管反射功能强大，但也需要注意它可能带来的性能开销以及对封装性的破坏，因此在不必要时应谨慎使用。


---

# Java - 并发与多任务 - 线程间的同步

# 同步锁
为了解决前文所示的竞态条件问题，我们可以引入一种线程之间的协调机制：当任意一个“购买商品”任务开始后，其中的三个操作必须连续执行完毕，在此期间其他的“购买商品”任务都将暂停，防止它们修改共享变量导致出错；当前一个任务完成后再执行后一个任务，以此类推直到商品卖完。这种协调机制被称为“同步”，能够将线程的随机执行限制为顺序执行。

<!-- 对于一个代码一把同步锁，当多个调用者调用同步代码片段时，最先抢到同步锁的调用者可以执行，其他调用者只能等待，

后文将介绍Java中实现同步的相关工具。 -->

# 同步代码块
同步代码块是一种自动锁定工具，它的语法为：

```text
synchronized (Object o) {
    // 需要同步的代码片段...
}
```

<!-- 当第一个任务进入该代码块时自动

假设线程A与线程B都需要执行该代码块，并且锁对象Object是全局唯一的。
线程A首先进入同步代码块，并获取到同步锁；此时线程B也执行至此，因为锁对象全局唯一并已被线程A持有，所以进入同步等待状态；后续线程A执行完同步代码块中的所有语句，随即释放同步锁；接着线程B获取到同步锁，从阻塞状态恢复并执行同步代码块中的内容。如此一来，线程A与线程B就变为串行操作，实现了。 -->

我们对前文示例中的BuyThread类进行修改，将需要连续执行的三个动作放入同步代码块中。

BuyThread2.java:

```java
@Override
public void run() {
    while (true) {
        // 加锁，确保当前线程的一次循环执行完毕后，再进行下一次操作。
        synchronized (BuyThread2.class) {
            // 判断如果商品仍有存货，则进行购买。（动作一）
            if (count > 0) {
                // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
                count--;
                // 输出日志（动作三）
                String thName = Thread.currentThread().getName();
                System.out.println(thName + ": Buy good with index: " + (count + 1));
            } else {
                break;
            }
        }
    }
}
```

此处使用的同步对象是"BuyThread2.class"，由于JVM中每个Class都是唯一的，因此同步锁也是全局唯一的，同一时刻只有一个线程可以获取同步锁并执行代码块中的内容，实现了同步机制。

运行程序并查看控制台输出：

```text
客户1: Buy good with index: 10
客户1: Buy good with index: 9
客户1: Buy good with index: 8
客户1: Buy good with index: 7
客户1: Buy good with index: 6
客户1: Buy good with index: 5
客户1: Buy good with index: 4
客户1: Buy good with index: 3
客户1: Buy good with index: 2
客户1: Buy good with index: 1
```

由上述日志输出可知，实现同步机制后重复购买与超出范围问题都未出现，符合逻辑。

此处所有的商品均被客户1买到，是因为CPU性能较高，一个时间片内10次循环都已执行完毕，如果我们希望模拟多个客户交替购买的情况，可以增大商品总数再进行测试。

# 同步方法
<!-- synchronized方法




非静态 -> 调用者
静态 -> 当前Class对象 -->

BuyThread3.java:

```java
public class BuyThread3 extends Thread {

    // 静态全局变量，表示商品的剩余数量，初始为10件。
    static int count = 10;

    @Override
    public void run() {
        while (true) {
            boolean hasNext = buy();
            // 若无剩余商品，则退出循环。
            if (!hasNext) {
                break;
            }
        }
    }

    /**
     * 购买商品
     *
     * @return 是否还有剩余商品
     */
    private static synchronized boolean buy() {
        // 判断如果商品仍有存货，则进行购买。（动作一）
        if (count > 0) {
            // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
            count--;
            // 输出日志（动作三）
            String thName = Thread.currentThread().getName();
            System.out.println(thName + ": Buy good with index: " + (count + 1));
        } else {
            // 没有剩余商品，返回"false"。
            return false;
        }
        return true;
    }
}
```

---

# 手动同步锁

<!-- TODO -->

---

# Java - 并发与多任务 - Executor

# 简介





线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。


JDK提供的Executor框架

JDK提供了Executor框架，可以让我们有效的管理和控制我们的线程，其实质也就是一个线程池。Executor下的接口和类继承关系如下：


2. 线程池的工作机制

         2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。

         2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。
线程重用的核心是，我们知道，Thread.start()只能调用一次，一旦这个调用结束，则该线程就到了stop状态，不能再次调用start。
则要达到复用的目的，则必须从Runnable接口的run()方法上入手，可以这样设计这个Runnable.run()方法（就叫外面的run()方法）：
它本质上是个无限循环，跑的过程中不断检查我们是否有新加入的子Runnable对象（就叫内部的runnable:run()吧，它就是用来实现我们自己的任务），有就调一下我们的run()，其实就一个大run()把其它小run()#1,run()#2,...给串联起来了，基本原理就这么简单
不停地处理我们提交的Runnable任务。
3. 使用线程池的好处

　Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处：

　　第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

　　第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

　　第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。



Executors：提供了一系列静态工厂方法用于创建各种线程池

　其中常用几类如下：

public static ExecutorService newFixedThreadPool()
public static ExecutorService newSingleThreadExecutor()
public static ExecutorService newCachedThreadPool()
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
public static ScheduledExecutorService newScheduledThreadPool()



🔷 `ExecutorService newSingleThreadExecutor()`

创建具有单个线程的线程池。

前一个任务执行完毕才能执行后一个任务，此时与Timer类似。

🔷 `ExecutorService newFixedThreadPool(int nThreads)`

创建具有 `nThreads` 个线程的线程池。

🔷 `ExecutorService newCachedThreadPool()`

缓存，动态扩容，1分钟后关闭线程

🔷 `ExecutorService newSingleThreadScheduledExecutor()`

　　4、newSingleThreadScheduledExecutor：该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能，可以进行定时执行等；

🔷 `ExecutorService newScheduledThreadPool(int nThreads)`

　　5、newScheduledThreadPool：在4的基础上可以指定线程数量。




`ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)`

1、corePoolSize 核心线程池大小；
2、maximumPoolSize 线程池最大容量大小；
3、keepAliveTime 线程池空闲时，线程存活的时间；
4、TimeUnit 时间单位；
5、ThreadFactory 线程工厂；
6、BlockingQueue任务队列；
7、RejectedExecutionHandler 线程拒绝策略；





execute和submit的区别

（1）execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。

（2）submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。






---

# Kotlin - 高级特性 - 任务管理 - 协程 - 任务调度

# 任务调度
## 并发执行任务

<!-- TODO -->


---

# Kotlin - 高级特性 - 任务管理 - 协程 - 上下文

# 上下文
## 调度器
为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测，我们通常不使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。


# 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。


不用小明思考了，我们直接开撸源码。协程使用过程中除了launch/asyc/runBlocking/delay 之外，想必还有一个函数比较熟悉：withContext。
刚接触时大家都使用它来切换线程用以执行新的协程(子协程)，而原来的协程(父协程)则被挂起。当子协程执行完毕后将会恢复父协程的运行。


---

# Kotlin - 高级特性 - 任务管理 - 协程 - 与线程交互

# 简介
部分功能模块并不支持协程，它们只提供了接口回调风格的API，如果我们直接在协程代码中使用这些接口，就会增加嵌套层级、降低代码的可维护性。

对于接口回调风格的API，我们可以使用 `suspendCoroutine()` 等工具将其转换为挂起函数，以便在协程代码中调用，减少嵌套层级并统一编码风格。

# 回调风格API
下文示例代码展示了一个网络回调接口示例：

"TestWorkWithThread.kt":

```kotlin
// 网络请求回调接口
interface NetCallback {

    // 请求成功
    fun onSuccess(data: String)

    // 请求失败
    fun onFailure(message: String)
}

/**
 * 模拟网络请求。
 *
 * @param[result] 控制请求结果。
 * @param[callback] 结果回调。
 */
fun request(result: Boolean, callback: NetCallback) {
    // 开启新线程进行网络请求
    thread {
        // 线程休眠，模拟网络延时。
        Thread.sleep(3000L)
        // 休眠结束，调用回调方法反馈执行结果。
        if (result) {
            callback.onSuccess("200 - OK.")
        } else {
            callback.onFailure("502 - Bad Gateway.")
        }
    }
}
```

NetCallback接口定义了两个方法，其中 `onSuccess()` 方法在请求成功时触发，参数为服务端返回的数据； `onFailure()` 方法则在请求失败时触发，参数为错误信息。

`request()` 方法用于模拟网络请求，其中开启了一个线程，休眠3秒以模拟网络耗时，休眠结束后根据参数 `result` 的值调用NetCallback实例的方法，向调用者反馈请求结果。

接口定义完毕后，调用者需要传入NetCallback实现类的实例，并在结果返回时执行对应的操作，例如更新界面等；此处我们只是简单的将回调结果输出到控制台上。

"TestWorkWithThread.kt":

```kotlin
println("Mock request start. Time:[${getTime()}]")
request(true, object : NetCallback {
    override fun onSuccess(data: String) {
        println("OnSuccess. Time:[${getTime()}] Data:[$data]")
    }

    override fun onFailure(message: String) {
        println("OnFailure. Time:[${getTime()}] Info:[$message]")
    }
})
```

此时运行示例程序，并查看控制台输出信息：

```text
Mock request start. Time:[23:18:09.453]
OnSuccess. Time:[23:18:12.481] Data:[200 - OK.]
```

根据上述输出内容可知：

`request()` 方法被调用3秒后，NetCallback实例的 `onSuccess()` 方法被触发，控制台上输出了请求结果。

# "suspendCoroutine()"方法
`suspendCoroutine()` 方法是一种可以手动控制协程任务暂停与恢复的工具，我们可以用它将前文的回调风格接口 `request()` 转换为挂起函数。

"TestWorkWithThread.kt":

```kotlin
// 模拟网络请求（挂起函数实现）。
private suspend fun requestSuspend(result: Boolean): String {
    return suspendCoroutine {
        request(result, object : NetCallback {
            override fun onSuccess(data: String) {
                // 请求成功，解除挂起状态并返回数据。
                it.resume(data)
            }

            override fun onFailure(message: String) {
                // 请求失败，抛出异常。
                val exception = Exception(message)
                it.resumeWithException(exception)
            }
        })
    }
}
```

<!-- TODO
当协程任务运行至 `suspendCoroutine()` 方法时，将会进入挂起状态，随后调度器开始执行 `suspendCoroutine()` 方法内部的代码。当模拟网络请求回调请求成功的结果时，我们
-->

接下来，我们就可以在协程任务中调用 `requestSuspend()` 挂起函数，以协程的方式使用接口回调API。

"TestWorkWithThread.kt":

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    println("Mock request start. Time:[${getTime()}]")
    // 声明变量以便接收请求成功的结果
    val data = requestSuspend(true)
    println("Request success. Time:[${getTime()}] Data:[$data]")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Mock request start. Time:[21:18:09.453]
OnSuccess. Time:[21:18:12.481] Data:[200 - OK.]
```

根据上述输出内容可知：

模拟网络请求开始3秒后，触发了 `onSuccess()` 回调方法及其中的 `it.resume()` 方法，向调用者返回请求结果。

<!-- TODO 请求失败的处理 -->

"TestWorkWithThread.kt":

```kotlin
CoroutineScope(Dispatchers.IO).launch {
    try {
        println("Mock request start. Time:[${getTime()}]")
        // 模拟请求失败的情况
        val data = requestSuspend(false)
        println("Request success. Time:[${getTime()}] Data:[$data]")
    } catch (e: Exception) {
        // 捕获异常以获取失败详情
        println("Request failure. Info:[${e.message}]")
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Mock request start. Time:[21:22:02.464]
Request failure. Time:[21:22:05.580] Info:[502 - Bad Gateway.]
```

根据上述输出内容可知：

模拟网络请求开始3秒后，触发了 `onFailure()` 回调方法及其中的 `it.resumeWithException()` 方法，向调用者抛出异常信息；随后调用 `requestSuspend()` 方法的协程任务捕获了异常信息，并且能够通过Exception实例获取异常详情。

<!-- TODO
当我们使用 suspendCoroutine 或者 suspendCancellableCoroutine 的时候，我们都知道使用 resume() 能够返回值，那问题来了，我们调用 resume() 之后，后续的代码会被执行吗？若多次调用 resume() 又会怎么样？
废话不多说，来个实验就行：
由此，我们可以得出几个结论：

调用 resume() 之后，后续代码还会继续执行。
第二次调用 resume() 后，后续代码不会被执行，并且会抛出异常，这一点，suspendCoroutine 和 suspendCancellableCoroutine 都是一样的。
-->

# "suspendCancellableCoroutine()"方法
<!-- TODO -->


# "runBlocking()"方法
`runBlocking()` 方法的功能与CoroutineScope的 `launch()` 和 `async()` 方法类似，都可以提供协程环境并开启协程任务，但 `launch()` 和 `async()` 方法属于CoroutineScope实例，且不会阻塞调用者线程； `runBlocking()` 方法则可以全局调用，不需要CoroutineScope实例，并且会阻塞调用者线程，直到协程任务运行完毕。

该方法的主要用途是将协程API转换为接口回调API，以便在不支持协程的模块中使用，或者在 `main()` 方法中测试协程API。

我们可以使用 `runBlocking()` 方法再将前文示例中模拟网络请求的挂起函数转换为接口回调形式：

"TestWorkWithThread.kt":

```kotlin
// 模拟网络请求（协程转接口回调）。
fun requestCallback(result: Boolean, callback: NetCallback) {
    // 在新线程进行网络请求
    thread {
        // 开启协程任务并阻塞当前线程
        runBlocking {
            try {
                val data: String = requestSuspend(result)
                // 获取到结果后，通过回调方法通知调用者。
                callback.onSuccess(data)
            } catch (e: Exception) {
                callback.onFailure(e.message ?: "")
            }
        }
    }
}

// 测试方法
fun main() {
    println("Mock request start. Time:[${getTime()}]")
    requestCallback(true, object : NetCallback {
        override fun onSuccess(data: String) {
            println("OnSuccess. Time:[${getTime()}] Data:[$data]")
        }

        override fun onFailure(message: String) {
            println("OnFailure. Time:[${getTime()}] Info:[$message]")
        }
    })
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Mock request start. Time:[14:36:08.621]
OnSuccess. Time:[14:36:11.672] Data:[200 - OK.]
```

---

# Java - 高级特性 - 外部交互 - 命令行

# 返回值

如果 `main()` 方法正常运行完毕，JVM将会向系统发送进程状态码"0"；如果其在运行过程中发生错误，导致进程异常终止，JVM将会向系统发送进程状态码"1"。

Linux系统中的环境变量 `$?` 即代表前一个任务的返回值，我们在Shell中运行以上代码，并查看返回值：

```text
# 编译并运行示例程序
[root@Fedora ~]$ java FirstDemo.java
Hello World!

# 读取上一个进程的状态码
[root@Fedora ~]$ echo "$?"
0
```

除了正常顺序运行的逻辑外，我们还可以根据需要，在代码中的任意位置调用 `System.exit(int code)` 方法终止主进程，并配置自定义的状态码"code"。



---

# Kotlin - 变量 - 外部交互 - 命令行

    const val 可见性为public final static，可以直接访问。
    val 可见性为private final static，并且val 会生成方法getNormalObject()，通过方法调用访问。

总结：

当定义常量时，出于效率考虑，我们应该使用const val方式，避免频繁函数调用。
