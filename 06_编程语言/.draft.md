> Java-线程间的同步

# 同步锁
为了解决前文的竞态条件问题，我们可以引入一种线程之间的协调机制：当任意一个“购买商品”任务开始后，其中的三个操作必须连续执行完毕，在此期间其他的“购买商品”任务都将暂停，防止它们修改共享变量导致出错；当前一个任务完成后再执行后一个任务，以此类推直到商品卖完。

这种协调机制被称为“同步”，能够将线程的随机执行限制为顺序执行。

<!-- 对于一个代码一把同步锁，当多个调用者调用同步代码片段时，最先抢到同步锁的调用者可以执行，其他调用者只能等待，

后文将介绍Java中实现同步的相关工具。 -->

# 同步代码块
同步代码块是一种自动锁定工具，它的语法为：

```text
synchronized (Object o) {
    // 需要同步的代码片段...
}
```

<!-- 当第一个任务进入该代码块时自动

假设线程A与线程B都需要执行该代码块，并且锁对象Object是全局唯一的。
线程A首先进入同步代码块，并获取到同步锁；此时线程B也执行至此，因为锁对象全局唯一并已被线程A持有，所以进入同步等待状态；后续线程A执行完同步代码块中的所有语句，随即释放同步锁；接着线程B获取到同步锁，从阻塞状态恢复并执行同步代码块中的内容。如此一来，线程A与线程B就变为串行操作，实现了。 -->

我们对前文示例中的BuyThread类进行修改，将需要连续执行的三个动作放入同步代码块中。

BuyThread2.java:

```java
@Override
public void run() {
    while (true) {
        // 加锁，确保当前线程的一次循环执行完毕后，再进行下一次操作。
        synchronized (BuyThread2.class) {
            // 判断如果商品仍有存货，则进行购买。（动作一）
            if (count > 0) {
                // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
                count--;
                // 输出日志（动作三）
                String thName = Thread.currentThread().getName();
                System.out.println(thName + ": Buy good with index: " + (count + 1));
            } else {
                break;
            }
        }
    }
}
```

此处使用的同步对象是"BuyThread2.class"，由于JVM中每个Class都是唯一的，因此同步锁也是全局唯一的，同一时刻只有一个线程可以获取同步锁并执行代码块中的内容，实现了同步机制。

运行程序并查看控制台输出：

```text
客户1: Buy good with index: 10
客户1: Buy good with index: 9
客户1: Buy good with index: 8
客户1: Buy good with index: 7
客户1: Buy good with index: 6
客户1: Buy good with index: 5
客户1: Buy good with index: 4
客户1: Buy good with index: 3
客户1: Buy good with index: 2
客户1: Buy good with index: 1
```

由上述日志输出可知，实现同步机制后重复购买与超出范围问题都未出现，符合逻辑。

此处所有的商品均被客户1买到，是因为CPU性能较高，一个时间片内10次循环都已执行完毕，如果我们希望模拟多个客户交替购买的情况，可以增大商品总数再进行测试。

# 同步方法
<!-- synchronized方法




非静态 -> 调用者
静态 -> 当前Class对象 -->

BuyThread3.java:

```java
public class BuyThread3 extends Thread {

    // 静态全局变量，表示商品的剩余数量，初始为10件。
    static int count = 10;

    @Override
    public void run() {
        while (true) {
            boolean hasNext = buy();
            // 若无剩余商品，则退出循环。
            if (!hasNext) {
                break;
            }
        }
    }

    /**
     * 购买商品
     *
     * @return 是否还有剩余商品
     */
    private static synchronized boolean buy() {
        // 判断如果商品仍有存货，则进行购买。（动作一）
        if (count > 0) {
            // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
            count--;
            // 输出日志（动作三）
            String thName = Thread.currentThread().getName();
            System.out.println(thName + ": Buy good with index: " + (count + 1));
        } else {
            // 没有剩余商品，返回"false"。
            return false;
        }
        return true;
    }
}
```


# 手动同步锁
<!-- TODO -->








---

> Java - 高级特性 - 外部交互 - 命令行

<!-- TODO -->



---

> Java - 并发 - Timer

# 简介
Timer是JDK内置的定时任务工具，可以在特定时刻或以固定间隔循环执行任务。

每个Timer实例将会与一个线程关联，用于执行TimerTask。Timer的队列可以被添加多个计划任务，但TimerTask实例不可复用，如果我们重复将其添加到Timer队列中，则会出现异常：IllegalStateException(Task already scheduled or cancelled)。

# 基本应用
Timer的任务使用TimerTask承载，该类是Runnable接口的实现类，我们首先需要创建自定义类继承自TimerTask类，并实现 `run()` 方法。

"TestTimer.java":

```java
TimerTask timerTask = new TimerTask() {
    @Override
    public void run() {
        System.out.println("Exec Time: " + LocalDateTime.now());
    }
};
```

此处我们在任务中简单的输出任务执行的时刻信息。

接着我们创建Timer实例，并通过下文内容所示的系列方法设置任务。

🔷 `void schedule(TimerTask task, long delay)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` 。

🔷 `void schedule(TimerTask task, long delay, long period)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void schedule(TimerTask task, Date time)`

在 `time` 时刻执行任务 `task` 。

🔷 `void schedule(TimerTask task, Date firstTime, long period)`

在 `firstTime` 时刻执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void scheduleAtFixedRate(TimerTask task, long delay, long period)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`

在 `firstTime` 时刻执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

<br />

上述方法被调用后任务即刻开始计时，下文代码块给出了一些示例。

"TestTimer.java":

```java
// 创建Timer实例
Timer timer = new Timer();

// 以当前时刻为参考点，在1000毫秒之后执行任务TimerTask。
timer.schedule(timerTask, 1000L);

// 以当前时刻为参考点，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
timer.schedule(timerTask, 1000L, 1000L);

// 在”当前时刻+3秒“执行任务TimerTask。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.schedule(timerTask, date);

// 在”当前时刻+3秒“执行任务TimerTask，且每隔1秒重复执行一次。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.schedule(timerTask, date, 1000L);

// 以当前时刻为参考点，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
timer.scheduleAtFixedRate(timerTask, 1000L, 1000L);

// 在”当前时刻+3秒“执行任务TimerTask，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.scheduleAtFixedRate(timerTask, date, 1000L);
```

# 终止任务

方法cancel会取消所有等待执行的Task，并且关联的Thread会被释放，这也很好理解。

可是看到Timer还提供了purge这个方法，注释是“从task queue里移除所有标记为canceled的task”。这里就有点糊涂了，既然cancel已经有这个功能了，为什么还要多此一举提供purge？

原来TimerTask也有cancel方法，对比Timer的cancel方法，TimerTask的cancel杀伤力没那么大，一次只取消一个Task。那么问题来了：如何释放对TimerTask的引用呢？不然会有内存泄漏。

purge方法就是用来释放内存引用的。purge方法会检查timer队列里标记为canceled的task，将对它的引用置为null。如此说来，purge方法的作用很不小呢？


# schedule与scheduleAtFixedRate

Ps1：​schedule：下次开始执行的时间以上次run方法完成时间为基准。

Ps2：scheduleAtFixedRate：下次开始执行的时间以上次run方法开始时间为基准。


（1）schedule方法：下一次执行时间相对于 上一次 实际执行完成的时间点 ，因此执行时间会不断延后
（2）scheduleAtFixedRate方法：下一次执行时间相对于上一次开始的 时间点 ，因此执行时间不会延后，存在并发性 

timer.scheduleAtFixedRate(new TestTimerTask(),1000,1000);是时钟周期（开始执行，按照上一次执行时间加一个周期（period）来执行，
即使任务阻塞也同样执行）；timer.schedule(new TestTimerTask(),2000,1000)是按当前时间加一个周期执行，如果上一个任务被阻塞，
那么当前时间就会被延迟，同样下个任务就会被延迟



"TestTimer.java":

```java
// 获取当前时间
Date date = new Date();
System.out.println("Reference Time: " + date);

// 阻塞当前线程3秒，不处理任何任务。
try {
    Thread.sleep(3000L);
} catch (InterruptedException e) {
    e.printStackTrace();
}

// 创建Timer并开启任务，参考时间点设置为3秒前。
Timer timer = new Timer();
timer.schedule(timerTask, date, 1000L);
```



```text
Reference Time: Fri Apr 12 00:12:48 CST 2024
Time: 00:12:51.821756300
Time: 00:12:52.824136400
Time: 00:12:53.826305200
Time: 00:12:54.827819500
Time: 00:12:55.829219400
Time: 00:12:56.831259500
```



```text
Reference Time: Fri Apr 12 00:13:16 CST 2024
Time: 00:13:19.133863300
Time: 00:13:19.133863300
Time: 00:13:19.133863300
Time: 00:13:19.133863300
Time: 00:13:20.098573800
Time: 00:13:21.100862
Time: 00:13:22.103028900
Time: 00:13:23.089317400
```
