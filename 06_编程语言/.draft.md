# Java - 基本语法 - 方法

# 可变参数
<!-- TODO -->



# 回调方法
<!-- TODO -->


---

# Java - 高级特性 - 注解

<!-- TODO -->

---

# Java - 高级特性 - 反射

<!-- TODO -->

---

# Java - 高级特性 - 泛型

<!-- TODO -->

---

# Java - 并发与多任务 - 线程间的同步

# 同步锁
为了解决前文所示的竞态条件问题，我们可以引入一种线程之间的协调机制：当任意一个“购买商品”任务开始后，其中的三个操作必须连续执行完毕，在此期间其他的“购买商品”任务都将暂停，防止它们修改共享变量导致出错；当前一个任务完成后再执行后一个任务，以此类推直到商品卖完。这种协调机制被称为“同步”，能够将线程的随机执行限制为顺序执行。

<!-- 对于一个代码一把同步锁，当多个调用者调用同步代码片段时，最先抢到同步锁的调用者可以执行，其他调用者只能等待，

后文将介绍Java中实现同步的相关工具。 -->

# 同步代码块
同步代码块是一种自动锁定工具，它的语法为：

```text
synchronized (Object o) {
    // 需要同步的代码片段...
}
```

<!-- 当第一个任务进入该代码块时自动

假设线程A与线程B都需要执行该代码块，并且锁对象Object是全局唯一的。
线程A首先进入同步代码块，并获取到同步锁；此时线程B也执行至此，因为锁对象全局唯一并已被线程A持有，所以进入同步等待状态；后续线程A执行完同步代码块中的所有语句，随即释放同步锁；接着线程B获取到同步锁，从阻塞状态恢复并执行同步代码块中的内容。如此一来，线程A与线程B就变为串行操作，实现了。 -->

我们对前文示例中的BuyThread类进行修改，将需要连续执行的三个动作放入同步代码块中。

BuyThread2.java:

```java
@Override
public void run() {
    while (true) {
        // 加锁，确保当前线程的一次循环执行完毕后，再进行下一次操作。
        synchronized (BuyThread2.class) {
            // 判断如果商品仍有存货，则进行购买。（动作一）
            if (count > 0) {
                // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
                count--;
                // 输出日志（动作三）
                String thName = Thread.currentThread().getName();
                System.out.println(thName + ": Buy good with index: " + (count + 1));
            } else {
                break;
            }
        }
    }
}
```

此处使用的同步对象是"BuyThread2.class"，由于JVM中每个Class都是唯一的，因此同步锁也是全局唯一的，同一时刻只有一个线程可以获取同步锁并执行代码块中的内容，实现了同步机制。

运行程序并查看控制台输出：

```text
客户1: Buy good with index: 10
客户1: Buy good with index: 9
客户1: Buy good with index: 8
客户1: Buy good with index: 7
客户1: Buy good with index: 6
客户1: Buy good with index: 5
客户1: Buy good with index: 4
客户1: Buy good with index: 3
客户1: Buy good with index: 2
客户1: Buy good with index: 1
```

由上述日志输出可知，实现同步机制后重复购买与超出范围问题都未出现，符合逻辑。

此处所有的商品均被客户1买到，是因为CPU性能较高，一个时间片内10次循环都已执行完毕，如果我们希望模拟多个客户交替购买的情况，可以增大商品总数再进行测试。

# 同步方法
<!-- synchronized方法




非静态 -> 调用者
静态 -> 当前Class对象 -->

BuyThread3.java:

```java
public class BuyThread3 extends Thread {

    // 静态全局变量，表示商品的剩余数量，初始为10件。
    static int count = 10;

    @Override
    public void run() {
        while (true) {
            boolean hasNext = buy();
            // 若无剩余商品，则退出循环。
            if (!hasNext) {
                break;
            }
        }
    }

    /**
     * 购买商品
     *
     * @return 是否还有剩余商品
     */
    private static synchronized boolean buy() {
        // 判断如果商品仍有存货，则进行购买。（动作一）
        if (count > 0) {
            // 商品剩余数量-1，模拟该商品已被当前线程持有。（动作二）
            count--;
            // 输出日志（动作三）
            String thName = Thread.currentThread().getName();
            System.out.println(thName + ": Buy good with index: " + (count + 1));
        } else {
            // 没有剩余商品，返回"false"。
            return false;
        }
        return true;
    }
}
```

---

# 手动同步锁

<!-- TODO -->

---

# Java - 并发与多任务 - Timer

# 简介
Timer是JDK内置的定时任务工具，可以在特定时刻或以固定间隔循环执行任务。

每个Timer实例将会与一个线程关联，用于执行TimerTask。Timer的队列可以被添加多个计划任务，但TimerTask实例不可复用，如果我们重复将其添加到Timer队列中，则会出现异常：IllegalStateException(Task already scheduled or cancelled)。

# 基本应用
Timer的任务使用TimerTask承载，该类是Runnable接口的实现类，我们首先需要创建自定义类继承自TimerTask类，并实现 `run()` 方法。

"TestTimer.java":

```java
TimerTask timerTask = new TimerTask() {
    @Override
    public void run() {
        System.out.println("Exec Time: " + LocalDateTime.now());
    }
};
```

此处我们在任务中简单的输出任务执行的时刻信息。

接着我们创建Timer实例，并通过下文内容所示的系列方法设置任务。

🔷 `void schedule(TimerTask task, long delay)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` 。

🔷 `void schedule(TimerTask task, long delay, long period)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void schedule(TimerTask task, Date time)`

在 `time` 时刻执行任务 `task` 。

🔷 `void schedule(TimerTask task, Date firstTime, long period)`

在 `firstTime` 时刻执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void scheduleAtFixedRate(TimerTask task, long delay, long period)`

以当前时刻为参考点，在 `delay` 毫秒之后执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

🔷 `void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`

在 `firstTime` 时刻执行任务 `task` ，且每隔 `period` 毫秒重复执行一次。

<br />

上述方法被调用后任务即刻开始计时，下文代码块给出了一些示例。

"TestTimer.java":

```java
// 创建Timer实例
Timer timer = new Timer();

// 以当前时刻为参考点，在1000毫秒之后执行任务TimerTask。
timer.schedule(timerTask, 1000L);

// 以当前时刻为参考点，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
timer.schedule(timerTask, 1000L, 1000L);

// 在”当前时刻+3秒“执行任务TimerTask。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.schedule(timerTask, date);

// 在”当前时刻+3秒“执行任务TimerTask，且每隔1秒重复执行一次。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.schedule(timerTask, date, 1000L);

// 以当前时刻为参考点，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
timer.scheduleAtFixedRate(timerTask, 1000L, 1000L);

// 在”当前时刻+3秒“执行任务TimerTask，在1秒之后执行任务TimerTask，且每隔1秒重复执行一次。
Date date = new Date();
date.setTime(System.currentTimeMillis() + 3000L);
timer.scheduleAtFixedRate(timerTask, date, 1000L);
```

# 终止任务
如果我们希望停止Timer队列中的任务，可以调用Timer实例的 `cancel()` 方法，它可以使未进入运行状态的任务即刻取消，但已经开始运行的任务仍将继续执行。

每个Timer实例被调用 `cancel()` 方法后就无法接受新的任务了，如果我们试图提交新的任务，则会出现异常：IllegalStateException(Timer already cancelled)。

TimerTask也拥有 `cancel()` 方法，它只会将当前实例标记为取消状态，但不影响Timer队列中的其他任务。

# 两种循环任务的区别
`​schedule()` 方法与 `scheduleAtFixedRate()` 方法都能定义周期任务，但它们的行为是不同的。

首先 `​schedule()` 方法会忽略已经错过的任务； `scheduleAtFixedRate()` 方法则会“补齐”已经错过的任务。

我们定义一个间隔为1秒循环任务，在任务中打印执行时刻，并将任务开始时刻设置为3秒前。

"TestTimer.java":

```java
// 获取当前时间
Date date = new Date();
System.out.println("Reference Time: " + date);

// 阻塞当前线程3秒，不处理任何任务。
try {
    Thread.sleep(3000L);
} catch (InterruptedException e) {
    e.printStackTrace();
}

// 创建Timer并开启任务，参考时间点设置为3秒前。
Timer timer = new Timer();
timer.schedule(timerTask, date, 1000L);
```

此时运行示例程序，并查看控制台输出信息：

```text
Reference Time: Fri Apr 12 00:12:48 CST 2024
Time: 00:12:51.821756300
Time: 00:12:52.824136400
Time: 00:12:53.826305200
```

根据上述输出内容可知：

通过 `schedule()` 方法开启的任务，将会忽略已经错过的任务，只以当前时刻为基准，执行新的任务。

接着我们仍然沿用前文的代码逻辑，并将 `schedule()` 方法替换为 `scheduleAtFixedRate()` 方法。

此时运行示例程序，并查看控制台输出信息：

```text
Reference Time: Fri Apr 12 00:13:16 CST 2024
Time: 00:13:19.133863300
Time: 00:13:19.133863300
Time: 00:13:19.133863300
Time: 00:13:20.098573800
Time: 00:13:21.100862700
Time: 00:13:22.103028900
```

根据上述输出内容可知：

通过 `scheduleAtFixedRate()` 方法开启的任务，将会“补齐”已经错过的任务，例如此处任务的参考时间为3秒前，任务间隔为1秒，因此任务连续执行了3次。

其次，当Timer中有多个任务时， `​schedule()` 方法会被任务阻塞，如果任务执行时长大于预设间隔，则后续任务将被延后； `scheduleAtFixedRate()` 方法不会被任务阻塞，后续任务将会按照原定间隔开启。

上述规律仅适用于多个不同的任务，如果Timer中仅有一个任务且执行时间大于预设间隔，使用上述两个方法的效果相同，后续任务都会被延后执行。

# 疑难解答
## 索引

<div align="center">

|       序号        |                        摘要                        |
| :---------------: | :------------------------------------------------: |
| [案例一](#案例一) | 周期任务未按照预定间隔运行，而是以很高的频率运行。 |

</div>

## 案例一
### 问题描述
周期任务并未按照计划的间隔运行，而是以很高的频率连续运行。

### 问题分析
通过 `scheduleAtFixedRate()` 方法开启的任务，如果错过参考时刻，将会“补齐”它们，详见相关章节： [🧭 两种循环任务的区别](#两种循环任务的区别) 。

由于Timer的参考时间为系统时钟，因此当系统时间发生跳变时，就会出现这种现象。

### 解决方案
使用 `schedule()` 方法开启周期任务；或将Timer替换为Executor等参考时间为相对时间的工具。

---

# Java - 并发与多任务 - Executor

# 简介





线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。


JDK提供的Executor框架

JDK提供了Executor框架，可以让我们有效的管理和控制我们的线程，其实质也就是一个线程池。Executor下的接口和类继承关系如下：


2. 线程池的工作机制

         2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。

         2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。
线程重用的核心是，我们知道，Thread.start()只能调用一次，一旦这个调用结束，则该线程就到了stop状态，不能再次调用start。
则要达到复用的目的，则必须从Runnable接口的run()方法上入手，可以这样设计这个Runnable.run()方法（就叫外面的run()方法）：
它本质上是个无限循环，跑的过程中不断检查我们是否有新加入的子Runnable对象（就叫内部的runnable:run()吧，它就是用来实现我们自己的任务），有就调一下我们的run()，其实就一个大run()把其它小run()#1,run()#2,...给串联起来了，基本原理就这么简单
不停地处理我们提交的Runnable任务。
3. 使用线程池的好处

　Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处：

　　第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

　　第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

　　第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。



Executors：提供了一系列静态工厂方法用于创建各种线程池

　其中常用几类如下：

public static ExecutorService newFixedThreadPool()
public static ExecutorService newSingleThreadExecutor()
public static ExecutorService newCachedThreadPool()
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
public static ScheduledExecutorService newScheduledThreadPool()



🔷 `ExecutorService newSingleThreadExecutor()`

创建具有单个线程的线程池。

前一个任务执行完毕才能执行后一个任务，此时与Timer类似。

🔷 `ExecutorService newFixedThreadPool(int nThreads)`

创建具有 `nThreads` 个线程的线程池。

🔷 `ExecutorService newCachedThreadPool()`

缓存，动态扩容，1分钟后关闭线程

🔷 `ExecutorService newSingleThreadScheduledExecutor()`

　　4、newSingleThreadScheduledExecutor：该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能，可以进行定时执行等；

🔷 `ExecutorService newScheduledThreadPool(int nThreads)`

　　5、newScheduledThreadPool：在4的基础上可以指定线程数量。




`ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)`

1、corePoolSize 核心线程池大小；
2、maximumPoolSize 线程池最大容量大小；
3、keepAliveTime 线程池空闲时，线程存活的时间；
4、TimeUnit 时间单位；
5、ThreadFactory 线程工厂；
6、BlockingQueue任务队列；
7、RejectedExecutionHandler 线程拒绝策略；





execute和submit的区别

（1）execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。

（2）submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。






---

# Kotlin - 高级特性 - 并发与多任务 - 协程

# 简介


1、协程是轻量级线程、比线程耗费资源少
这话虽然是官方说的，但我觉得有点误导的作用，协程是语言层面的东西，线程是系统层面的东西，两者没有可比性。
协程就是一段代码块，既然是代码那就离不开CPU的执行，而CPU调度的基本单位是线程。
2、协程是线程框架
协程解决了异步编程时过多回调的问题，既然是异步编程，那势必涉及到不同的线程。Kotlin 协程内部自己维护了线程池，与Java 线程池相比有些优化的地方。在使用协程过程中，无需关注线程的切换细节，只需指定想要执行的线程即可，从对线程的封装这方面来说这说话也没问题。
3、协程效率高于线程
与第一点类似，协程在运行方面的高效率其实换成回调方式也是能够达成同样的效果，实际上协程内部也是通过回调实现的，只是在编译阶段封装了回调的细节而已。因此，协程与线程没有可比性。

JVM协程基于线程实现，协程任务将在线程池中执行。





# 基本应用
下文的代码片段展示了协程的基本用法，我们提交了一个协程任务，延时片刻模拟耗时操作，并输出一些日志信息。

"TestCoroutine.kt":

```kotlin
fun main() {
    // 阻塞主线程，等待协程执行完毕。
    runBlocking {
        // 使用Default调度器，提交任务并启动协程。
        CoroutineScope(Dispatchers.Default).launch {
            println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
            // 延时2秒，模拟耗时操作。
            delay(2000)
            println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
        }.join()
    }
}
```

`CoroutineScope()` 方法用于创建协程环境， `Dispatchers.Default` 是框架内置的调度器，指定了协程任务将在子线程中运行， `launch()` 方法用于提交任务并开始执行任务。

日志输出语句中的 `getThread()` 方法用于获取工作线程名称， `getTime()` 方法则用于获取当前时间，此处省略具体实现，详见本章示例工程。

此处的实验环境为Java SE平台，我们需要使用 `runBlocking{}` 方法包裹协程测试代码，并在协程启动后调用它的 `join()` 方法使主线程等待协程任务完成。这是因为JVM平台中的协程基于线程实现，主线程执行完毕则整个进程结束，所有非守护线程（包括协程任务）都会立刻终止。如果我们使用Android等主线程无限循环的环境进行实验，则无需调用 `runBlocking{}` 和 `join()` 方法。为了减少缩进，本章后续示例代码均省略 `runBlocking{}` 和 `join()` 方法调用。

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Name:[DefaultDispatcher-worker-1] Time:[15:22:06.914]
Task end. Name:[DefaultDispatcher-worker-1] Time:[15:22:08.936]
```

根据上述输出内容可知：

协程任务在Default调度器所分配的工作线程"worker-1"中运行，遇到 `delay(2000)` 方法时暂停运行，2秒后计时结束恢复运行。

# 挂起与恢复
“挂起”是Kotlin协程的一种特性，当一个协程任务由于某些原因（延时、等待服务器响应等）被“挂起”时，该任务进入暂停状态，并与工作线程脱离，此时协程不会阻塞工作线程，工作线程可以继续为其他协程服务。一段时间后，延时结束或收到服务器的响应，当前协程任务解除“挂起”，从暂停状态中恢复，调度器将会重新为它分配工作线程，继续执行剩余的语句。

对于可复用的代码片段，我们通常会将其定义为方法，例如前文示例协程任务中的延时与日志输出逻辑：

```kotlin
fun task() {
    println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(2000)
    println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
}
```

上述方法定义语句将会导致编译错误，这是因为“挂起”特性是Kotlin协程专有的，非协程部分无法使用该特性，此处的延时方法 `delay()` 就是一个会导致“挂起”的语句。

如果一个方法中含有可能导致“挂起”的语句，我们必须在方法声明语句中添加"suspend"关键字，标识本方法只能在协程任务中使用。

"TestCoroutine.kt":

```kotlin
suspend fun task(): Int {
    println("Task start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(2000)
    println("Task end. Name:[${getThread()}] Time:[${getTime()}]")
    return 0
}

CoroutineScope(Dispatchers.Default).launch {
    // 开启任务并获取返回值
    val value = task()
    println("Task return value is $value")
}.join()
```

被"suspend"关键字修饰的方法也叫“挂起函数”，挂起函数不仅可以被协程任务调用，还可以被嵌套在其他挂起函数中。协程库的内置方法 `delay()` 就是一个挂起函数，因此它可以出现在CoroutineScope实例的 `launch()` 方法中，也可以出现在挂起函数 `task()` 的方法体中。

挂起函数可以拥有返回值，当程序运行至"return"语句时，挂起函数执行完毕，调用者可以声明一个变量接收该值。

在JVM平台中，协程的“挂起”特性由回调机制实现。以协程任务语句 `val value = task()` 为例，当挂起函数 `task()` 开始执行时，调用者注册了结果回调；当延时语句 `delay(2000)` 结束并运行至"return"语句时，调用者通过结果回调接收返回值，并赋值给变量 `value` 。这就是协程代码表现形式为同步，执行效果却为异步的原理。

此时运行示例程序，并查看控制台输出信息：

```text
Task start. Name:[DefaultDispatcher-worker-1] Time:[20:49:56.009]
Task end. Name:[DefaultDispatcher-worker-1] Time:[20:49:58.035]
Task return value is 0
```

我们可以同时开启多个协程任务，以便测试协程任务与工作线程之间的关系。

"TestCoroutine.kt":

```kotlin
suspend fun task(name: String, time: Long) {
    println("Task $name start. Name:[${getThread()}] Time:[${getTime()}]")
    delay(time)
    println("Task $name end. Name:[${getThread()}] Time:[${getTime()}]")
}

val scope = CoroutineScope(Dispatchers.Default)
// 开启第一个任务
scope.launch {
    task("1", 2000)
}
// 开启第二个任务
scope.launch {
    task("2", 3000)
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 1 start. Name:[DefaultDispatcher-worker-1] Time:[21:07:19.332]
Task 2 start. Name:[DefaultDispatcher-worker-2] Time:[21:07:19.332]
Task 1 end. Name:[DefaultDispatcher-worker-2] Time:[21:07:21.368]
Task 2 end. Name:[DefaultDispatcher-worker-2] Time:[21:07:22.376]
```

根据上述输出内容可知：

Task1和Task2依次启动，Default调度器分别为它们分配了工作线程"worker-1"和"worker-2"；Task1执行挂起函数 `delay()` 后进入暂停状态，与工作线程分离，Task2亦然。

2秒之后，Task1首先从暂停状态中恢复，调度器将先前分配给Task2的工作线程"worker-2"分配给Task1，使其继续执行日志输出语句，该现象说明Task2在挂起刻时已经与工作线程"worker-2"分离，而不会使工作线程阻塞，在此期间工作线程可以处理其他任务。

# 任务调度
## 顺序执行
协程任务中的语句默认按照书写顺序执行，当前一个语句执行完毕后，才会开始执行后一个语句。

"TestCoroutine.kt":

```kotlin
CoroutineScope(Dispatchers.Default).launch {
    // 先执行第一个任务
    task("1", 2000)
    // 第一个任务执行完毕后，再执行第二个任务。
    task("2", 2000)
}
```

此时运行示例程序，并查看控制台输出信息：

```text
Task 1 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:18.351]
Task 1 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 start. Name:[DefaultDispatcher-worker-1] Time:[21:55:20.392]
Task 2 end. Name:[DefaultDispatcher-worker-1] Time:[21:55:22.397]
```

对于多个串行化的异步任务，协程代码相比方法回调代码缩进层次更少、更加简洁。

假设我们已知学生ID，需要先通过“查询学生详情”异步接口获取学生信息，再从学生信息中同步获取班级ID，最后通过“查询班级详情”异步接口获取班级详情。

对于该场景，下文代码块展示了方法回调风格的伪代码：

```kotlin
val studentID: Long = 1

// 首先根据ID查询学生信息
queryStudent(studentID, object : OnResult() {
    override fun onSuccess(student: Student) {
        // 获取班级ID
        val classID: Long = student.classID
        // 然后根据班级ID查询班级信息
        queryClass(classID, object : OnResult() {
            override fun onSuccess(classInfo: ClassInfo) {
                // 显示班级信息
                println(classInfo)
            }
        })
    }
})
```

下文代码块则提供了协程风格的伪代码：

```kotlin
val studentID: Long = 1

CoroutineScope(Dispatchers.Default).launch {
    // 首先根据ID查询学生信息
    val student: Student = queryStudent(studentID)
    // 获取班级ID
    val classID: Long = student.classID
    // 然后根据班级ID查询班级信息
    val classInfo: ClassInfo = queryClass(classID)
    // 显示班级信息
    println(classInfo)
}
```

## 并发

<!-- TODO -->

# 上下文
## 调度器
为了方便开发者使用协程，Kotlin提供了一些默认的调度器，详见下文内容：

🔷 `Dispatchers.Default`

CPU密集型任务调度器，适合执行数据过滤、排序、JSON解析等任务。

该调度器在JVM平台中通过线程池实现，默认线程数与CPU核心数一致，能够最大程度地利用CPU计算性能。

当线程数小于CPU核心数时，部分核心没有被分配到线程，此时无法完全利用CPU资源；当线程数大于CPU核心数时，核心频繁切换线程会带来额外的性能开销；因此线程数等于CPU核心数时效率最高。

🔷 `Dispatchers.IO`

I/O密集型任务调度器，适合执行文件读写、网络请求等任务。

该调度器在JVM平台中通过线程池实现，默认线程数为64，如果CPU核心数大于64，则线程数与CPU核心数保持一致。

线程在等待I/O响应期间几乎不消耗CPU的计算性能，因此即使分配较多的线程也不会占用过多CPU性能。

🔷 `Dispatchers.Main`

UI任务调度器，仅在Android平台可用，适合执行更新UI等任务。

该调度器中的任务将通过Handler提交到UI线程中运行，遇到 `delay()` 等"suspend"方法时协程任务将会被挂起，不会阻塞UI线程，因此不用担心导致UI无响应。

🔷 `Dispatchers.Unconfined`

不指定上下文的任务调度器，实际工作线程不可预测，我们通常不使用该调度器。

该调度器中的任务将在调用它的线程中执行，如果调用线程发生阻塞或挂起，则自动开启新线程执行后续任务。


# 切换协程
withContext 是 Kotlin 协程中一个非常实用的函数，它的主要作用包括：
切换协程的执行上下文（线程）：
withContext 允许你明确指定在其代码块中执行的线程或调度器（Dispatcher）。例如，从默认的 Dispatchers.Main 切换到 Dispatchers.IO 以便执行IO密集型操作，如网络请求或磁盘读写，而不阻塞主线程。
阻塞当前协程上下文并等待结果：
当调用 withContext 时，当前协程会在新指定的上下文中执行指定的代码块，并且会阻塞当前的协程执行，直到该代码块执行完毕并返回结果。这意味着你可以从一个具有特定上下文的协程中调用 withContext 来执行另一个上下文中的代码，并直接获得其结果。
返回值处理：
与 launch 不同，withContext 是有返回值的。它会返回代码块中最后一行表达式的值，这使得它非常适合用于执行一些计算或数据获取操作，并将结果带回原始上下文。
综上所述，withContext 是一种在不同线程间进行切换并执行阻塞操作，同时能够携带结果返回的便捷方式，非常适合于需要在后台线程执行耗时操作并处理其结果的场景。

















# Android Scope

GlobalScope是生命周期是process级别的，即使Activity或Fragment已经被销毁，协程仍然在执行。所以需要绑定生命周期。
lifecycleScope只能在Activity、Fragment中使用，会绑定Activity和Fragment的生命周期
viewModelScope只能在ViewModel中使用，绑定ViewModel的生命周期

implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9'
implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.2.0'//lifecycleScope
implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0'//viewModelScope




---

# Java - 高级特性 - 外部交互 - 命令行

# 返回值

如果 `main()` 方法正常运行完毕，JVM将会向系统发送进程状态码"0"；如果其在运行过程中发生错误，导致进程异常终止，JVM将会向系统发送进程状态码"1"。

Linux系统中的环境变量 `$?` 即代表前一个任务的返回值，我们在Shell中运行以上代码，并查看返回值：

```text
# 编译并运行示例程序
[root@Fedora ~]$ java FirstDemo.java
Hello World!

# 读取上一个进程的状态码
[root@Fedora ~]$ echo "$?"
0
```

除了正常顺序运行的逻辑外，我们还可以根据需要，在代码中的任意位置调用 `System.exit(int code)` 方法终止主进程，并配置自定义的状态码"code"。



---

# Kotlin - 变量 - 外部交互 - 命令行

    const val 可见性为public final static，可以直接访问。
    val 可见性为private final static，并且val 会生成方法getNormalObject()，通过方法调用访问。

总结：

当定义常量时，出于效率考虑，我们应该使用const val方式，避免频繁函数调用。
