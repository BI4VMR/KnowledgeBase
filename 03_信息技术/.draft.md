# 设计模式 - 概述

根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。
序号	模式 & 描述	包括
1	创建型模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 	

    工厂模式（Factory Pattern）
    抽象工厂模式（Abstract Factory Pattern）
    单例模式（Singleton Pattern）
    建造者模式（Builder Pattern）
    原型模式（Prototype Pattern）

2	结构型模式
这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 	

    适配器模式（Adapter Pattern）
    桥接模式（Bridge Pattern）
    过滤器模式（Filter、Criteria Pattern）
    组合模式（Composite Pattern）
    装饰器模式（Decorator Pattern）
    外观模式（Facade Pattern）
    享元模式（Flyweight Pattern）
    代理模式（Proxy Pattern）

3	行为型模式
这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 	

    责任链模式（Chain of Responsibility Pattern）
    命令模式（Command Pattern）
    解释器模式（Interpreter Pattern）
    迭代器模式（Iterator Pattern）
    中介者模式（Mediator Pattern）
    备忘录模式（Memento Pattern）
    观察者模式（Observer Pattern）
    状态模式（State Pattern）
    空对象模式（Null Object Pattern）
    策略模式（Strategy Pattern）
    模板模式（Template Pattern）
    访问者模式（Visitor Pattern）

4	J2EE 模式
这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 	

    MVC 模式（MVC Pattern）
    业务代表模式（Business Delegate Pattern）
    组合实体模式（Composite Entity Pattern）
    数据访问对象模式（Data Access Object Pattern）
    前端控制器模式（Front Controller Pattern）
    拦截过滤器模式（Intercepting Filter Pattern）
    服务定位器模式（Service Locator Pattern）
    传输对象模式（Transfer Object Pattern）

下面用一个图片来整体描述一下设计模式之间的关系：

设计模式之间的关系
设计模式的优点

    提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。
    提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。
    促进了代码的重用，避免了重复的设计和实现。
    通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。

设计模式的六大原则

1、开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3、依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5、迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。


---

# 操作系统 - CPU


1  处理器管理
1.1  进程
1.1.1  概述
早期的计算机一次只能运行单个程序，当某个程序开始运行时，将会独占系统的全部资源（处理器、存储设备、I/O设备等），其它用户必须等待当前程序执行完成后，才能使用计算机，这种方式的设备利用率极低。
单道程序的运行具有以下特征：
 顺序性
程序执行时严格按照预先规定的步骤推进。
 封闭性
程序执行时独占全部系统资源，外界无法进行干涉。
 可再现性
程序重复多次执行时，只要初始条件相同，结果必然也相同。
由于单道程序系统的低效率，人们设计了多道程序系统，多个程序在微观时间内交替执行，充分利用闲置的系统资源，以此提高系统利用率。
多个程序并发执行将会破坏单道程序的三个特性，有些程序的部分操作必须严格按照预定的顺序进行，否则会导致结果不一致的问题，因此需要引入“进程”进行管理。
进程(Process)是程序在一个数据集合（软/硬件环境）上的执行过程，也是系统分配资源与CPU调度的单位，与“程序”具有以下区别：
 动态性
进程反应程序的执行过程，具有创建、运行、暂停、销毁等状态，且拥有系统资源；程序是存储在介质中的代码，是静态的且不持有系统资源。
 并发性
进程能交替进入运行、暂停状态，与其它进程交替执行，程序不具有此特征。
 临时性
进程执行完毕后相关资源就被释放了，程序则是永久存在于介质中的。
1.1.2  进程状态机
进程有三个基本状态：
 运行(Running)
进程得到CPU资源，正在运行。单处理机系统同时只能运行一个进程；多处理机系统可能有多个进程同时运行。
 就绪(Ready)
进程除CPU以外的资源都已经就绪，但未被分配CPU资源，暂时无法运行。
 阻塞(Block)
正在等待I/O操作或同步事件完成，此时即便分配了CPU资源也无法运行。
状态机之间可以相互转换：
 运行与就绪
操作系统会将处于就绪状态的进程放置在一个队列中，当处理机空闲时，系统会根据优先级或其它因素选择进程，使其获得处理机资源并运行。当进程获得的CPU时间片用完后，进程会重新回到就绪状态，等待下一次调度。
 运行与阻塞
当进程需要等待I/O操作或同步事件时，将从运行进入阻塞状态。
 阻塞与就绪
当进程所需的其它资源满足时，将重新进入进入就绪队列，等待系统调度。
 
图 1-1 基本进程状态转换
除了三个基本状态，进程还可以有其它的状态：
 创建
系统为进程设置相关参数、分配资源，前期操作完成后将会加入就绪队列。
 退出
进程正常结束或崩溃后，系统将其从运行状态中移除，并释放系统资源。
 挂起
有些系统为了更精确的控制资源配置，还定义了挂起状态。当内存空间紧张时，可以将不重要的进程挂起，内存中的部分内容被写入外存储器交换空间，缓解系统负载。另一方面，用户可以观察暂停的进程，便于对程序进行调试。
 
图 1-2 扩展进程状态转换
1.1.3  进程控制块
进程控制块(Process Control Block,PCB)是进程的组成部分，用于描述进程的动态信息，如进程标识符、当前状态、优先级、创建者、父进程等，系统的资源调度模块根据PCB中的信息执行调度操作。
 
1.2  线程
1.2.1  概述
进程的应用使得计算机宏观上可以同时运行多个程序，资源利用率得到提高，但每个进程内部依然是顺序执行的，不能满足现代程序的需要。现代程序一般拥有多个线程，主线程用于控制GUI显示，及时响应用户操作；逻辑功能则通过子线程实现，这样执行耗时操作时GUI仍然能与用户交互，提升了用户体验。
线程是比进程更小的调度单位，切换进程时，需要保存原进程的CPU上下文，再装入新进程的CPU上下文，消耗了额外的资源，开销较大；线程则只涉及CPU算力的分配，切换速度较快，开销较小。


---

# 操作系统 - CPU

# 理论基础
## 进程与线程
进程是指程序的一次执行过程，它直接持有操作系统分配的内存、网络地址、I/O设备等资源。

线程是进程内部的任务，它只占用CPU计算资源，而不持有内存等其他资源。



---

# 计算机体系结构 - 数制系统





---

# 计算机体系结构 - 数据的表示 - 文件

文件名是方便人类识别文件类型的，不一定能准确反应实际类型，可能会被恶意篡改。

每种文件类型都有特性的格式，我们通常可以读取文件头部的若干字节，来判断文件类型。例如JPEG图像都以"FFD8FF"开头，WAV音频都以"57415645"开头

有些文件类型的文件头部是相同的，我们还需要进一步读取其他信息进行判断，例如ZIP压缩包和WORD2007文本文档都以"504B0304"开头。










判断原理：定义好常用格式的文件后缀，以及对应文件的字节码前N位，作为判断的一句。

一般而言，如果手工修改文件的后缀，其内部文件字节码是不会发生变化的，以此来作为判断的标准。

因此，工作中，定义一个简要的工具来对常用的文件格式进行校验也是必要的。

以下是定义好的常用几种文件格式的校验，若有需要，可以自行增加。

特殊情况：目前，对于文本文件（*.txt）的文件无法校验，其读取的文件字节码几乎都不一样。当然还可能存在其他的。




# 文件特征

APK 文件：
文件头：50 4B 03 04 14 00 08 00
文件尾：50 4B 05 06 00 00

AVI 文件：
文件头：52 49 46 46 xx xx xx xx 41 56 49 20
文件尾：00 00 00 00

BAT 文件：
文件头：3C 25 40 20 25 5F 46 49 4C 45 5F 25 20 3E
文件尾：(无)

BMP 文件：
文件头：42 4D
文件尾：（无）

DLL 文件：
文件头：4D 5A
文件尾：(无)

DOC 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

DOCX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

EPS 文件：
文件头：25 21 50 53 2D 41 64 6F 62 65
文件尾：(无)

EXE 文件：
文件头：4D 5A
文件尾：(无)

FLAC 文件：
文件头：66 4C 61 43
文件尾：(无)

GIF 文件：
文件头：47 49 46 38 39 61
文件尾：3B

GZ 文件：
文件头：1F 8B 08
文件尾：(无)

HTML 文件：
文件头：3C 21 44 4F 43 54 59 50 45 20 48 54 4D 4C 20 50
文件尾：3C 2F 48 54 4D 4C 3E

ICO 文件：
文件头：00 00 01 00
文件尾：（无）

INI 文件：
文件头：3B
文件尾：(无)

ISO 文件：
文件头：43 44 30 30 31
文件尾：(无)

Java 类文件：
文件头：CA FE BA BE
文件尾：(无)

JAR 文件：
文件头：50 4B 03 04 14 00 08 00
文件尾：50 4B 05 06 00 00

JPEG 文件：
文件头：FF D8 FF E0
文件尾：FF D9

JPG 文件：
文件头：FF D8 FF E0
文件尾：FF D9

JSON 文件：
文件头：7B 22 74 79 70 65 22 3A 22
文件尾：7D

MKV 文件：
文件头：1A 45 DF A3
文件尾：(无)

MOV 文件：
文件头：00 00 00 14 66 74 79 70 71 74 20
文件尾：(无)

MP3 文件：
文件头：49 44 33
文件尾：FF FB

MP4 文件：
文件头：00 00 00 14 66 74 79 70 69 73 6F 6D
文件尾：(无)

ODT 文件：
文件头：50 4B 03 04 14 00 08 08
文件尾：50 4B 05 06 00 00

OTF 文件：
文件头：4F 54 54 4F
文件尾：(无)

PDF 文件：
文件头：25 50 44 46 2D 31 2E
文件尾：25 25 45 4F 46

PNG 文件：
文件头：89 50 4E 47 0D 0A 1A 0A
文件尾：49 45 4E 44 AE 42 60 82

PPT 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

PPTX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

PSD 文件：
文件头：38 42 50 53
文件尾：(无)

RAR 文件：
文件头：52 61 72 21 1A 07 00
文件尾：(无)

RTF 文件：
文件头：7B 5C 72 74 66 31
文件尾：7D

SQL 文件：
文件头：3B 43 3B 20
文件尾：3B

SVG 文件：
文件头：3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E
文件尾：3C 2F 73 76 67 3E

TAR 文件：
文件头：75 73 74 61 72 00 30 30
文件尾：（无）

TIFF 文件：
文件头：49 49 2A 00
文件尾：(无)

TXT 文件：
文件头：（无）
文件尾：（无）

WAV 文件：
文件头：52 49 46 46 xx xx xx xx 57 41 56 45 66 6D 74 20
文件尾：64 61 74 61 xx xx xx xx

WebM 文件：
文件头：1A 45 DF A3
文件尾：(无)

Windows 文件夹（目录）：
文件头：4B 44 57 4D
文件尾：(无)

WMV 文件：
文件头：30 26 B2 75 8E 66 CF 11 A6 D9 00 AA 00 62 CE 6C
文件尾：(无)

WordPerfect 文件：
文件头：FF 57 50 43
文件尾：（无）

XLS 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

XLSX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

XML 文件：
文件头：3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E
文件尾：3C 2F 72 6F 6F 74 3E

ZIP 文件：
文件头：50 4B 03 04
文件尾：50 4B 05 06


---



# 计算机体系结构 - 数据的表示 - 文本

比如说，对于文本文件，开头的几个字节可以叫做BOM（Byte Order Mark），它的作用是用来标记文本文件内部是用的哪种Unicode编码，以及其字节码顺序。UTF-8，UTF-16BE，UTF-16LE等等各种Unicode编码都有自己独一无二的BOM。一般的文本编辑器也都支持 BOM。这样就不会出现乱码了。


---

# 计算机体系结构 - 代码结构

# 顺序结构
连续的多行语句即为顺序结构，程序运行时，将会首先执行第一条语句对应的操作，当第一条语句执行完毕后，再执行第二条语句，依次类推直到所有语句都被执行完毕。

# 分支结构
## 简介
分支结构也叫选择结构，程序运行时不会严格按照语句的书写顺序执行，而是根据条件选择相应的语句并执行。



---

# 计算机体系结构 - ANSI颜色

ANSI颜色标准定义了一组有限的颜色选项，最初支持的是16种基本颜色。这些颜色可以通过ANSI转义序列来设置文本或背景的颜色。对于基本的16种颜色，它们并没有直接对应到特定的十六进制RGB值，而是有一组约定俗成的颜色映射。
最初的8种标准颜色包括：
黑色 (Black)
红色 (Red)
绿色 (Green)
黄色 (Yellow)
蓝色 (Blue)
靛青色/Magenta (Magenta)
青色/Cyan (Cyan)
白色 (White)
接下来的8种颜色是上述颜色的“明亮”版本：
亮黑色 (Bright Black, 或者深灰色)
亮红色 (Bright Red)
亮绿色 (Bright Green)
亮黄色 (Bright Yellow, 或者淡绿色)
亮蓝色 (Bright Blue)
亮靛青色 (Bright Magenta)
亮青色 (Bright Cyan)
亮白色 (Bright White, 或者纯白色)
这些颜色可以用ANSI转义序列来设置，例如：
前景色：\033[30m 到 \033[37m 对应于黑色到白色。
背景色：\033[40m 到 \033[47m 对应于黑色到白色。

对于这些基本颜色，通常使用的十六进制RGB值如下（这并不是ANSI标准的一部分，而是一种常见的实现方式）：

黑色: #000000
红色: #CD0000
绿色: #00CD00
黄色: #CDCD00
蓝色: #0000EE
靛青色/Magenta: #CD00CD
青色/Cyan: #00CDCC
白色: #E5E5E5

明亮版本的颜色通常会更接近以下值：

亮黑色: #7F7F7F
亮红色: #FF0000
亮绿色: #00FF00
亮黄色: #FFFF00
亮蓝色: #5C5CFF
亮靛青色: #FF00FF
亮青色: #00FFFF
亮白色: #FFFFFF



# 计算机体系结构
## 屏幕大小

屏幕大小：通常描述手机大小会用几寸来描述，如6.5寸手机，这里的屏幕大小实际指的是屏幕对角线的长度；

分辨率：手机屏幕的像素点个数，如手机屏幕分辨率为1920x1080指的是宽有1080个像素点，高有1920个像素点；

DPI：每英寸像素，由对角线的像素点个数除以屏幕大小（对角线长度）得到；

px：像素，1px代表屏幕上一个物理的像素点，可以理解为绝对尺寸，在某个屏幕分辨率上显示一个长度值，到了另一个屏幕分辨率还是同一个长度值，一般不使用这个单位，因为会造成同一尺寸在不同分辨率显示不同的效果；


---

# UUID

UUID（Universally Unique Identifier）和GUID（Globally Unique Identifier）本质上是相同的概念，但在某些细节和使用场景上有轻微差异。以下是它们的核心区别和联系：
1. 起源与标准

    UUID
    由RFC 4122（2005年发布）定义的标准，是开放网络计算基金会（Open Software Foundation, OSF）最初提出的概念。
    遵循严格的格式和生成规则（如版本1-5），通常以32位十六进制数表示（例如：550e8400-e29b-41d4-a716-446655440000）。

    GUID
    是微软对UUID的实现，最初用于其技术（如COM、ActiveX、.NET等）。
    虽然格式与UUID相同，但早期微软的GUID生成算法可能与RFC标准不完全一致（例如版本1的字节顺序问题）。

https://www.rfc-editor.org/rfc/rfc4122
https://www.rfc-editor.org/rfc/rfc9562


79f43d95-3ba2-49b2-8e46-80175e591169
2c9788f5-bc53-44b0-b41e-39ebb45246b7
d681a590-e4a3-4b88-935b-58546a873038

UUID之所以被广泛采用，主要原因之一是它们的分配不需要中心管理机构介入。其具有唯一性和持久性，它们非常适合用作统一资源名称（URN）。UUID能够无需注册过程就能生成新的标识符的独特优点，使得UUID成为创建成本最低的URN类型之一。


第三段的高4位是版本号，常见取值 1,2,3,4,5,7

第四段的高2位是保留位，固定值"10"

8/9/a/b


V1

    原理：timestamp + 时钟序列+MAC 地址。

时钟序列

时钟序列（clock sequence）用于帮助避免因系统时间被设置回溯或节点ID发生变化时可能出现的重复标识符。

    缺点：

        机器的MAC地址出厂后不能保证完全唯一，且之后 MAC 地址也可手动修改

        MAC 地址的暴露会造成了隐私与安全问题

        若一台机子上的两个进程同时跑，有可能出现重复问题

UUID v2
DCE（Distributed Computing Environment）安全应用中
UUID版本2（UUIDv2）是基于DCE安全的UUID，它在UUIDv1的基础上添加了本地域标识符（如用户ID或组ID）。
域标识符 (domain) 可以是：

    0 = 个人 (PERSON)

    1 = 组 (GROUP)

    2 = 组织 (ORG)

本地标识符 (identifier) 通常是：

    对于个人域：用户ID (POSIX uid)

    对于组域：组ID (POSIX gid)

    对于组织域：组织定义的ID


UUID v3

命名空间+名称，例如“bi4vmr.com-node1” 命名空间和名称的具体数据形式不做限制，可以是字符串、数字等，底层均以字节处理

在同一命名空间内，使用相同名称在不同时间生成的UUID必须完全相同。
在同一命名空间内，使用两个不同名称生成的UUID应当是不同的（概率极高）。
在两个不同命名空间内，使用相同名称生成的UUID也应当是不同的（概率极高）。
如果两个由名称生成的UUID相同，则它们几乎肯定是由同一命名空间内的相同名称生成的。



UUID v4

版本号固定为"4"，其他位置使用随机或伪随机数值填充，该方法完全无规律，是最常用的一种实现


UUID v5


与3相同，但散列算法由MD5变更为SHA-1

UUID v7

UUIDv7 是基于时间戳驱动生成的，同时保留了一部分随机数。
前 48 位嵌入了毫秒级的 Unix 时间戳，后续部分为随机数。

适合作为数据库的主键使用，线性增长对部分数据库性能更友好


---


## Base系列编码
### 简介


> ⛔ 禁止
>
> Base系列编码并非加密算法，严禁明文传输包含敏感信息的编码字符串。
>
> 虽然经过Base算法编码后的文本人类不可读，但它们具有一些明显的编码特征，攻击者截获文本后，只需尝试使用各种常见的编码算法进行解码，就会得到人类可读的原始内容。


---


# 数据库事务

数据库中的事务有四大特性（ACID），分别是原子性、一致性、隔离性和持久性。针对隔离性，还有四个隔离级别，分别是串行化、可重复读、读已提交和读未提交。这四个隔离级别是针对并发事务中存在的三个问题，分别是脏读、不可重复读和幻读。

事务的四大特性
1. 原子性（Atomicity）

事务包含的所有数据库操作要么全部成功，要不全部失败回滚。
2. 一致性（Consistency）

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。一致性规定事务提交前后只存在两个状态，提交前的状态和提交后的状态，绝对不会出现中间的状态。最典型的例子就是银行转账，A和B之间互相转账，账面加起来总和5000元，无论A和B之间怎么转，转几次，成功与否，事务结束后A和B账面总和还是5000元。
3. 隔离性（Isolation）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
4. 持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

事务并发时存在的问题
1. 脏读（Dirty Read）

脏数据所指的就是未提交的数据，而脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。比如，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。
2. 不可重复读（Non-repeatable Read）

一个事务先后读取同一条记录，而事务在两次读取之间该数据被其它事务所修改，则两次读取的数据不同，我们称之为不可重复读。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是在同一事务内读取了前一事务提交的数据，即前一次读到的数据是另一个事务提交前，后一次读到的数据是提交后的。
3. 幻读（Phantom Read）

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

在实际开发和使用中，其实幻读问题是可以接受也符合用户的心理预期，比如在淘宝双十一抢东西，点击“购买”，成功进入**“下单页面”，结果到“付款页面”**却提示已经被抢完，这是可以接受的。

四个隔离级别
1. 读未提交（Read uncommitted）

所有事务都可以看到其他未提交事务的执行结果。本隔离级别是最低的隔离级别，虽然拥有超高的并发处理能力及很低的系统开销，但很少用于实际应用。因为采用这种隔离级别只能防止更新丢失问题（这个问题现代关系型数据库已经不会发生），不能解决脏读，不可重复读及幻读问题。
2. 读已提交（Read committed）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别可以防止脏读问题，但会出现不可重复读及幻读问题。
3. 可重复读（Repeatable read）

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别可以防止除幻读外的其他问题。
4. 串行化（Serializable ）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读、第二类更新丢失问题。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常数据库不会用这个隔离级别，我们需要其他的机制来解决这些问题:乐观锁和悲观锁。

---

# LIKE语句

如果like语句的条件为空或者任意数量的 `%` ，会被视为没有条件，匹配到所有表项，需要从程序中避免。

```kotlin
val keyword = userInput.trim()
val sql = if (keyword.isEmpty() || keyword.all { it == '%' }) {
    throw Exception()
} else {
    "SELECT * FROM app_metadata_table WHERE componentName LIKE ?"
}
```
