# Linux - 高级特性 - 系统设置

# 理论基础
## 时区划分
整个地球被划分为24个时区，以本初子午线为基准，大致每隔15°经度划分一次，东西各12个时区，每个时区都有自己的本地时间。时区划分产生了各种不同的计时标准，我们需要选择合适的标准，防止时间发生混乱。

<div align="center">

![时区划分](./Assets-时钟控制/基本概念-时区划分.jpg)

</div>

## 世界协调时(UTC)
世界协调时(Universal Time Coordinated, UTC)是使用原子钟计时得到的时间，“一天”为精确的86400秒。在国际无线电通信等场合，统一使用UTC时间作为标准。

UTC在军事上使用"Z"表示，由于"Z"在字母解释法中以"Zulu"作为代称，UTC也被称为祖鲁时间(Zulu Time)。

## 格林威治标准时间(GMT)
格林威治标准时间(Greenwich Mean Time, GMT)是位于英国伦敦的皇家格林威治天文台标准时间，“一天”为地球自转的周期。

由于地球自转周期总在缓慢变化，当GMT与UTC的差值达到±0.9秒时，就把UTC时间拨快或拨慢1秒，使UTC与自转周期相符。

## 中国标准时间(CST)
中国标准时间(China Standard Time, CST)是指北京时间，北京位于东8区，因此UTC或GMT+8小时即得到CST时间。

需要注意的是，"CST"这一缩写还可能代表其它地区，例如美国中部时间(UTC-6)、古巴标准时间(UTC-4)。

## 夏令时(DST)
夏令时(Daylight Saving Time, DST)是指在夏天太阳升起较早时，将时钟拨快一小时，可以使人早起早睡，充分利用光照资源，从而节约照明用电。

由于这种标准并未达到预期的效果，反而导致时间混乱，现在已经较少使用。

# "date"命令
`date` 命令用于读取或设置系统时间与日期，其常用选项见下文：

🔷 `-u`

显示为UTC时间。

🔷 `-R`

显示为RFC 2822格式。

🔷 `-d`

将字符串转换为指定格式。

🔷 `-s`

将字符串设置为系统时间。

当我们使用字符串表示时间格式时，需要使用特定的符号组合，它以"+"号开头，可用的符号及其含义详见下表。

<div align="center">

| 符号  |        含义        |
| :---: | :----------------: |
| `%t`  |       制表符       |
| `%n`  |     插入新的行     |
| `%Y`  |    年份(四位数)    |
| `%y`  |    年份(两位数)    |
| `%m`  |     月份(数字)     |
| `%d`  |    日期(01-31)     |
| `%H`  |    小时(00-23)     |
| `%I`  |    小时(01-12)     |
| `%K`  |     小时(0-23)     |
| `%l`  |     小时(0-12)     |
| `%P`  |     显示AM/PM      |
| `%M`  |        分钟        |
| `%S`  |         秒         |
| `%s`  |  时间戳(不含毫秒)  |
| `%c`  | 当前地区的默认格式 |

</div>

🔴 示例一

按照“年-月-日 时:分:秒”的格式显示当前时间。

```text
[root@Fedora ~]# date "+%Y-%m-%d %H:%M:%S"
2021-08-12 10:43:10
```

🟠 示例二

将系统时间设置为"2000-01-01 12:00:00"。

```text
[root@Fedora ~]# date -s "2000-01-01 12:00:00"
Sat Jan  1 12:00:00 CST 2000
```

🟡 示例三

将字符串格式化为指定格式。

```text
[root@Fedora ~]# date -d "2020-08-01 12:30" "+%Y/%m/%d%n%H:%M"
2020/08/01
12:30
```

# "timedatectl"命令
`timedatectl` 是Systemd提供的时间配置命令，直接运行该命令可以查看当前时间与时区的相关信息。

🔴 示例一

使用 `timedatectl` 命令查看系统时间与时区信息。

```text
[root@Fedora ~]# timedatectl
      Local time: Thu 2021-08-12 10:50:49 CST
  Universal time: Thu 2021-08-12 02:50:49 UTC
        RTC time: Thu 2021-08-12 10:50:48
       Time zone: Asia/Shanghai (CST, +0800)
     NTP enabled: yes
NTP synchronized: yes
 RTC in local TZ: yes
      DST active: n/a
```

系统默认会与NTP服务器自动校时，执行 `timedatectl set-ntp < true | false >` 可以控制是否启用校时服务，关闭NTP服务时，执行 `timedatectl set-time <时间>` 可以手动设置系统时间。

## 时区设置
该工具还可以调整系统时区设置，执行 `timedatectl list-timezones` 可以查看所有时区的名称， `timedatectl set-timezone [时区]` 命令可以更改时区设置。

🟠 示例二

将系统时区改为“亚洲/上海”。

```text
# 设置时区
[root@Fedora ~]# timedatectl set-timezone Asia/Shanghai

# 查看当前时区
[root@Fedora ~]# timedatectl
timedatectl
      Local time: Thu 2021-08-12 10:54:39 CST
  Universal time: Thu 2021-08-12 02:54:39 UTC
        RTC time: Thu 2021-08-12 10:54:37
       Time zone: Asia/Shanghai (CST, +0800)
```

## 硬件时钟控制
默认情况下Linux系统将硬件时钟视作UTC时间，然后通过时区换算得到本地时间。

若用户有特殊的需求，例如计算机存在Windows系统、主板存在时控功能，可以通过 `timedatectl set-local-rtc < true | false >` 设置是否将硬件时钟视作本地时间。

---

# 电源管理

# "shutdown"命令
我们通常使用 `shutdown` 命令控制系统电源，语法为： `shutdown {选项} { 时间 | 时间偏移量 | now } {&}` ，“时间偏移量”以当前时间为基准，单位为秒，"+T"表示"T"分钟后执行；"now"则表示立刻执行；"&"表示将命令放入后台。

`shutdown` 命令的常用选项如下文内容所示：

🔷 `-h`

关机。

🔷 `-r`

重启。

🔷 `-c`

取消前一条定时关机任务。

🔷 `-k`

向所有用户发送控制台消息。

除了使用 `shutdown` 命令进行关机、重启之外，其它命令也可以实现这些功能：

- `reboot` 命令等价于 `shutdown -r now` ，系统将立即重启。
- `poweroff` 和 `halt` 命令等价于 `shutdown -h now` ，系统将立即关机。

关机或重启前系统将会执行 `sync` 命令，将内存中未保存的更改写入硬盘，以防数据丢失。



# Linux - Shell - Bash别名

# 查找可执行文件
执行 `whereis <命令>` 可以查找命令的可执行文件与文档位置，其常用选项可参见下文内容。

🔷 `-b`

仅查找可执行文件位置。

🔷 `-m`

仅查找帮助文件位置。

🔷 `-s`

仅查找源代码位置。

🔴 示例一

查找 `reboot` 命令的可执行文件与文档位置。

```text
[root@Fedora ~]# whereis reboot
reboot: /usr/sbin/reboot /usr/share/man/man8/reboot.8.gz
```

# 命令的别名
## 简介
Shell支持为命令语句设置别名，用户输入的别名将被翻译成对应的语句，为复杂的语句设置别名，能够显著提高操作效率。

## 查看特定别名
执行 `which <别名>` 可以查看该别名对应的真实命令，部分发行版会将常用的命令与选项组合设置为别名，方便用户使用，例如Fedora系统的 `ll` 。

🔴 示例一

查看 `ll` 对应的真实命令。

```text
[root@Fedora ~]# which ll
alias ll='ls -lh'
        /usr/bin/ls
```

## 查看所有别名
`alias` 命令用于创建别名，不加参数直接执行时，将会显示当前用户的所有别名。

🟠 示例二

查看当前用户的所有别名。

```text
[root@Fedora ~]# alias
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias ll='ls -lh'
```

## 创建别名
执行 `alias <别名>="<命令语句>"` 可以创建新的别名，这种别名只能临时生效，用户注销后将被清除。若要设置永久别名，需修改配置文件，按照前文所述语法书写别名规则。

写入 `/etc/profile` 的规则将影响所有用户，写入用户Shell配置文件的规则只对其自身生效，Bash的用户配置文件为 `~/.bashrc` 。

## 删除别名
`unalias` 命令可以删除指定命令的所有别名，该命令只能临时生效，若希望永久生效，需要修改对应的配置文件。

# 命令历史记录
Shell会保存用户输入的命令，以供后续查阅或调用。Bash的历史记录保存在用户主目录中的 `.bash_history` 文件中，默认的最大数量为1000条，可以通过修改 `HISTSIZE` 环境变量进行变更。

我们可以使用 `history` 命令查看历史记录，其常用选项可参见下文内容。

🔷 `-c`

清空缓存中的历史命令。

🔷 `-w`

将缓存中的历史命令写入。

🔴 示例一

查看当前用户的历史记录。

```text
[root@Fedora ~]# history 
    1  touch abc
    2  mkdir dir1
    3  echo -e "ABC"
    4  history
```

我们可以在Shell中使用特定的操作再次调用历史记录中的命令：

- 使用上下方向键可以逐条查阅历史记录。
- 输入 `!N` 可以再次执行上述示例输出中的第N条命令。
- 输入 `!!` 可以再次执行前一条命令。
- 输入 `![字符串]` 可再次执行最后一条以指定字符串开头的命令。
- 使用 `CTRL+R` 组合键可以进入搜索模式，输入字符以搜索历史命令，按下 `ENTER` 键采用搜索结果。

🟠 示例二

调用编号为3的历史命令。

```text
[root@Fedora ~]# !3
echo -e "ABC"
ABC
```

# 查看帮助信息
## 简明信息
大部分命令都有丰富的选项与特殊语法，如果我们忘记了某些命令的用法，可以在命令后添加"-h"或"--help"选项，查看其简要说明。

🔴 示例一

查看"zip"命令的简明帮助信息。

```text
[root@Fedora ~]# zip -h
Copyright (c) 1990-2008 Info-ZIP - Type 'zip "-L"' for software license.
Zip 3.0 (July 5th 2008). Usage:
zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]
  The default action is to add or replace zipfile entries from list, which
  can include the special name - to compress standard input.
  If zipfile and list are omitted, zip compresses stdin to stdout.
  -f   freshen: only changed files  -u   update: only changed or new files
```

对于Shell的内置命令，需要执行 `help [命令]` 查看其帮助信息。

🟠 示例二

查看"source"命令的简明帮助信息。

```text
[root@Fedora ~]# help source
source: source filename [arguments]
    Execute commands from a file in the current shell.
    
    Read and execute commands from FILENAME in the current shell.  The
    entries in $PATH are used to find the directory containing FILENAME.
    If any ARGUMENTS are supplied, they become the positional parameters
    when FILENAME is executed.
```

## 详细信息
除了简明帮助信息，各大软件包通常还附有详细的使用文档，系统将帮助文档分为9个级别，分别对应不同类型的信息：

<div align="center">

| 级别  |           含义           |
| :---: | :----------------------: |
|   1   |       普通帮助文档       |
|   2   | 可被内核调用的函数的文档 |
|   3   |  普通函数和库的帮助文档  |
|   4   | 特殊文件（主要在/dev中） |
|   5   |     配置文件帮助文档     |
|   6   |      游戏的帮助文档      |
|   7   |           杂项           |
|   8   | 管理员可用的命令帮助文档 |
|   9   | 与内核相关文件的帮助文档 |

</div>

"man"命令可以查看软件包的帮助文档，语法为 `man {级别} {选项} [命令]` ，其常用选项详见下文：

🔷 `-a`

在所有文档中搜索。

🔷 `-f`

查看文档摘要信息（精确匹配）。

🔷 `-k`

查看文档摘要信息（模糊匹配）。

🔷 `-M`

指定搜索文档的目录。

系统中还有"whatis"和"apropos"命令，分别用于精确和模糊搜索帮助文档， `whatis` 等价于 `man -f` ， `apropos` 等价于 `man -k` 。除此之外，"info"命令可以查看比"man"命令更详细的文档信息。


# Linux - Shell - Bash历史记录

ignoredups 去除连续重复的命令，要消除整个命令历史中的重复命令，把 HISTCONTROL设置成 erasedups

---

# Linux - Shell - zsh历史记录

`~/.zshrc`


# 历史记录文件
#
# 在Zsh中，我们必须明确设置该属性，否则Shell不会记录任何历史命令。
HISTFILE="$HOME/.zsh_history"

# 最大历史记录数量
HISTSIZE=5000
SAVEHIST=5000

# 在多个会话之间共享历史记录
setopt SHARE_HISTORY

# 即时更新历史记录
#
# 默认情况下，每个会话都有独立的历史记录内存缓冲区，仅当会话正常退出时才会将内容写入文件。
# 如果会话非正常退出，历史记录将会丢失。添加该选项后，我们每执行一条命令，都会立刻将记录写入文件，防止记录丢失。
setopt INC_APPEND_HISTORY

# 如果当前命令与最新的一条历史记录重复，则不记录当前命令。
setopt HIST_IGNORE_DUPS

# 如果当前命令与任意的一条历史命令重复，则删除历史记录，并将当前命令写入历史记录末尾。
setopt HIST_IGNORE_ALL_DUPS

---

# Linux - Shell - zsh命令提示符

PROMPT变量用于定义命令提示符格式。

官方说明

https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html


    %n：用于显示登录用户的用户名。

    %m：显示系统的主机名。

    %1~：%1 部分显示当前工作目录的名称，只有在主目录中时才会显示波形符。

%j

    当前由 shell 管理的作业数量。
%L

    $SLVL 变量的当前值。

%t 
12 小时格式的当前时间。
 1:33下午

%T

    24 小时格式的当前时间。
%r

    以 12 小时格式显示当前时间（含秒）。
%D

    以“yyyy-mm-dd”格式显示日期。


-- 颜色 --

Start 	End 	Effect
%B 	%b 	Bold
%U 	%u 	Underline
%S 	%s 	Highlight
%F{color} 	%f 	Foreground color
%K{color} 	%k 	Background color


%{$reset_color%} 可能无效


https://www.ditig.com/publications/256-colors-cheat-sheet



%n - username
%m - short name of the current host
%M - name of curent host
%# - a % or a #, depending on whether the shell is running as root or not
%~ - relative path
%/ or %d - absolute path
%c or %C - Trailing component of the current working directory.
%t - time 12hr am/pm format
%T - time 24hr format
%w - day and date (day-dd)
%D - Date (default: yy-mm-dd)
%D{%f} - day of the month
%l or %y - The line (tty) the user is logged in on, without /dev/ prefix.
颜色

%F{237} 256 color number
%F{red} 8 color name (black, red, green, yellow, blue, magenta, cyan, white)
$FG[237] (notice the $ sign instead of %) 256 color number
$fg[red] (notice the $ and lower case fg) 8 color name (black, red, green, yellow, blue, magenta, cyan, white)
%{$fg_bold[blue]%} bold variants
%F is Foreground color, $f for resetting foreground color
%K is bacKground color, %k for resetting background-color
$reset_color is a Zsh variable that resets the color of the output
You can use Unicode for symbols
%E Clear to end of the line.
%U (%u) to Start (stop) underline mode.
高级

%{...%} 来表示提示符替换序列。这些序列允许在提示符中插入颜色、样式和其他特殊文本，以实现个性化的终端显示。例如 %{$fg[red]%} 表示将后面的文本显示为红色。
%(condition.true-text.false-text) 来进行条件判断，并在满足条件时显示 true-text，不满足条件时显示 false-text。
%? 来获取上一个命令的退出状态码，并根据退出状态码进行条件判断。例如 %{$fg_bold[red]%}%(?..[%?]) 可以在上一个命令返回非零状态码时显示状态码，否则不显示。
%F{code} 和 %f 来设置异步命令的前景色。可以使用它们来在命令执行期间改变命令输出的颜色。
$underline 表示下划线文本
$blink 表示闪烁文本
%# 可以显示当前 Zsh 会话中已执行的命令数。
%B%> 可以显示一个右提示符，通常用于辅助显示长命令或多行命令输入。
%B%{...%} 来添加颜色和样式到自动补全提示符。
%h 显示当前历史命令
%! 可以显示最近执行的历史命令。
%d 表示目录堆栈的深度，这对于有多个目录切换的情况下很有用。
%{%} 表示宽度适应，当终端窗口变窄时，可以隐藏长路径等。
\\ 表示插入逃逸字符，从而显示特殊字符，例如 $、% 等，这个逃逸字符我试了但没有效果
$(date) 表示插入当前日期。
$variable_name 表示变量。例如 $PROMPT 表示一个保存主提示符的变量。
\n 表示换行
\t 表示制表符（Tab）






添加时间到右角

虽然部分标题“在右侧角落添加时间”并不能体现正确的正义性，因为您可以添加您可以添加或已添加到右侧的所有内容，例如用户名、主机名等，但添加时间比这些更有意义元素。

要将时间或任何其他元素添加到右上角，请首先打开 zshrc 文件：

nano ~/.zshrc

在这里，您必须添加一个变量 RPROMPT 并定义要添加的元素。

例如，在这里，我添加了 12 小时格式的时间，因此我的行将如下所示：

RPROMPT="%t"

最终结果如下所示：

看起来很无聊？让我们将文本加粗并着色：

RPROMPT="%F{241}%t%b%f"



---

# Linux - 文件共享 - 挂载samba目录

cifs-utils

```text
# 指定新文件与目录的权限
mount -o username='<用户名称#',password='<登录口令#' //<服务器地址#/<共享目录# <挂载点#
```


```text
# 指定新文件与目录的权限
mount -o username='<用户名称#',password='<登录口令#',fmask=744,dmask=755 //<服务器地址#/<共享目录# <挂载点#
```


```text
# 指定挂载权限
mount -o username='<用户名称#',password='<登录口令#',uid=<用户ID#,gid=<用户组ID# //<服务器地址#/<共享目录# <挂载点#
```


# 自动挂载

``` shell
if ping -c 1 -w 1 baidu.com #/dev/null;then
  echo "ping success"
else
  echo "ping failed"
fi
```

---

# Linux - 网络管理 - Bridge

<!-- TODO

```text
# 启用IPv6
sysctl net.ipv6.conf.br0.disable_ipv6=0

# 开启自动配置
sysctl net.ipv6.conf.br0.autoconf=1

# 接受路由器的RA报文
sysctl net.ipv6.conf.br0.accept_ra=1

# 生成默认路由
sysctl net.ipv6.conf.br0.accept_ra_defrtr=1
```
-->

---

# Linux - 系统备份

## 打包系统文件
### 备份


🔴 示例一：打包备份系统文件。

在本示例中，我们将所有系统文件打包，实现备份。

为了在备份文件的同时保存权限等元数据，我们应当首先选用TAR格式进行打包，再根据实际需要选择压缩算法进行压缩。

```text
[root@Fedora-SRC ~]# tar -cpf /media/backup/Fedora.tar.xz --exclude-from=backup-os-exclude-rule.txt --exclude-ignore=backup-os-exclude-ignore-rule.txt /
```

系统中的部分文件是无需备份的，我们可以通过 `backup-os-exclude-rule.txt` 文件将它们列出：

"backup-os-exclude-rule.txt":

```text
# ESP分区文件（通常不可复用，迁移后需要重新生成。）
/boot/efi/*
# 内存映射文件（系统运行时数据，无需备份。）
/proc/*
/run/*
/sys/*
# 设备文件（不同型号机器的设备列表也不同，一般无需备份。）
/dev/*
# 挂载点（其他存储设备可以单独备份）
/mnt/*
/media/*
/cdrom/*
# 交换文件（系统运行时数据，迁移后需要重新生成。）
/swapfile
# 临时文件（可以按需排除）
/tmp/*
/var/log/*
/lost+found
# 缓存文件（可以按需排除）
/home/*/.cache
/home/*/.local/share/Trash/*
/home/*/.m2
/home/*/.gradle
# 其他无需备份的内容（体积较大、可重新下载的内容，可以按需排除。）
/home/*/.android/avd
/home/*/.android/cache
```

> ⚠️ 警告
>
> 备份文件本身必须被排除，否则递归写入会导致备份分区空间被占满。

`backup-os-exclude-ignore-rule.txt` 文件用于指明被 `backup-os-exclude-rule.txt` 规则命中但需要备份的文件，我们可以按需声明路径，此处省略相关内容。

### 恢复
以下示例展示了使用归档文件恢复系统的方法。

🟠 示例二：从备份文件恢复系统。

在本示例中，我们使用前文“示例一”创建的备份文件，恢复系统。

第一步，我们制作一个与源系统版本相同的LiveCD存储介质，将其插在目标设备上，开启目标设备电源，启动LiveCD存储介质中的系统。

第二步，我们通过LiveCD系统对目标设备存储器进行分区，将目标分区挂载至LiveCD系统的任意目录，并解压备份文件至目标分区。

此处目标分区为 `/dev/sda2` ，我们将其挂载到LiveCD系统的 `/mnt` 目录上。

```text
# 将目标分区挂载至LiveCD系统
[root@LiveCD-DST ~]# mount /dev/sda2 /mnt

# 将备份文件解压至目标分区
[root@LiveCD-DST ~]# tar -xvf /media/backup/Fedora.tar.xz -C /mnt
```

第三步，我们为目标设备生成引导信息。

当备份文件解压完毕后，目标设备中只有系统文件，没有引导文件，此时系统无法正常启动，我们还需要为目标设备生成引导信息。

GRUB生成引导文件时需要读取本机的运行时信息，因此我们首先需要使用 `mount` 命令的 `--bind` 选项，将LiveCD系统中的 `/dev` 等分区同步到目标系统中。

在本示例中， `/dev/sda1` 是ESP分区，用于存放EFI引导文件。

```text
# 挂载ESP分区
[root@LiveCD-DST ~]# mount /dev/sda1 /mnt/boot/efi

# 将LiveCD系统中的部分文件同步至目标系统中
[root@LiveCD-DST ~]# mount --rbind /dev /mnt/dev
[root@LiveCD-DST ~]# mount --rbind /proc /mnt/proc
[root@LiveCD-DST ~]# mount --rbind /sys /mnt/sys
``` 

接着我们通过 `chroot` 命令，进入目标系统的Shell，为其生成引导信息。

```text
# 进入目标系统的Shell
[root@LiveCD-DST ~]# chroot /mnt

# 生成引导信息
#
# 以下命令适用于Ubuntu系列系统
[root@Fedora-DST ~]# update-grub

# 以下命令适用于所有系统
[root@Fedora-DST ~]# grub-install --target=x86_64-efi --bootloader-id='GRUB on Fedora' --efi-directory=/boot/efi --removable /dev/sda
[root@Fedora-DST ~]# grub-mkconfig -o /boot/grub/grub.cfg
``` 

`update-grub` 命令是Ubuntu系列系统提供的快捷命令，可以自动更新GRUB信息；对于其他发行版，如果并未提供此类命令，我们需要手动执行 `grub-install` 和 `grub-mkconfig` 命令更新GRUB信息。

第四步，我们需要检查目标系统，将所有与源设备有关的信息变更为新设备的信息。

```text
# 查看目标分区信息
[root@Fedora-DST ~]# lsblk -f | grep "sda"
sda
├─sda1 vfat   FAT16 ESP    FCBE-CE25                             108.7M    15% /boot/efi
└─sda2 xfs          Fedora ab5c287b-8bf6-4fb1-a664-58da8b15c25a  113.1G    12% /

# 更新"/etc/fstab"文件记录
[root@Fedora-DST ~]# vim /etc/fstab
# 更新分区ID、文件系统等信息
UUID=FCBE-CE25                             /boot/efi  vfat  umask=0077,shortname=winnt 0 2
UUID=ab5c287b-8bf6-4fb1-a664-58da8b15c25a  /          xfs   defaults                   0 0
``` 

第五步，我们卸载目标系统分区，拔出LiveCD存储介质并重启，尝试进入目标系统。

```text
# 退出"chroot"环境
[root@Fedora-DST ~]# exit

# 卸载所有分区
[root@LiveCD-DST ~]# umount -fR /mnt

# 拔出LiveCD存储介质并重启
[root@LiveCD-DST ~]# reboot
``` 

> 🚩 提示
>
> 上述示例中的步骤适用于源系统损坏或跨机器恢复的情况，如果源系统仍然能够正常启动，我们可以使用"root"用户登录系统并解压备份文件，直接覆盖现有文件完成恢复。


---

# Windows - 部署管理 - 使用dism对系统镜像进行自定义

1. 背景
重装系统后，驱动和补丁的安装往往非常耗费时间，并且由于较新的主板使用XHCI标准，安装Windows 7时由于没有集成相应驱动，会导致USB接口不能工作，使用非常不便。借助Windows自带的部署管理工具dism，我们可以很方便的集成自定义组件到系统安装镜像中。

1. 操作步骤
1.首先提取原版镜像sources目录中的install.wim文件到任意位置。
2.创建一个空文件夹，用于装载wim文件。（例如D:\temp）
3.以“管理员”身份打开命令提示符，输入命令挂载镜像：
C:/>dism /mount-wim /wimfile:[install.wim路径] /index:[映像索引] /mountdir:[挂载点]
4.开始整合驱动程序：
C:/>dism /image:[挂载点] /add-driver /driver:[驱动所在路径] {/recurse} {/forceunsigned}
{/recurse}：表示搜索该文件夹及子文件夹下的所有驱动。
{/forceunsigned}：表示强制整合未经数字签名的程序。
5.检查驱动程序：
C:/>dism /image:[挂载点] /get-drivers
6.开始整合系统补丁(msu文件)：
C:/>dism /image:[挂载点] /add-package /packagepath:[存放补丁的文件夹]
7.提交更改并卸载镜像
C:/>dism /unmount-wim /mountdir:[挂载点] /commit
8.用UltraISO等软件编辑ISO文件，用修改后的install.wim替换原镜像sources目录中的install.wim，重新保存为新的ISO。



---

# Windows - 用户管理 - 自动登录

没有密码的本地账户开机后可以自动登录直接进入桌面，拥有密码的本地账户和在线账户则需要由用户手动输入密码登录，有时我们希望使得所有账户都能自动登录，免于手动输入密码，可以通过以下操作步骤实现：

按下 `Windows + R` 组合键，在弹出的“运行”对话框中输入 `netplwiz` 或 `control userpasswords2` 并按下确认键。


在2004之前的版本中，可以在运行里输入或者
然后在用户账户设置界面，取消勾选“要使用本计算机，用户必须输入用户名和密码”
再输入两次密码，确认设置就可以实现自动登录。
在2004的版本上，输入netplwiz或者control userpasswords2之后



按下 `Windows + R` 组合键，在弹出的“运行”对话框中输入 `regedit` 并按下确认键，打开“注册表编辑器”。


`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\PasswordLess\Device` ，将 `DevicePasswordLessBuildVersion` 键的值改为

上述操作也可以通过以下注册表脚本完成：

```text
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\PasswordLess\Device]
"DevicePasswordLessBuildVersion"=dword:00000000
```

我们可以将上述代码块中所示的文本内容保存为".reg"文件，并通过双击鼠标左键执行该脚本。

---

# Windows - 桌面技巧 - 注册表脚本的编写规则

注册表脚本是后缀为".reg"的文本文件。


首先新建一个文本文档，并将文件后缀的.txt改为.reg，然后右键编辑，这样就可以开始编写注册表文件了。

分号(;)后面的内容是注释，导入时会忽略这些内容。

文件的开头

Windows Registry Editor Version 5.00。并与后面的内容隔一行，文件最后还要有一个回车。

新建一个项：

[HKEY_LOCAL_MACHINE\SYSTEM\rcbb]

;在System下新建rcbb项

删除一个项：

[-HKEY_LOCAL_MACHINE\SYSTEM\rcbb] ;删除项rcbb

新建一个键值

[HKEY_LOCAL_MACHINE\SYSTEM\rcbb]

"RCBB"=dword:00000001

;在rcbb项下新建一个名字为RCBB，类型为DWORD，值为00000001的键值，如果项rcbb不存在则新建项rcbb，再新建键值RCBB，如果原来已存在键值RCBB，则用新的值覆盖原键值。

删除一个键值：

[KEY_LOCAL_MACHINE\SYSTEM\rcbb]

"rcbb"=-

在创建字符串类型的键值时，如果该字符串中包含路径分隔符，这个路径分隔符要用双斜杠“\\"表示，如：

[HKEY_LOCAL_MACHINE\SYSTEM\rcbb]

"RCBB"="C:\\test\\wo.exe"

这里文件类型有以下几种：

1、Dword，用dword表示

2、十六进制，用hex表示

3、 字符串，用reg_sz表示，添加时直接用引号接内容

4、二进制，用reg_binary表示

5、多行字符串值，用reg_multi_sz表示

6、可扩展字符串值，用reg_expand_sz表示

若键值名为“默认”，用@，没有引号，如：

@=dword:00000001

如果值中有中文，则需要将.reg文件以ascii编码保存，否则会出现乱码。


---

# Windows - 桌面技巧 - 目录 (Directory) 与文件夹 (Folder) 的区别

在 Windows 系统中，我们经常会见到「目录」和「文件夹」两个名词，但很多人会这两个概念混用，甚至搞不清楚它们的区别，包括写这篇博文的我，之前也是一样。同样表示「文件夹」的概念，为什么会有两个说法？事实上，这两个词不仅仅是在中文中，在英文原文中，也是有两个不同的词汇，Directory 和 Folder。通常，Directory 被翻译成「目录」，而 Folder 被翻译成「文件夹」。但实际的情况是，很多情况下，这两个的翻译都比较混乱，Directory 也经常被翻译为「文件夹」。那么微软使用 Directory 和 Folder 这两个名词到底什么不同的意义和差异呢？这个问题我多年也没搞清楚，直到最近又在网上搜索资料，并自己进行一些测试后，才发现他们的细微差别。

首先，作为一个 Windows 开发人员，注册表、文件关联等都应该是了解的。那么大家应该都知道，在 Windows 的注册表编辑器中的 HKEY_CLASSES_ROOT 节点下面，有 Directory 和 Folder 两个子键，类似其他的 ProgId 子键，支持在其 shell 子键添加自定义的动作和命令。有一天我突发奇想，如果我分别在这两个位置添加一个动作项，系统该如何显示它们？于是我分别在不同的位置单独添加注册表项，然后观察右键菜单，发现了其中的秘密：

仅在 HKEY_CLASSES_ROOT\Directory\shell 下面随便添加一个节点，如 action，我分别在「计算机」、「回收站」、「计算机」中的任意驱动器、普通文件夹上点击右键，只有普通的文件夹右键菜单中出现了 action 这一菜单项。

仅在 HKEY_CLASSES_ROOT\Folder\shell 下面随便添加一个节点，如 action，我分别在「计算机」、「回收站」、「计算机」中的任意驱动器、普通文件夹上点击右键，所有这些项目的右键菜单中均出现了 action 这一菜单项。

仅在 HKEY_CLASSES_ROOT\Drive\shell 下面随便添加一个节点，如 action，我分别在「计算机」、「回收站」、「计算机」中的任意驱动器、普通文件夹上点击右键，只有驱动器盘符右键菜单中出现了 action 这一菜单项。

如此看来，Folder 的范围其实是很大的，它包括了系统中所有可以双击打开并查看其内容的「文件夹」项目，包括「计算机」、「回收站」、「控制面板」等这些虚拟文件夹，以及「计算机」中的所有磁盘驱动器，以及其中的任何文件夹 (Directory)。

而 Directory 的概念则小的很多，它必须是存在于物理磁盘上的一个「文件夹」项目，而「计算机」中的所有磁盘驱动器，如「本地磁盘 (C:)」则不认为是 Directory。

总结：如果是开发外壳扩展 dll，最好根据需要写入到正确的子键下面，不要在 Directory 和 Folder 等子键下乱写一通。虽然有的外壳扩展不支持虚拟文件夹，写在 Directory 下系统也并不会加载，但还是希望各位开发人员能够正确遵守规范。



---

# Windows - 桌面技巧 - 在Windows Server 2012/2016/2019上开启硬盘监控页面

从windows server 2012开始，微软修改了任务管理器的显示方式，图像化看起来更直观了，但是可惜的是，默认情况下，2012和2016均只显示CPU/内存/网络三个资源监视，没有重要的磁盘，这对于经常测试性能的来说，是及其不方便的，但是我们可以通过命令来开启监控，下面就讲解开启方法。
实际操作

Win+R 打开CMD（不是管理员的话请以管理员身份打开）

输入以下命令
diskperf -y

---

# Windows - 桌面技巧 - DISM清理报错

该问题出现于 Win10 2004/20H2(2009) 高版本系统，出错原因未知，猜测是清理规则冲突，可以在日志中看到清理WER等规则失败，无其他报错。

因为Dism++相当于对dism.exe的GUI封装，因此尝试直接运行命令分析清理

分析命令（管理员权限）

Dism.exe /Online /Cleanup-Image /AnalyzeComponentStore

PowerShell
全屏

清理命令（管理员权限）

Dism.exe /Online /Cleanup-Image /StartComponentCleanup

PowerShell
全屏

清理完成后重新执行 Dism++ 清理 WinSxS 成功。

为什么需要手动执行一次命令的原因暂不清楚。

---

# Windows - 桌面技巧 - 远程桌面客户端报错

远程桌面客户端打不开：
下载官方重新安装工具：
https://learn.microsoft.com/zh-cn/windows-server/remote/remote-desktop-services/clients/uninstall-remote-desktop-connection


---

# Windows - 桌面技巧 - 创建指向远程目录的链接

因为某些原因，设计好的目录结构是不能动的，因此需要将网络共享目录挂载到指定目录下，以便扩容。
在Linux下这完全没有问题，但是Windows下的操作就稍微复杂一点。

1、直接使用net use Z: \\host\shareddir这种方式映射目录到Z盘，然后再在指定目录下建立一个软链接到Z，这是可以的。
2、可以直接使用mklink /D localdir \\host\shareddir方式建立软链接到共享目录。

部分软件不支持网络驱动器，此时只有方法2可用。
