# Android - 核心能力 - 软件包管理

# 简介
<!-- TODO -->





# 调试命令
## 语法
我们可以通过ADB Shell管理软件包，以便进行调试与测试。

下文将介绍常用的软件包管理命令。

🔶 查询软件包列表

以下命令可以列出设备中安装的软件包列表：

```text
ADB$ pm list packages [选项] [--user <用户ID>]
```

当我们省略选项与用户ID时，该命令将输出所有用户的软件包名称。

该命令的常用选项如下文列表所示：

- `-s` : 筛选系统软件。
- `-3` : 筛选非系统软件。
- `-d` : 筛选已被禁用的软件。
- `-e` : 筛选已被启用的软件。
- `-i` : 显示安装来源。
- `-f` : 显示安装位置。

🔶 查询软件包的安装位置

以下命令可以列出指定软件包的安装位置：

```text
ADB$ pm path [--user <用户ID>] <软件包名称>
```

如果软件包有预装的版本和升级安装的版本，该命令将会输出多条结果。

🔶 查询软件包详情

以下命令可以输出软件包的详细信息：

```text
ADB$ dumpsys package [软件包名称]

ADB$ pm dump <软件包名称>
```

`dumpsys package` 命令能够输出软件包的基本信息，主要包括下文列表中的内容：

- 版本号 : `versionCode=<数字版本号>` 、 `versionName=<文本版本号>` 。
- 签名摘要 : `signatures=<签名信息>` 。
- UID分配情况 : `userId=<UID>` 。
- SDK版本信息 : `minSdk=<版本号>` 、 `targetSdk=<版本号>` 。
- 数据目录 : `dataDir=<目录>` 、 `codePath=<目录>` 、 `resourcePath=<目录>` 。
- 权限授予情况 : `requested permissions:` 、 `install permissions:` 和 `runtime permissions:` 。

`pm dump` 命令能够输出软件包的详细信息，包括组件信息、资源使用情况等。

🔶 查询系统支持的特性

以下命令可以查询当前设备支持的特性：

```text
# 列出所有特性
ADB$ pm list features

# 判断当前设备是否支持某种特性
ADB$ pm has-feature <特性名称>
```

### 示例
下文示例展示了通过命令管理软件包的方法。

<!--
要查看某个软件的详细信息，可以通过 ADB 命令查询（红色部分为软件包名称，自行替换，下同）。

# 查看软件详细信息
.\adb.exe shell dumpsys package com.mipay.wallet


通过 ADB 命令停止软件运行

在禁用或卸载软件之前，最好先停止软件运行。

.\adb.exe shell am force-stop com.mipay.wallet

通过 ADB 命令禁用软件

禁用是比直接卸载更好的选择，它可以在需要时恢复。例如禁用“小米钱包”软件，禁用后手机上就看不到了。

.\adb.exe shell pm disable-user com.mipay.wallet

如果要恢复软件，使用下面命令。

.\adb.exe shell pm enable com.mipay.wallet

通过 ADB 命令卸载软件

如果一定要卸载删除软件，使用下面命令。

.\adb.exe shell pm uninstall -k --user 0 com.mipay.wallet

在完成操作后，用 .\adb.exe reboot 命令重启手机。
```

-->



# 版本变更
## 索引

<div align="center">

|       序号        |    版本    |                     摘要                     |
| :---------------: | :--------: | :------------------------------------------: |
| [变更一](#变更一) | Android 11 | 查询其他软件包信息时，需要声明软件包可见性。 |

</div>

## 变更一
### 摘要
自从Android 11开始，应用程序需要声明软件包可见性，才能查询其他应用程序的信息。

### 详情
自从Android 11开始，如果应用程序需要查询其他应用程序的信息，则需要在Manifest文件中声明目标程序的包名，否则会出现 `NameNotFoundException` 等异常。

我们可以通过以下配置项声明需要查询的应用程序包名：

"AndroidManifest.xml":

```xml
<manifest>
    <queries>
        <package android:name="<目标软件包的包名1>" />
        <package android:name="<目标软件包的包名2>" />
    </queries>
</manifest>
```

如果我们需要查询所有软件包的信息，则可以声明以下权限：

"AndroidManifest.xml":

```xml
<manifest>
    <!-- 查询所有软件包的信息  -->
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES" />
</manifest>
```

关于软件包可见性的详细信息，可以参考以下链接：

- [🔗 Android官方文档 - 软件包可见性](https://developer.android.com/training/package-visibility)
- [🔗 Android官方文档 - 版本变更记录](https://developer.android.com/about/versions/11/privacy/package-visibility)







---

# Android - 核心能力 - 用户管理




1.前言：

通过分离用户帐号和应用数据，Android 支持在一台 Android 设备上添加多个用户。例如，父母可能会允许他们的孩子使用家庭平板电脑，一个家庭可以共用一辆汽车。Android Automotive 依靠 Android 的多用户实现来提供共用设备体验。
1.1 多用户涉及的文件路径：
路径	系统路径（可选）	用途
/data/user/{userId}/{app.path}	/data/data	应用存储空间
/storage/emulated/{userId}	/sdcard	共享内部存储空间
/data/media/{userId}	无	用户媒体数据（例如，音乐和视频）
/data/system/users/{userId}	无	每个用户的系统配置/状态只能由系统应用访问






# 调试命令
## 语法
我们可以通过ADB Shell管理用户，以便进行调试与测试。

下文内容将介绍常用的用户管理命令：

🔶 查询用户列表

以下命令可以列出设备中的用户列表：

```text
ADB$ pm list users
```

🔶 创建用户

以下命令可以创建新的用户：

```text
ADB$ pm create-user <用户名称>
```

🔶 删除用户

以下命令可以删除已存在的用户：

```text
ADB$ pm remove-user <用户ID>
```

🔶 切换用户

以下命令可以从当前用户切换至指定的用户：

```text
ADB$ am switch-user <用户ID>
```

🔶 启动用户

以下命令可以使指定用户在后台运行，但暂不切换当前用户：

```text
ADB$ am start-user <用户ID>
```

🔶 获取前台用户的ID

以下命令可以获取当前前台用户的ID：

```text
ADB$ am get-current-user
```





注意：shell 命令下查看的都是userid 为0的路径。查看其它用户的目录权限受限 ：


uid: android中uid用于标识一个应用程序，uid在应用安装时被分配，并且在应用存在于手机上期间，都不会改变。一个应用程序只能有一个uid，多个应用可以使用sharedUserId 方式共享同一个uid，前提是这些应用的签名要相同。


1|generic_x86_64:/ # ps -A | grep hello
u0_a116       4173  1739 3890064 140760 SyS_epoll_wait      0 S net.bi4vmr.study.overview.helloworld


这个 u0_a106 就表示该应用是 user 0（主用户）下面的应用，id是 106，前面说过 普通应用程序的UID 都是从 10000开始的，所以 最终计算出的 UID 就是 10106。
多用户情况下的 UID 计算类似：
在这里插入图片描述
可以看到 工作用户的 userID 是 14，后面是一样的。计算方式是：
所以最后 工作空间内应用的 UID 是 100000 * 14 + 10106 = 1410106

通过uid获取包名，通过包名获取uid

    通过包名获取UID

        PackageManager mPm = getPackageManager();
        try {
            ApplicationInfo applicationInfo = mPm.getApplicationInfo("com.tencent.mm", 0);
            int uid = applicationInfo.uid;
            Toast.makeText(MainActivity.this, "" + uid, Toast.LENGTH_SHORT).show();
        }catch (Exception e){
            e.printStackTrace();
        }


    通过 UID 获取包名

String packagename = getPackageManager().getNameForUid(uid);

4.设置自己的应用UID为系统进程的UID

系统进程UID有三种：

android:sharedUserId=“android.uid.system”
android:sharedUserId=“android.uid.shared”
android:sharedUserId=“android.media”
我们这里取第一种来实验下，其他两种实现的方式都一样。
4.1 声明UID

首先我们需要在manifest中声明该应用的UID：

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="cn.izis.chessdeskrobot"
    android:sharedUserId="android.uid.system"
    >
...
</manifest>




安装在设备中的每一个apk文件，Android给每个APK进程分配一个单独的用户空间,其manifest中的userid就是对应一个Linux用户都会被分配到一个属于自己的统一的Linux用户ID，并且为它创建一个沙箱，以防止影响其他应用程序（或者其他应用程序影响它）。用户ID 在应用程序安装到设备中时被分配，并且在这个设备中保持它的永久性。
通过Shared User id,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样.

UID在linux中就是用户的ID，表明时哪个用户运行了这个程序，主要用于权限的管理。而在android 中又有所不同，因为android为单用户系统，这时UID 便被赋予了新的使命，数据共享，为了实现数据共享，android为每个应用几乎都分配了不同的UID，不像传统的linux，每个用户相同就为之分配相 同的UID。（当然这也就表明了一个问题，android只能时单用户系统，在设计之初就被他们的工程师给阉割了多用户），使之成了数据共享的工具。

因此在android中PID，和UID都是用来识别应用程序的身份的，但UID是为了不同的程序来使用共享的数据。
对于一个APK来说，如果要使用某个共享UID的话，必须做一下两部步：
1、相同的在Manifest节点中增加android:sharedUserId属性。
2、相同的在Android.mk中增加LOCAL_CERTIFICATE的定义。（既签名相同）

如果有看系统源码的同学，可以看到一些系统应用就是这样：
系统中所有使用android.uid.system作为共享UID的APK，都会首先在manifest节点中增加 android:sharedUserId=“android.uid.system”，然后在Android.mk中增加 LOCAL_CERTIFICATE := platform。可以参见Settings等

系统中所有使用android.uid.shared作为共享UID的APK，都会在manifest节点中增加 android:sharedUserId=“android.uid.shared”，然后在Android.mk中增加 LOCAL_CERTIFICATE := shared。可以参见Launcher等

系统中所有使用android.media作为共享UID的APK，都会在manifest节点中增加 android:sharedUserId=“android.media”，然后在Android.mk中增加LOCAL_CERTIFICATE := media。可以参见Gallery等。

关于签名：
build/target/product/security目录中有四组默认签名供Android.mk在编译APK使用：

1、testkey：普通APK，默认情况下使用。
2、platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试，这种方式编译出来的APK所在进程的UID为system。
3、shared：该APK需要和home/contacts进程共享数据。
4、media：该APK是media/download系统中的一环。


---

# Android - 网络通讯 - 禁止应用联网



#通过包名查找应用的uid
➜  apk adb shell cat /data/system/packages.xml | grep com.xzh.hbls
    <package name="com.xzh.hbls" codePath="/data/app/com.xzh.hbls-htP4fJSjJ2QQGmIifZ6xpA==" nativeLibraryPath="/data/app/com.xzh.hbls-htP4fJSjJ2QQGmIifZ6xpA==/lib" publicFlags="940064324" privateFlags="0" ft="177e2c42790" it="177e2c434ca" ut="177e2c434ca" version="80" userId="10106">
#关闭某个uid的上网权限
➜  apk adb shell iptables -I fw_OUTPUT -m owner --uid-owner 10106 -j DROP
➜  apk adb shell iptables -I fw_INPUT -m owner --uid-owner 10106 -j DROP


iptables是Linux的一个命令行工具,通过设置一些规则可以直接把指定uid或网址的数据包从ip层过滤掉，从而实现网络防火墙的功能，这部分已经比较成熟,android或厂商只是对iptables命令进行了封装,让android app可以通过iptables命令进行防火墙设置，iptables有很多复杂的功能,我们主要看看怎么设置白名单只让指定的uid app可以联网和设置黑名单让指定的uid app不能联网,我们通过代码流程来分析,代码是mtk android8.1。

root后通过adb shell iptables -L可以查看当前的规则列表，Chain INPUT，OUTPUT就是控制数据包的输入输出，没做任何设置前应该张下面这个样子，Chain OUTPUT的数据包通过Chain fw_OUTPUT控制, Chain fw_OUTPUT的规则是空的，所以当前对网络不做限制。



---

# Android - 核心能力 - 按键管理

# 监听是否点击了home键或者锁屏键

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        IntentFilter filter = new IntentFilter();
        //锁屏广播，由系统发出
        filter.addAction(Intent.ACTION_SCREEN_ON);
        //锁屏广播，由系统发出
        filter.addAction(Intent.ACTION_SCREEN_OFF);
        //点击home键广播，由系统发出
        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
        registerReceiver(homeAndLockReceiver, filter);
    }

    /**
     * 监听是否点击了home键将客户端推到后台
     */
    private BroadcastReceiver homeAndLockReceiver = new BroadcastReceiver() {
        String SYSTEM_REASON = "reason";
        String SYSTEM_HOME_KEY = "homekey";

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {
                String reason = intent.getStringExtra(SYSTEM_REASON);
                if (TextUtils.equals(reason, SYSTEM_HOME_KEY)) {
                    //表示按了home键,程序到了后台
                    Toast.makeText(getApplicationContext(), "home", Toast.LENGTH_SHORT).show();
                }
            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
                //屏幕亮了
                Log.i("lock-", "--on");

            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
                //屏幕黑了
                Log.i("lock-", "--off");
            }
        }
    };
}


# 调试命令

//这条命令相当于按了设备的Backkey键
adb shell input keyevent 4

//可以解锁屏幕

adb shell input keyevent  82 

 

每个数字与keycode对应表如下：
0 -->  "KEYCODE_UNKNOWN"
1 -->  "KEYCODE_MENU"
2 -->  "KEYCODE_SOFT_RIGHT"
3 -->  "KEYCODE_HOME"
4 -->  "KEYCODE_BACK"
5 -->  "KEYCODE_CALL"
6 -->  "KEYCODE_ENDCALL"
7 -->  "KEYCODE_0"
8 -->  "KEYCODE_1"
9 -->  "KEYCODE_2"
10 -->  "KEYCODE_3"
11 -->  "KEYCODE_4"
12 -->  "KEYCODE_5"
13 -->  "KEYCODE_6"
14 -->  "KEYCODE_7"
15 -->  "KEYCODE_8"
16 -->  "KEYCODE_9"
17 -->  "KEYCODE_STAR"
18 -->  "KEYCODE_POUND"
19 -->  "KEYCODE_DPAD_UP"
20 -->  "KEYCODE_DPAD_DOWN"
21 -->  "KEYCODE_DPAD_LEFT"
22 -->  "KEYCODE_DPAD_RIGHT"
23 -->  "KEYCODE_DPAD_CENTER"
24 -->  "KEYCODE_VOLUME_UP"
25 -->  "KEYCODE_VOLUME_DOWN"
26 -->  "KEYCODE_POWER"
27 -->  "KEYCODE_CAMERA"
28 -->  "KEYCODE_CLEAR"
29 -->  "KEYCODE_A"
30 -->  "KEYCODE_B"
31 -->  "KEYCODE_C"
32 -->  "KEYCODE_D"
33 -->  "KEYCODE_E"
34 -->  "KEYCODE_F"
35 -->  "KEYCODE_G"
36 -->  "KEYCODE_H"
37 -->  "KEYCODE_I"
38 -->  "KEYCODE_J"
39 -->  "KEYCODE_K"
40 -->  "KEYCODE_L"
41 -->  "KEYCODE_M"
42 -->  "KEYCODE_N"
43 -->  "KEYCODE_O"
44 -->  "KEYCODE_P"
45 -->  "KEYCODE_Q"
46 -->  "KEYCODE_R"
47 -->  "KEYCODE_S"
48 -->  "KEYCODE_T"
49 -->  "KEYCODE_U"
50 -->  "KEYCODE_V"
51 -->  "KEYCODE_W"
52 -->  "KEYCODE_X"
53 -->  "KEYCODE_Y"
54 -->  "KEYCODE_Z"
55 -->  "KEYCODE_COMMA"
56 -->  "KEYCODE_PERIOD"
57 -->  "KEYCODE_ALT_LEFT"
58 -->  "KEYCODE_ALT_RIGHT"
59 -->  "KEYCODE_SHIFT_LEFT"
60 -->  "KEYCODE_SHIFT_RIGHT"
61 -->  "KEYCODE_TAB"
62 -->  "KEYCODE_SPACE"
63 -->  "KEYCODE_SYM"
64 -->  "KEYCODE_EXPLORER"
65 -->  "KEYCODE_ENVELOPE"
66 -->  "KEYCODE_ENTER"
67 -->  "KEYCODE_DEL"
68 -->  "KEYCODE_GRAVE"
69 -->  "KEYCODE_MINUS"
70 -->  "KEYCODE_EQUALS"
71 -->  "KEYCODE_LEFT_BRACKET"
72 -->  "KEYCODE_RIGHT_BRACKET"
73 -->  "KEYCODE_BACKSLASH"
74 -->  "KEYCODE_SEMICOLON"
75 -->  "KEYCODE_APOSTROPHE"
76 -->  "KEYCODE_SLASH"
77 -->  "KEYCODE_AT"
78 -->  "KEYCODE_NUM"
79 -->  "KEYCODE_HEADSETHOOK"
80 -->  "KEYCODE_FOCUS"
81 -->  "KEYCODE_PLUS"
82 -->  "KEYCODE_MENU"
83 -->  "KEYCODE_NOTIFICATION"
84 -->  "KEYCODE_SEARCH"
85 -->  "TAG_LAST_KEYCODE"





---

# Android - 系统组件 - 通用能力

# 时间设置


//读取
Settings.System.getString(Context.getContentResolver(), Settings.System.TIME_12_24, "12");

//设置
Settings.System.putString(Context.getContentResolver(),Settings.System.TIME_12_24, "24");



//查询：
adb shell settings get system time_12_24

//设置24小时制:

adb shell settings set system time_12_24 24




# 常用注解




---

# Android - 多媒体 - 音频

# 耳机拔出事件


AudioManager.ACTION_AUDIO_BECOMING_NOISY介绍

    广播intent，提示应用程序音频信号由于音频输出的变化将变得“嘈杂”。
    例如，当拔出一个有线耳机，或断开一个支持A2DP的音频接收器，这个intent就会被发送，且音频系统将自动切换音频线路到扬声器。收到这个intent后，控制音频流的应用程序会考虑暂停，减小音量或其他措施，以免扬声器的声音使用户惊奇。


---

# Android - 核心能力 - 进程管理

是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。


1、一个app只运行在一个进程中，进程名字为包名。
2、一个service（所有组件都一样）只作为一个线程运行在app的进程中，没有自己独立的进程。


1、设置了这行代码，系统就会为service创建新的进程
      service将运行在这个新的独立的进程，它所在的apk依旧运行在原来进程。这样就实现了Android使用多进程
2、属性值可以随意定义
       xxxx是自定义的，上面代码的remote是随便写的
3、当属性值以冒号开头   ：，如 android:process  = “ :xxxx ”
       表示：将为 app 创建一个私有进程，其他 app 无法访问，进程名称是：包名: xxxx
4、当属性值以小写字母开头，如 android:process = “xxxx”
       表示：这个进程是对外公开的，其他app可以访问它，进程名称是：xxxx


注意：a）<application> 和四大组件节点都可设置
             b）设置<application android:process="xxx:xxx"> 可以指定app的进程名称
             c）若<application> 节点和四大组件都设置了android:process="xxx:xxxx"属性，以组件的属性为准
重点来了，因为设置了 android:process 属性将组件运行到另一个进程，相当于另一个应用程序，所以在另一个线程中也将新建一个 Application 的实例。因此，每新建一个进程 Application 的 onCreate 都将被调用一次。 如果在 Application 的 onCreate 中有许多初始化工作并且需要根据进程来区分的，那就需要特别注意了。

方案1
public static String getProcessName(Context cxt, int pid) {  
    ActivityManager am = (ActivityManager) cxt.getSystemService(Context.ACTIVITY_SERVICE);  
    List<RunningAppProcessInfo> runningApps = am.getRunningAppProcesses();  
    if (runningApps == null) {  
        return null;  
    }  
    for (RunningAppProcessInfo procInfo : runningApps) {  
        if (procInfo.pid == pid) {  
            return procInfo.processName;  
        }  
    }  
    return null;  
}  
目前网上主流的方法，但效率没有方案2高，感谢由王燚同学提供的方案2
 
方案2
public static String getProcessName() {
  try {
    File file = new File("/proc/" + android.os.Process.myPid() + "/" + "cmdline");
    BufferedReader mBufferedReader = new BufferedReader(new FileReader(file));
    String processName = mBufferedReader.readLine().trim();
    mBufferedReader.close();
    return processName;
  } catch (Exception e) {
    e.printStackTrace();
    return null;
  }
}
然后在 Application 的 onCreate 中获取进程名称并进行相应的判断，例如：
 
String processName = getProcessName(this, android.os.Process.myPid());
 
if (!TextUtils.isEmpty(processName) && processName.equals(this.getPackageName())) {//判断进程名，保证只有主进程运行
    //主进程初始化逻辑
    ....
}


---

# Android -> 用户界面 -> 素材与资源 -> 概述

# 引用资源


# 资源后缀



---

# Android -> 用户界面 -> 素材与资源 -> 文本资源

## RTL布局
自从API版本17开始，Android支持RTL功能，能够根据语言配置自动适应用户的阅读习惯。一般来说，文本按照从左到右的顺序阅读，此时"start"属性等同于"left"，"end"属性等同于"right"；对于从右到左阅读的语言，"start"相当于"right"，"end"相当于"left"。


```xml
<application
    android:supportsRtl="true">
```

---

# Android -> 用户界面 -> 素材与资源 -> 图像

# 简介

drawable-mdpi drawable-xdpi

除此之外，还有两个限定符为，例如 drawable-nodpi 存放与像素密度无关的资源。无论当前屏幕的像素密度如何，系统都不会缩放使用此限定符标记的资源。和 drawable-anydpi 资源优先于任何dpi得到使用。



android系统适配Drawable时会首先查找屏幕密度尺寸都满足的drawable，如果没有找到：
 当应用在设备对应dpi目录下没有找到某个资源时，遵循“先高再低”原则，然后按比例缩放图片如果当前为xhdpi设备（项目中只有xxhdpi,xhdpi,xxhdpi,nodpi,mdpi,hdpi），则drawable的寻找顺序为，首先查找xhdpi目录 如果没找到，依然查找xxhdpi,如果还没有找到xxxhdpi,还没有找到查找nodpi，如果还没有查找hdpi，然后查找mdpi，如果在xxhdpi中找到目标图片，则压缩2/3来使用（因为系统认为它找到了一个比合适尺寸大的图片），如果在mdpi中找到图片，则放大2倍来使用（系统认为它找到了一个比适合尺寸小的图片，需要放大才能保证正常）。



---

# Android -> 用户界面 -> 素材与资源 -> 样式

# 主题
## 默认主题

<!-- TODO -->

"themes.xml":

```xml
<!-- 自定义主题 -->
<style name="Theme.Custom" parent="Theme.Material3.DayNight.NoActionBar">
    <!-- 覆盖全局属性 -->
    <item name="windowActionBar">false</item>
    <item name="windowNoTitle">true</item>

    <!-- 覆盖各个控件的属性 -->
    <item name="android:textViewStyle">@style/Theme.Custom.TextView</item>
</style>

<!-- 自定义TextView样式 -->
<style name="Theme.Custom.TextView">
    <item name="android:textColor">#00FF00</item>
    <item name="android:textSize">16sp</item>
</style>
```



"AndroidManifest.xml":

```xml
<!-- 应用主题：对所有组件生效 -->
<application
    android:theme="@style/Theme.Default">

    <!-- Activity：仅对当前组件生效 -->
    <activity
        android:name=".theme.TestUITheme"
        android:theme="@style/Theme.Custom" />
</application>
```


## 常用属性

<!-- TODO -->


---

# Android - 数据存储 - SQL - Room

# 注解与配置
## 数据库
### 配置日志模式
SQLite支持以下两种日志模式：

`JournalMode.TRUNCATE` : SQLite的默认日志模式，向存储器写入数据时会阻塞其他读写操作，降低写入并发。

`JournalMode.WRITE_AHEAD_LOGGING` : Room框架的默认模式(API Level > 16时)，WAL模式使得读与写操作之间不会阻塞，只会阻塞写与写操作，能够提高写入并发。

setJournalMode(JournalMode journalMode)
WAL模式比TRUNCATE模式写入速度更快，但由于读取数据时也需要读取WAL日志验证数据的正确性，所以读取数据较慢，我们应当根据实际使用场景进行选择。

# 异步查询
