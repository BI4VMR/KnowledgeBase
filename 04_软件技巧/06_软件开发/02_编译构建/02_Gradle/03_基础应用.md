# 初始化工程
若要创建一个新的Gradle工程，我们首先需要执行 `gradle init` 命令进行初始化。

> 🚩 提示
>
> 本节内容所介绍的初始化方法要求全局安装Gradle，由于我们很少全局安装Gradle，下文提供了另外两种初始化方法：
>
> - 通过IntelliJ IDEA或Android Studio等IDE创建Gradle工程，配置文件将由IDE生成。
> - 如果我们已经熟悉了Gradle工程的结构，可以从现有项目复制文件并进行修改。

Gradle会通过交互式向导询问若干问题，并根据用户的应答生成基本配置文件。

```text
# 新建一个Gradle工程
[bi4vmr@Fedora ~]$ mkdir GradleProject && cd GradleProject

# 初始化工程
[bi4vmr@Fedora GradleProject]$ gradle init

# 选择工程类型
Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4]

# 选择脚本文件语言
# 较新版本推荐使用Kotlin，而早期版本使用Groovy。
Select build script DSL:
  1: Kotlin
  2: Groovy
Enter selection (default: Kotlin) [1..2]

# 指定工程名称
# 该名称将在Gradle中使用，通常与目录名称相同。
Project name (default: project):

# 是否启用新特性
Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no]


> Task :init
To learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.4/samples

BUILD SUCCESSFUL in 36s
2 actionable tasks: 2 executed
```

当初始化命令执行完毕后，将会生成以下文件：

```text
GradleProject
├── build.gradle
├── gradle
│   └── wrapper
│        ├── gradle-wrapper.jar
│        └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
```

`settings.gradle` 文件包含全局属性、子模块声明、仓库声明，默认只有顶层工程拥有该文件； `build.gradle` 文件包含模块的编译配置与依赖声明，通常顶层工程以及每个子模块都拥有一份。编译工程时， `settings.gradle` 的优先级高于 `build.gradle` 。

初始化命令所生成的顶层工程不包含任何子模块，我们可以直接创建 `src/main/java/` 等目录并编写业务代码；如果工程规模较大，我们通常不会直接在顶层工程中进行开发，而是划分多个子模块以便组织代码，详见相关章节： [🧭 模块管理](#模块管理) 。

在IntelliJ IDEA系列IDE中使用Gradle时，每次修改Gradle配置文件后都要执行一次Gradle任务才会生效。当我们使用命令行时，可以执行 `gradle help` 命令；当我们使用IDE GUI时，可以点击Gradle插件中的 `Gradle Sync` 按钮。


# Gradle Wrapper
## 简介
Gradle版本更新较为频繁，新旧版本可能无法相互识别部分配置语法，因此全局安装的版本难以适用于不同的工程。

Gradle Wrapper是工程根目录下的脚本文件，作用是调用指定版本的Gradle程序，通过该脚本我们可以为每个工程配置不同的Gradle版本，这种机制解决了Gradle版本之间的兼容性问题。

当我们通过 `gradle init` 命令初始化工程时，Gradle Wrapper脚本 `gradlew` 、 `gradlew.bat` 与配置文件将会自动生成。其中 `gradlew` 是Linux平台的脚本； `gradlew.bat` 是Windows平台的脚本。

## 配置文件
Gradle Wrapper的配置文件位于： `<工程根目录>/gradle/wrapper/gradle-wrapper.properties` ，它的初始内容如下文代码片段所示：

"gradle-wrapper.properties":

```text
distributionUrl=https\://services.gradle.org/distributions/gradle-7.2-bin.zip
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```

该配置文件的属性含义如下文所示：

🔷 `distributionUrl`

指定Gradle程序的下载地址。

该地址即为Gradle Wrapper脚本所使用的Gradle版本，通过更改其中的版本号，就可以指定当前工程所使用的Gradle程序版本。

🔷 `distributionBase`

指定Gradle程序压缩包解压后程序文件的根目录。

`GRADLE_USER_HOME` 是一个环境变量，它所指向的路径即为Gradle程序与库文件的存储目录。如果该变量不存在，默认的路径为 `<用户主目录>/.gradle/` 。

🔷 `distributionPath`

指定Gradle程序压缩包解压后程序文件的存储目录。

该路径与 `distributionBase` 合并即为Gradle程序压缩包的存储目录，默认的路径为 `<用户主目录>/.gradle/wrapper/dists/` ，与原始压缩包一致。

🔷 `zipStoreBase`

指定Gradle程序压缩包的根目录。

🔷 `zipStorePath`

指定Gradle程序压缩包的存储目录。

该路径与 `zipStoreBase` 合并即为Gradle程序压缩包的存储目录，默认的路径为 `<用户主目录>/.gradle/wrapper/dists/` 。

## 离线安装Gradle程序
每当我们使用工程的Gradle Wrapper脚本执行任务时，若配置文件中指定的Gradle版本未被安装，脚本就会自动下载当前版本。如果此时终端所处的网络环境不佳，下载过程可能会中断，导致无法进行后续的工作。在这种情况下，我们可以手动下载Gradle版本，或者从其他设备复制已有的Gradle版本，跳过自动下载过程。

当新工程初始化时，Gradle会在存储目录中生成一个以随机字符命名的目录，用于存放当前版本的Gradle程序压缩包，例如 `<用户主目录>/.gradle/wrapper/dists/gradle-8.4-bin/2dnblmf4td7x66yl1d74lt32g/` ；我们可以先终止当前的Gradle进程，再删除目录中未下载完全的文件，最后将提前准备好的Gradle版本文件 `gradle-8.4-all.zip` 复制到该目录中。

上述操作完成后，再重新执行Gradle任务，即可跳过下载版本的步骤。


# 模块管理
## 创建模块
在以下示例中，我们将一个工程划分为多个模块，便于组织代码：

- `App` : 应用程序界面实现。
- `Logic` : 应用程序业务实现。
- `Base` : 通用组件。
- `Tool` : 工具组件。

🔴 示例一：通过Gradle管理多模块工程。

在本示例中，我们创建具有多个模块的工程，了解Gradle的模块管理功能。

第一步，我们初始化一个新的Gradle工程，并按照前文规划创建若干目录。

```text
GradleProject
├── app
├── common
│   ├── base
│   └── tool
└── logic
```

Gradle模块的命名通常使用小写字母，当存在多个单词时，以短划线( `-` )分隔，例如： `lib-common` 。

第二步，我们修改工程根目录下的 `settings.gradle` 配置文件，向Gradle注册上述模块。

"settings.gradle":

```groovy
// 声明根目录下的模块
include ':app'
include ':logic'

// 存在层级的模块需要逐级声明
include ':common:base'
include ':common:tool'
```

上述内容也可以使用Kotlin语言编写：

"settings.gradle.kts":

```kotlin
// 声明根目录下的模块
include(":app")
include(":logic")

// 存在层级的模块需要逐级声明
include(":common:base")
include(":common:tool")
```

`include()` 方法用来声明一个模块，模块名称中的冒号( `:` )相当于文件路径中的斜杠( `/` )，例如 `:app` 表示 `<工程根目录>/app` ； `:common:base` 表示 `<工程根目录>/common/base` 。

第三步，为子模块创建Gradle配置文件。

`app` 、 `logic` 、 `base` 、 `tool` 模块用于存放源代码、需要参与编译，我们为它们各自创建一个 `build.gradle` 配置文件，声明模块的类型。

"build.gradle":

```groovy
plugins {
    // 库可定义为 `java-library` 类型，应用程序可使用 `application` 。
    id 'java-library'
}
```

上述内容也可以使用Kotlin语言编写：

"build.gradle.kts":

```kotlin
plugins {
    // 库可定义为 `java-library` 类型，应用程序可使用 `application` 。
    id("java-library")
}
```

此处以Java应用程序为例，我们将 `base` 、 `tool` 和 `logic` 模块配置为 `java-library` 类型，将 `app` 模块配置为 `application` 类型。

`common` 目录只用于存放子模块，不包含源代码、不需要参与编译，因此我们不必为它创建 `build.gradle` 配置文件。

## 导入外部工程
对于规模更大的工程，单工程多模块可能无法满足需求，此时我们可以按照功能划分出多个子工程，例如：将公共组件放置在某个工程中统一维护，并在其他工程中进行引用。

此处我们创建以下目录结构，演示导入外部工程的方法。

```text
Projects
├── Gradle01
│   └── common
└── Gradle02
```

`Gradle01` 和 `Gradle02` 是两个独立的Gradle工程，其中 `Gradle01` 的 `common` 模块包含公共组件，我们需要在 `Gradle02` 中调用这些组件。

我们首先编辑 `Gradle02` 根目录下的 `settings.gradle` 文件，引入 `Gradle01` 的 `common` 模块。

"settings.gradle":

```groovy
// 声明外部模块名称
include ':common'
// 声明外部模块的路径
project(':common').projectDir = file('../Gradle01/common')
```

上述内容也可以使用Kotlin语言编写：

"settings.gradle.kts":

```kotlin
// 声明外部模块名称
include(":common")
// 声明外部模块的路径
project(":common").projectDir = file("../Gradle01/common")
```

`include(':common')` 方法表示声明名为 `common` 的模块； `project(':common').projectDir` 表示设置 `common` 模块的路径，可以填写绝对路径或相对路径。

保存上述配置文件后， `Gradle02` 即可在编译工具层面访问 `Gradle01` 的 `common` 模块，例如：读取 `common` 模块中的Gradle配置文件、编译 `common` 模块、从 `common` 模块复制文件等。但是，此时 `Gradle02` 仍然无法在代码层面调用 `common` 模块中的类与方法，若要实现代码层面的调用，我们还需要将 `common` 模块配置为 `Gradle02` 的依赖组件，详见相关章节： [🧭 依赖管理 - 工程依赖](./03_依赖管理.md#工程依赖) 。


# 实用技巧
## 文件
### FileTree
FileTree是用于表示目录结构的类，可以设置筛选规则，我们在复制构建产物、配置单元测试覆盖率检查范围等场景中经常使用该类，它的构造方法原型为： `fileTree(baseDir: Any, Closure configureClosure)` ，其中第一参数 `baseDir` 用于指定参考目录，可以是File或字符串等表示目录的对象；第二参数 `configureClosure` 是可选的，用于配置筛选规则，如果我们不指定筛选规则，默认匹配参考目录中的所有子项。

🟠 示例二：FileTree的简单应用。

在本示例中，我们创建一个FileTree实例并指定参考目录，查看其匹配到的文件。

第一步，我们创建一些测试目录与文件。

```text
testFiles
├── 101.log
├── 102.log
├── 105.log
├── 20250701.log
├── file
└── subdir
    ├── file
    ├── LogicTest.kt
    └── UtilTest.jav
```

第二步，我们在构建脚本中创建FileTree实例，并指向测试目录。

"filetree.gradle":

```groovy
// 创建FileTree实例，指定根目录为 `<当前模块>/testFiles/` 。
def baseDir = "${layout.projectDirectory}${File.separator}testFiles"
def tree = fileTree(baseDir)
// 查看匹配到的文件
tree.each { file ->
    println("${file.path}")
}
```

上述内容也可以使用Kotlin语言编写：

"filetree.gradle.kts":

```kotlin
// 创建FileTree实例，指定根目录为 `<当前模块>/testFiles/` 。
val baseDir = "${layout.projectDirectory}${File.separator}testFiles"
val tree: FileTree = fileTree(baseDir)
// 查看匹配到的文件
tree.forEach { file ->
    println("${file.path}")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
<示例工程根目录>/testFiles/101.log
<示例工程根目录>/testFiles/102.log
<示例工程根目录>/testFiles/subdir/file

# 此处已省略部分输出内容...
```

FileTree最常用的两个配置项是排除规则和筛选规则， `include(filter: String...)` 表示只匹配命中规则的文件，如果有多条规则，目标文件命中任意规则即可加入FileTree； `exclude(filter: String...)` 表示忽略命中规则的文件，只匹配其他文件，如果有多条规则，目标文件命中任意规则就会被忽略。

排除和筛选规则中可用的特殊语法如下文列表所示：

- `?` : 匹配当前目录中的任意单个字符。
- `*` : 匹配当前目录中的任意数量字符。
- `**` : 匹配任意目录层级的任意数量字符。

下文列表给出了一些规则语句和可被匹配的文件示例：

- `dir/file` : 精确匹配参考目录下 `dir` 目录内的 `file` 文件。
- `dir/dir2/` : 精确匹配参考目录下 `dir` 目录内的 `dir2` 目录及其子项。
- `*.log` : 模糊匹配参考目录内所有后缀为 `.log` 的文件，例如： `101.log` 、 `20250701.log` 等。
- `10?.log` : 模糊匹配参考目录内前缀为 `10` 、第三位为任意字符、后缀为 `.log` 的文件，例如： `101.log` 、 `105.log` 、 `10A.log` 等。
- `dir/*` : 模糊匹配参考目录下 `dir` 目录及其子项。
- `**/build/` : 模糊匹配任意层级的名称为 `build` 的目录及其子项。
- `**/.gitignore` : 模糊匹配任意层级的名称为 `.gitignore` 的文件。
- `**/*Test.*` : 模糊匹配任意层级的名称包含 `Test.` 的文件，例如： `<参考目录>/UtilTest.java` 、 `<参考目录>/src/test/kotlin/LogicTest.kt` 。

🟡 示例三：FileTree的筛选规则。

在本示例中，我们创建一个FileTree实例并指定筛选规则，查看其匹配到的文件。

"filetree.gradle":

```groovy
// 设置过滤规则
def filter = ["10?.log", "**/*Test*"]

// 创建FileTree实例，指定根目录为 `<当前模块>/testFiles/` 。
def baseDir = "${layout.projectDirectory}${File.separator}testFiles"
def tree = fileTree(baseDir) {
    // 筛选命中规则的文件
    include filter
}
// 查看匹配到的文件
tree.each { file ->
    println("${file.path}")
}
```

上述内容也可以使用Kotlin语言编写：

"filetree.gradle.kts":

```kotlin
// 设置过滤规则
val filter: List<String> = listOf(
    "10?.log",
    "**/*Test*",
)

// 创建FileTree实例，指定根目录为 `<当前模块>/testFiles/` 。
val baseDir = "${layout.projectDirectory}${File.separator}testFiles"
val tree: FileTree = fileTree(baseDir) {
    // 筛选命中规则的文件
    include(filter)
}
// 查看匹配到的文件
tree.forEach { file ->
    println("${file.path}")
}
```

此时运行示例程序，并查看控制台输出信息：

```text
<示例工程根目录>/testFiles/101.log
<示例工程根目录>/testFiles/102.log
<示例工程根目录>/testFiles/105.log
<示例工程根目录>/testFiles/subdir/LogicTest.kt
<示例工程根目录>/testFiles/subdir/UtilTest.java
```

🟢 示例四：设置过滤规则后再添加部分特定文件。

有时我们希望排除特定目录中的大多数文件，但又要求保留特定的文件，通过配置FileTree可以达到此目的。

在本示例中，我们希望排除测试目录下的所有Log文件，但需要保留 `20250701.log` 。

第一步，我们了解一种常见的错误用法。

"filetree.gradle":

```groovy
def baseDir = "${layout.projectDirectory}${File.separator}testFiles"
def tree = fileTree(baseDir) {
    include "20250701.log"
    exclude "*.log"
}
// 查看匹配到的文件
tree.each {
    println("${it.path}")
}
```

上述代码无法匹配任何文件，这是因为在同一个FileTree实例中， `include` 优先级高于 `exclude` ，相当于先添加 `20250701.log` 文件，再忽略所有后缀为 `.log` 的文件。

第二步，我们提供一种正确用法。

"filetree.gradle":

```groovy
def baseDir = "${layout.projectDirectory}${File.separator}testFiles"
// 分别使用排除和包含规则创建FileTree实例，再将二者合并。
def tree = fileTree(baseDir) { exclude "*.log" } +
        fileTree(baseDir) { include "20250701.log" }
// 查看匹配到的文件
tree.each {
    println("${it.path}")
}
```

上述内容也可以使用Kotlin语言编写：

"filetree.gradle.kts":

```kotlin
val baseDir = "${layout.projectDirectory}${File.separator}testFiles"
// 分别使用排除和包含规则创建FileTree实例，再将二者合并。
val tree: FileTree = fileTree(baseDir) { exclude("*.log") } +
        fileTree(baseDir) { include("20250701.log") }
// 查看匹配到的文件
tree.forEach {
    println("${it.path}")
}
```

我们可以为多个FileTree实例设置不同的规则，然后通过加号( `+` )将它们组合起来，生成我们期望的文件列表。

此时运行示例程序，并查看控制台输出信息：

```text
<示例工程根目录>/testFiles/file
<示例工程根目录>/testFiles/subdir/file
<示例工程根目录>/testFiles/subdir/LogicTest.kt
<示例工程根目录>/testFiles/subdir/UtilTest.java
<示例工程根目录>/testFiles/20250701.log
```
