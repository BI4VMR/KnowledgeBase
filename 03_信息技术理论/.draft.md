> 设计模式-概述

根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。
序号	模式 & 描述	包括
1	创建型模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 	

    工厂模式（Factory Pattern）
    抽象工厂模式（Abstract Factory Pattern）
    单例模式（Singleton Pattern）
    建造者模式（Builder Pattern）
    原型模式（Prototype Pattern）

2	结构型模式
这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 	

    适配器模式（Adapter Pattern）
    桥接模式（Bridge Pattern）
    过滤器模式（Filter、Criteria Pattern）
    组合模式（Composite Pattern）
    装饰器模式（Decorator Pattern）
    外观模式（Facade Pattern）
    享元模式（Flyweight Pattern）
    代理模式（Proxy Pattern）

3	行为型模式
这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 	

    责任链模式（Chain of Responsibility Pattern）
    命令模式（Command Pattern）
    解释器模式（Interpreter Pattern）
    迭代器模式（Iterator Pattern）
    中介者模式（Mediator Pattern）
    备忘录模式（Memento Pattern）
    观察者模式（Observer Pattern）
    状态模式（State Pattern）
    空对象模式（Null Object Pattern）
    策略模式（Strategy Pattern）
    模板模式（Template Pattern）
    访问者模式（Visitor Pattern）

4	J2EE 模式
这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 	

    MVC 模式（MVC Pattern）
    业务代表模式（Business Delegate Pattern）
    组合实体模式（Composite Entity Pattern）
    数据访问对象模式（Data Access Object Pattern）
    前端控制器模式（Front Controller Pattern）
    拦截过滤器模式（Intercepting Filter Pattern）
    服务定位器模式（Service Locator Pattern）
    传输对象模式（Transfer Object Pattern）

下面用一个图片来整体描述一下设计模式之间的关系：

设计模式之间的关系
设计模式的优点

    提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。
    提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。
    促进了代码的重用，避免了重复的设计和实现。
    通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。

设计模式的六大原则

1、开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

3、依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

5、迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。


---

> 操作系统 - CPU


1  处理器管理
1.1  进程
1.1.1  概述
早期的计算机一次只能运行单个程序，当某个程序开始运行时，将会独占系统的全部资源（处理器、存储设备、I/O设备等），其它用户必须等待当前程序执行完成后，才能使用计算机，这种方式的设备利用率极低。
单道程序的运行具有以下特征：
 顺序性
程序执行时严格按照预先规定的步骤推进。
 封闭性
程序执行时独占全部系统资源，外界无法进行干涉。
 可再现性
程序重复多次执行时，只要初始条件相同，结果必然也相同。
由于单道程序系统的低效率，人们设计了多道程序系统，多个程序在微观时间内交替执行，充分利用闲置的系统资源，以此提高系统利用率。
多个程序并发执行将会破坏单道程序的三个特性，有些程序的部分操作必须严格按照预定的顺序进行，否则会导致结果不一致的问题，因此需要引入“进程”进行管理。
进程(Process)是程序在一个数据集合（软/硬件环境）上的执行过程，也是系统分配资源与CPU调度的单位，与“程序”具有以下区别：
 动态性
进程反应程序的执行过程，具有创建、运行、暂停、销毁等状态，且拥有系统资源；程序是存储在介质中的代码，是静态的且不持有系统资源。
 并发性
进程能交替进入运行、暂停状态，与其它进程交替执行，程序不具有此特征。
 临时性
进程执行完毕后相关资源就被释放了，程序则是永久存在于介质中的。
1.1.2  进程状态机
进程有三个基本状态：
 运行(Running)
进程得到CPU资源，正在运行。单处理机系统同时只能运行一个进程；多处理机系统可能有多个进程同时运行。
 就绪(Ready)
进程除CPU以外的资源都已经就绪，但未被分配CPU资源，暂时无法运行。
 阻塞(Block)
正在等待I/O操作或同步事件完成，此时即便分配了CPU资源也无法运行。
状态机之间可以相互转换：
 运行与就绪
操作系统会将处于就绪状态的进程放置在一个队列中，当处理机空闲时，系统会根据优先级或其它因素选择进程，使其获得处理机资源并运行。当进程获得的CPU时间片用完后，进程会重新回到就绪状态，等待下一次调度。
 运行与阻塞
当进程需要等待I/O操作或同步事件时，将从运行进入阻塞状态。
 阻塞与就绪
当进程所需的其它资源满足时，将重新进入进入就绪队列，等待系统调度。
 
图 1-1 基本进程状态转换
除了三个基本状态，进程还可以有其它的状态：
 创建
系统为进程设置相关参数、分配资源，前期操作完成后将会加入就绪队列。
 退出
进程正常结束或崩溃后，系统将其从运行状态中移除，并释放系统资源。
 挂起
有些系统为了更精确的控制资源配置，还定义了挂起状态。当内存空间紧张时，可以将不重要的进程挂起，内存中的部分内容被写入外存储器交换空间，缓解系统负载。另一方面，用户可以观察暂停的进程，便于对程序进行调试。
 
图 1-2 扩展进程状态转换
1.1.3  进程控制块
进程控制块(Process Control Block,PCB)是进程的组成部分，用于描述进程的动态信息，如进程标识符、当前状态、优先级、创建者、父进程等，系统的资源调度模块根据PCB中的信息执行调度操作。
 
1.2  线程
1.2.1  概述
进程的应用使得计算机宏观上可以同时运行多个程序，资源利用率得到提高，但每个进程内部依然是顺序执行的，不能满足现代程序的需要。现代程序一般拥有多个线程，主线程用于控制GUI显示，及时响应用户操作；逻辑功能则通过子线程实现，这样执行耗时操作时GUI仍然能与用户交互，提升了用户体验。
线程是比进程更小的调度单位，切换进程时，需要保存原进程的CPU上下文，再装入新进程的CPU上下文，消耗了额外的资源，开销较大；线程则只涉及CPU算力的分配，切换速度较快，开销较小。


---

# 操作系统 - CPU

# 理论基础
## 进程与线程
进程是指程序的一次执行过程，它直接持有操作系统分配的内存、网络地址、I/O设备等资源。

线程是进程内部的任务，它只占用CPU计算资源，而不持有内存等其他资源。



---

# 计算机体系结构 - 数制系统





---


# 计算机体系结构 - 数据的表示 - 文件

文件名是方便人类识别文件类型的，不一定能准确反应实际类型，可能会被恶意篡改。

每种文件类型都有特性的格式，我们通常可以读取文件头部的若干字节，来判断文件类型。例如JPEG图像都以"FFD8FF"开头，WAV音频都以"57415645"开头

有些文件类型的文件头部是相同的，我们还需要进一步读取其他信息进行判断，例如ZIP压缩包和WORD2007文本文档都以"504B0304"开头。










判断原理：定义好常用格式的文件后缀，以及对应文件的字节码前N位，作为判断的一句。

一般而言，如果手工修改文件的后缀，其内部文件字节码是不会发生变化的，以此来作为判断的标准。

因此，工作中，定义一个简要的工具来对常用的文件格式进行校验也是必要的。

以下是定义好的常用几种文件格式的校验，若有需要，可以自行增加。

特殊情况：目前，对于文本文件（*.txt）的文件无法校验，其读取的文件字节码几乎都不一样。当然还可能存在其他的。



# 计算机体系结构 - 数据的表示 - 文本

比如说，对于文本文件，开头的几个字节可以叫做BOM（Byte Order Mark），它的作用是用来标记文本文件内部是用的哪种Unicode编码，以及其字节码顺序。UTF-8，UTF-16BE，UTF-16LE等等各种Unicode编码都有自己独一无二的BOM。一般的文本编辑器也都支持 BOM。这样就不会出现乱码了。


# 文件特征

APK 文件：
文件头：50 4B 03 04 14 00 08 00
文件尾：50 4B 05 06 00 00

AVI 文件：
文件头：52 49 46 46 xx xx xx xx 41 56 49 20
文件尾：00 00 00 00

BAT 文件：
文件头：3C 25 40 20 25 5F 46 49 4C 45 5F 25 20 3E
文件尾：(无)

BMP 文件：
文件头：42 4D
文件尾：（无）

CSV 文件：
文件头：（无）
文件尾：（无）

DLL 文件：
文件头：4D 5A
文件尾：(无)

DOC 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

DOCX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

EPS 文件：
文件头：25 21 50 53 2D 41 64 6F 62 65
文件尾：(无)

EXE 文件：
文件头：4D 5A
文件尾：(无)

FLAC 文件：
文件头：66 4C 61 43
文件尾：(无)

GIF 文件：
文件头：47 49 46 38 39 61
文件尾：3B

GZ 文件：
文件头：1F 8B 08
文件尾：(无)

HTML 文件：
文件头：3C 21 44 4F 43 54 59 50 45 20 48 54 4D 4C 20 50
文件尾：3C 2F 48 54 4D 4C 3E

ICO 文件：
文件头：00 00 01 00
文件尾：（无）

INI 文件：
文件头：3B
文件尾：(无)

ISO 文件：
文件头：43 44 30 30 31
文件尾：(无)

Java 类文件：
文件头：CA FE BA BE
文件尾：(无)

JAR 文件：
文件头：50 4B 03 04 14 00 08 00
文件尾：50 4B 05 06 00 00

JPEG 文件：
文件头：FF D8 FF E0
文件尾：FF D9

JPG 文件：
文件头：FF D8 FF E0
文件尾：FF D9

JSON 文件：
文件头：7B 22 74 79 70 65 22 3A 22
文件尾：7D

MKV 文件：
文件头：1A 45 DF A3
文件尾：(无)

MOV 文件：
文件头：00 00 00 14 66 74 79 70 71 74 20
文件尾：(无)

MP3 文件：
文件头：49 44 33
文件尾：FF FB

MP4 文件：
文件头：00 00 00 14 66 74 79 70 69 73 6F 6D
文件尾：(无)

ODT 文件：
文件头：50 4B 03 04 14 00 08 08
文件尾：50 4B 05 06 00 00

OTF 文件：
文件头：4F 54 54 4F
文件尾：(无)

PDF 文件：
文件头：25 50 44 46 2D 31 2E
文件尾：25 25 45 4F 46

PNG 文件：
文件头：89 50 4E 47 0D 0A 1A 0A
文件尾：49 45 4E 44 AE 42 60 82

PPT 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

PPTX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

PSD 文件：
文件头：38 42 50 53
文件尾：(无)

RAR 文件：
文件头：52 61 72 21 1A 07 00
文件尾：(无)

RTF 文件：
文件头：7B 5C 72 74 66 31
文件尾：7D

SQL 文件：
文件头：3B 43 3B 20
文件尾：3B

SVG 文件：
文件头：3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E
文件尾：3C 2F 73 76 67 3E

TAR 文件：
文件头：75 73 74 61 72 00 30 30
文件尾：（无）

TIFF 文件：
文件头：49 49 2A 00
文件尾：(无)

TXT 文件：
文件头：（无）
文件尾：（无）

WAV 文件：
文件头：52 49 46 46 xx xx xx xx 57 41 56 45 66 6D 74 20
文件尾：64 61 74 61 xx xx xx xx

WebM 文件：
文件头：1A 45 DF A3
文件尾：(无)

Windows 文件夹（目录）：
文件头：4B 44 57 4D
文件尾：(无)

WMV 文件：
文件头：30 26 B2 75 8E 66 CF 11 A6 D9 00 AA 00 62 CE 6C
文件尾：(无)

WordPerfect 文件：
文件头：FF 57 50 43
文件尾：（无）

XLS 文件：
文件头：D0 CF 11 E0 A1 B1 1A E1
文件尾：（无）

XLSX 文件：
文件头：50 4B 03 04 14 00 06 00
文件尾：50 4B 05 06 00 00

XML 文件：
文件头：3C 3F 78 6D 6C 20 76 65 72 73 69 6F 6E
文件尾：3C 2F 72 6F 6F 74 3E

ZIP 文件：
文件头：50 4B 03 04
文件尾：50 4B 05 06


---

# 计算机体系结构 - 代码结构

# 顺序结构
连续的多行语句即为顺序结构，程序运行时，将会首先执行第一条语句对应的操作，当第一条语句执行完毕后，再执行第二条语句，依次类推直到所有语句都被执行完毕。

# 分支结构
## 简介
分支结构也叫选择结构，程序运行时不会严格按照语句的书写顺序执行，而是根据条件选择相应的语句并执行。



---

# 计算机体系结构 - ANSI颜色

ANSI颜色标准定义了一组有限的颜色选项，最初支持的是16种基本颜色。这些颜色可以通过ANSI转义序列来设置文本或背景的颜色。对于基本的16种颜色，它们并没有直接对应到特定的十六进制RGB值，而是有一组约定俗成的颜色映射。
最初的8种标准颜色包括：
黑色 (Black)
红色 (Red)
绿色 (Green)
黄色 (Yellow)
蓝色 (Blue)
靛青色/Magenta (Magenta)
青色/Cyan (Cyan)
白色 (White)
接下来的8种颜色是上述颜色的“明亮”版本：
亮黑色 (Bright Black, 或者深灰色)
亮红色 (Bright Red)
亮绿色 (Bright Green)
亮黄色 (Bright Yellow, 或者淡绿色)
亮蓝色 (Bright Blue)
亮靛青色 (Bright Magenta)
亮青色 (Bright Cyan)
亮白色 (Bright White, 或者纯白色)
这些颜色可以用ANSI转义序列来设置，例如：
前景色：\033[30m 到 \033[37m 对应于黑色到白色。
背景色：\033[40m 到 \033[47m 对应于黑色到白色。

对于这些基本颜色，通常使用的十六进制RGB值如下（这并不是ANSI标准的一部分，而是一种常见的实现方式）：

黑色: #000000
红色: #CD0000
绿色: #00CD00
黄色: #CDCD00
蓝色: #0000EE
靛青色/Magenta: #CD00CD
青色/Cyan: #00CDCC
白色: #E5E5E5

明亮版本的颜色通常会更接近以下值：

亮黑色: #7F7F7F
亮红色: #FF0000
亮绿色: #00FF00
亮黄色: #FFFF00
亮蓝色: #5C5CFF
亮靛青色: #FF00FF
亮青色: #00FFFF
亮白色: #FFFFFF



# 计算机体系结构
## 屏幕大小

屏幕大小：通常描述手机大小会用几寸来描述，如6.5寸手机，这里的屏幕大小实际指的是屏幕对角线的长度；

分辨率：手机屏幕的像素点个数，如手机屏幕分辨率为1920x1080指的是宽有1080个像素点，高有1920个像素点；

DPI：每英寸像素，由对角线的像素点个数除以屏幕大小（对角线长度）得到；

px：像素，1px代表屏幕上一个物理的像素点，可以理解为绝对尺寸，在某个屏幕分辨率上显示一个长度值，到了另一个屏幕分辨率还是同一个长度值，一般不使用这个单位，因为会造成同一尺寸在不同分辨率显示不同的效果；
