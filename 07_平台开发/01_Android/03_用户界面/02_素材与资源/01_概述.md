# 简介
Android工程中的资源(Resource)泛指一切非逻辑代码的静态内容，例如：字符串、布局描述文件、位图、矢量图等。

资源文件都被统一放置在模块的 `res` 目录中，由于资源的类型众多，为了便于管理，我们还需要进一步划分子目录。

下文代码块展示了常见的资源目录与文件：

```text
<模块根目录>
├── src
│   └── 源代码...
└── res
    ├── drawable
    ├── drawable-mdpi
    ├── drawable-hdpi
    ├── drawable-xdpi
    ├── layout
    └── values
        ├── colors.xml
        ├── strings.xml
        └── styles.xml
```

下文内容将对上述目录与文件进行说明：

🔷 `drawable`

该目录用于放置矢量图描述文件，包括Shape、Selector、 `.9.png` 格式的图片等。

🔷 `drawable-mdpi` 等

这些目录用于放置点阵图，目录名称中的后缀指明了像素密度，系统将会选择与屏幕最为匹配的图片并加载；因此我们需要根据目标设备尺寸制作对应的素材，避免图片尺寸过大导致内存占用较高，或图片尺寸过小导致被拉伸后变得模糊。

🔷 `layout` 

该目录用于放置布局描述文件。

🔷 `values`

该目录用于放置文本、颜色、样式等资源。

下文列表展示了一些约定俗成的资源文件名称：

- `arrays.xml` : 常量数组。
- `colors.xml` : 颜色。
- `dimens.xml` : 尺寸。
- `strings.xml` : 文本。
- `styles.xml` : 样式。
- `themes.xml` : 主题。

该目录中的资源在编译阶段会被整合到 `.arsc` 索引文件，不保留原始XML文件，因此我们可以在工程中创建多个具有不同名称的XML文件以便区分资源用途，例如：在 `colors.xml` 中放置应用主页的颜色资源、在 `colors_setting.xml` 中放置设置模块的颜色资源。

<br />

本章的相关知识详见以下链接：

- [🔗 Android官方文档 - 应用程序资源](https://developer.android.com/guide/topics/resources/providing-resources)
- [🔗 Android官方文档 - 资源类型概览](https://developer.android.com/guide/topics/resources/available-resources)

本章的示例工程详见以下链接：

- [🔗 示例工程：概述](https://github.com/BI4VMR/Study-Android/tree/master/M03_UI/C02_Resource/S01_Base)


# 计量单位
## DP
密度无关像素(Density Independent Pixel, DIP)也被称为DP，是Android中特有的尺寸单位，它能够根据屏幕的像素密度(PPI)自动进行缩放，使控件在不同屏幕上的尺寸尽可能地保持一致，以便适配多种设备。

DP与PX的转换公式为：

$$
PX值 = DP值 * \frac{ PPI }{ 160 }
$$

PPI是屏幕的物理属性，系统会根据PPI值计算缩放倍率，调整控件尺寸或选择合适的图像资源。 `160` 是一个基准PPI，如果屏幕的PPI恰好也为 `160` ，则 `1dp` 等于 `1px` ，此时系统不必进行缩放；如果屏幕的PPI为 `320` ，则 `1dp` 将被转换为 `2px` 。

🔴 示例一：比较DP与PX在不同屏幕上的显示效果。

在本示例中，我们在两款常见的设备上显示矩形，分别以DP与PX作为计量单位，并比较它们的显示效果。

下文表格列出了测试设备的屏幕参数：

<div align="center">

|  设备名称  |   分辨率    | 屏幕尺寸  |  PPI   | DP缩放倍率 |
| :--------: | :---------: | :-------: | :----: | :--------: |
| 笔记本电脑 | 1920 * 1080 | 13.8 英寸 | 159.63 |  约 1 倍   |
|    手机    | 1920 * 1080 |  6 英寸   | 367.15 | 约 2.3 倍  |

</div>

第一步，我们在界面上放置一个宽高为 `480px * 270px` 的矩形，显示效果如下文图片所示：

<div align="center">

![使用PX的情况](./Assets_概述/尺寸计量单位_使用PX的情况.jpg)

</div>

笔记本电脑的屏幕分辨率与手机相同，且物理尺寸大约相差2倍，因此该控件在电脑上能够被用户看清，但在手机上显得较小，其中的文本难以辨认。

第二步，我们在界面上放置一个宽高为 `480dp * 270dp` 的矩形，显示效果如下文图片所示：

<div align="center">

![使用DP的情况](./Assets_概述/尺寸计量单位_使用DP的情况.jpg)

</div>

根据PPI与缩放倍率的映射规则，该控件在手机上将被放大约2.3倍，实际尺寸约为 `1100px * 620px` ，与笔记本电脑屏幕上的控件尺寸接近，因此其中的文本不会变得难以辨认。

## SP
受缩放影响的密度无关像素(Scaled Density, SP)主要用于设置文本的尺寸，默认情况下 `1sp` 等同于 `1dp` 。用户可以在系统设置中调整文本的缩放倍率，此时最终的倍率为：

$$
SP缩放倍率 = DP缩放倍率 * 文本缩放倍率
$$

## 单位转换
当需要在不同的尺寸单位之间相互转换时，我们可以使用DisplayMetrics对象获取屏幕尺寸与缩放倍率等参数，再进行计算。

我们可以通过以下方式获取DisplayMetrics对象：

🔷 单显示器环境

这种方式可以获取主显示器的DisplayMetrics对象，并不依赖Context，适用于只有单个屏幕的工程。

```java
DisplayMetrics dm = Resources.getSystem().getDisplayMetrics()
```

🔷 多显示器环境

这种方式依赖当前界面组件的Context对象，因此能够支持多个屏幕。

```java
// 创建一个空的DisplayMetrics对象
DisplayMetrics dm = new DisplayMetrics();
// 使用当前Context所关联的显示器设置DisplayMetrics参数
context.getDisplay().getRealMetrics(dm);
```

<br />

下文示例展示了DisplayMetrics对象包含的详细信息：

🟠 示例二：获取设备屏幕的相关参数。

在本示例中，我们获取设备主显示器的DisplayMetrics对象，并查看相关参数。

"TestUIBase.java":

```java
DisplayMetrics dm = Resources.getSystem().getDisplayMetrics();
Log.i(TAG, "屏幕宽度：" + dm.widthPixels);
Log.i(TAG, "屏幕高度：" + dm.heightPixels);
Log.i(TAG, "像素密度：" + dm.densityDpi);
Log.i(TAG, "缩放倍率(DP)：" + dm.density);
Log.i(TAG, "缩放倍率(SP)：" + dm.scaledDensity);
```

上述内容也可以使用Kotlin语言编写：

"TestUIBase.kt":

```kotlin
val dm = Resources.getSystem().displayMetrics
Log.i(TAG, "屏幕宽度：${dm.widthPixels}")
Log.i(TAG, "屏幕高度：${dm.heightPixels}")
Log.i(TAG, "像素密度：${dm.densityDpi}")
Log.i(TAG, "缩放倍率(DP)：${dm.density}")
Log.i(TAG, "缩放倍率(SP)：${dm.scaledDensity}")
```

此时运行示例程序，并查看控制台输出信息：

```text
22:45:35.485 27731 27731 I TestApp: 屏幕宽度：1080
22:45:35.485 27731 27731 I TestApp: 屏幕高度：2160
22:45:35.485 27731 27731 I TestApp: 像素密度：480
22:45:35.485 27731 27731 I TestApp: 缩放倍率(DP)：3.0
22:45:35.485 27731 27731 I TestApp: 缩放倍率(SP)：3.0
```

---

在前文示例中，我们已经知悉设备屏幕的像素密度与缩放倍率，此时便可进行单位换算了。

🟡 示例三：DP、SP与PX之间的相互转换。

在本示例中，我们实现DP、SP与PX之间的转换方法。

"TestUIBase.java":

```java
// 将DP转换为PX
public static int dpToPX(float dpValue) {
    // "applyDimension()"方法用于将指定的非标准单位转换为像素
    float rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, Resources.getSystem().getDisplayMetrics());
    // 物理像素不可能为小数，因此保留整数部分即可。
    return Math.round(rawValue);
}

// 将SP转换为PX
public static int spToPX(float spValue) {
    float rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, Resources.getSystem().getDisplayMetrics());
    return Math.round(rawValue);
}

// 将PX转换为DP
public static int pxToDP(int pxValue) {
    // 获取缩放倍率
    float density = Resources.getSystem().getDisplayMetrics().density;
    return Math.round(pxValue / density);
}

// 将PX转换为SP
public static int pxToSP(int pxValue) {
    // 获取字体缩放倍率
    float density = Resources.getSystem().getDisplayMetrics().scaledDensity;
    return Math.round(pxValue / density);
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIBase.kt":

```kotlin
// 将DP转换为PX
private fun dpToPX(dpValue: Float): Int {
    val dm: DisplayMetrics = Resources.getSystem().displayMetrics
    // "applyDimension()"方法用于将指定的单位转换为像素
    val rawValue: Float = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, dm)
    // 物理像素不可能为小数，因此保留整数部分即可。
    return rawValue.roundToInt()
}

// 将SP转换为PX
private fun spToPX(spValue: Float): Int {
    val dm = Resources.getSystem().displayMetrics
    val rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, dm)
    return rawValue.roundToInt()
}

// 将PX转换为DP
private fun pxToDP(pxValue: Int): Int {
    // 获取DP缩放倍率
    val density = Resources.getSystem().displayMetrics.density
    return (pxValue / density).roundToInt()
}

// 将PX转换为SP
private fun pxToSP(pxValue: Int): Int {
    // 获取SP缩放倍率
    val density = Resources.getSystem().displayMetrics.scaledDensity
    return (pxValue / density).roundToInt()
}
```

此时运行示例程序，并查看控制台输出信息：

```text
22:46:58.015 27731 27731 I TestApp: 100dp -> ?px: 300
22:46:58.015 27731 27731 I TestApp: 100sp -> ?px: 300
22:46:58.015 27731 27731 I TestApp: 300px -> ?dp: 100
22:46:58.015 27731 27731 I TestApp: 300px -> ?sp: 100
```

> 🚩 提示
>
> 上述代码中的DisplayMetrics对象均为主显示器，如果需要支持多显示器，我们可以新增Context参数并获取DisplayMetrics对象。


# 资源索引
Android Asset Packaging Tool(AAPT)是在APK编译阶段处理资源文件的工具，该工具会为每项资源生成全局唯一的ID，并将ID与资源路径的映射关系记录在 `.arsc` 索引文件中；在应用程序运行阶段，程序可以通过索引文件查询ID指向的路径以便访问资源文件。

以颜色资源为例，我们在示例工程的 `res/values/colors.xml` 文件中声明一条资源：

"colors.xml":

```xml
<color name="black">#000000</color>
```

然后将示例工程编译为APK，并使用Android Studio反编译该APK文件，查看资源索引的内容：

<div align="center">

![查看APK中资源索引文件的内容](./Assets_概述/查看APK中资源索引文件的内容.jpg)

</div>

对于颜色、文本等资源，AAPT会将数据值直接写入索引文件，因此我们不会在APK中看到 `colors.xml` 、 `strings.xml` 等文件；对于图像、布局文件等资源，AAPT会将资源文件复制到APK中，并通过索引文件记录存放路径。

为了便于人类阅读代码，在编码阶段我们可以通过名称引用资源，而不是直接填写数字形式的资源ID。AAPT会为每条资源生成一个常量，常量名称为无扩展名的文件名，常量值为数字ID，这些常量被放置在当前模块的 `<包名>.R` 文件中；我们可以通过常量在布局文件和代码中引用资源，提高可读性。

若要在布局文件中引用资源，可以使用 `@[<包名>:]<资源类型>/<资源名称>` 语法：

```xml
<!-- 此处已省略部分属性... -->
<TextView
    android:textColor="@color/black" />
```

若要在代码中引用资源，可以使用 `[<包名>.]R.<资源类型>.<资源名称>` 语法：

```kotlin
// 先获取当前Context的Resources实例，再获取资源。
int colorValue = getResources().getColor(R.color.common_text, getTheme());
// 直接使用当前Context的相关方法获取资源。
int colorValue2 = getColor(android.R.color.holo_blue_light);

// 使用资源
textview.setTextColor(colorValue)
textview2.setTextColor(colorValue2)
```

Resources是资源管理类，我们可以通过Context获取该类的实例并访问各种资源；部分资源与主题有关，我们可以通过Context的 `getTheme()` 获取当前主题并传入，以便获取当前主题对应的资源内容；如果我们并不关心主题，也可以传入 `null` 。

Context类提供了一些快捷方法，以便我们更方便地访问资源，例如： `Context.getColor(int id)` 等价于 `Context.getResources().getColor(int id, Theme theme)` ，且此时 `theme` 参数将自动填入Context的主题。

Resources实例提供了一些方法以便我们查看资源详情。

🟢 示例四：查看资源详情。

在本示例中，我们通过Resources类提供的方法查看资源详细信息。

"TestUIIndex.java":

```java
// 获取完整名称
String fullName = getResources().getResourceName(R.string.app_name);
// 获取资源名称
String name = getResources().getResourceEntryName(R.string.app_name);
// 获取资源类型
String type = getResources().getResourceTypeName(R.string.app_name);
// 获取资源所在包名
String pkgName = getResources().getResourcePackageName(R.string.app_name);
```

上述内容也可以使用Kotlin语言编写：

"TestUIIndexKT.kt":

```kotlin
// 获取完整名称
val fullName = resources.getResourceName(R.string.app_name)
// 获取资源名称
val name = resources.getResourceEntryName(R.string.app_name)
// 获取资源类型
val type = resources.getResourceTypeName(R.string.app_name)
// 获取资源所在包名
val pkgName = resources.getResourcePackageName(R.string.app_name)
```

此时运行示例程序，并查看控制台输出信息：

```text
07:16:28.568  9921 9921 I TestApp: 完整名称：net.bi4vmr.study.ui.resource.base:string/app_name
07:16:28.568  9921 9921 I TestApp: 资源名称：app_name
07:16:28.568  9921 9921 I TestApp: 资源类型：string
07:16:28.568  9921 9921 I TestApp: 资源包名：net.bi4vmr.study.ui.resource.base
```

根据上述输出内容可知：

资源名称的完整格式为： `<包名>:<资源类型>/<资源名称>` ，当我们引用当前工程中定义的资源时，可以省略包名；当我们引用外部模块中定义的资源时，必须指明其所在的包名。

当我们想要获取Android SDK内置的资源时，需要将包名指明为 `android` ，例如： `@android:color/black` 或 `android.R.color.black` 表示引用SDK内置的“黑色”资源。


<!-- TODO
# 资源后缀

-night限定符

-->


# 外部资源
## 外部软件包
应用程序可以访问自身软件包所携带的资源，也可以访问外部软件包中的资源，这种机制提供了一定的可扩展性。

在某些设备中，Launcher的应用列表可以根据配置替换部分App的默认图标，如果我们将特殊图标全部打包到Launcher中，显然是不合理的，因为用户安装的App各不相同，且后续可能新增或修改特殊图标的数量。我们应当约定Launcher侧从目标软件包远程读取具有特定名称的资源，App侧可以根据需要自行打包图标，降低耦合性。

这种方式要求当前程序具有访问所有软件包的权限，否则需要明确声明对目标软件包的可见性请求，因此适用场景较窄，通常仅用于系统预置应用。

🔵 示例五：访问外部软件包中的资源。

在本示例中，我们从示例程序获取外部软件包中的图片资源，并展示在示例程序界面上。

第一步，我们在主工程中新建单独的 `S01_Base_ResPack` 模块，作为远程获取资源的目标应用程序。

```text
S01_Base_ResPack/src/main/
└── res
    └── drawable
        └── alarm.xml
```

我们首先在该模块的资源目录中放置名为 `alarm.xml` 的矢量图，然后编译模块生成APK文件并安装到测试设备中。

第二步，我们在示例程序 `S01_Base` 模块中编写逻辑代码。

"TestUIRemote.java":

```java
try {
    String targetPackage = "net.bi4vmr.study.ui.resource.base.res";
    // 创建指定软件包的Context
    Context remoteContext = createPackageContext(targetPackage, 0);
    // 查询资源名称对应的资源ID
    int resID = remoteContext.getResources().getIdentifier("alarm", "drawable", targetPackage);
    // 如果ID大于0，说明资源存在；否则表示资源不存在。
    if (resID > 0) {
        // 使用目标软件包的Resources获取该ID对应的资源
        Drawable drawable = ResourcesCompat.getDrawable(remoteContext.getResources(), resID, remoteContext.getTheme());
        // 使用资源
        imageview.setImageDrawable(drawable);
    } else {
        Log.w(TAG, "未找到远程资源！");
    }
} catch (Exception e) {
    Log.e(TAG, "获取远程资源失败！", e);
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIRemoteKT.kt":

```kotlin
try {
    val targetPackage = "net.bi4vmr.study.ui.resource.base.res"
    // 创建指定软件包的Context
    val remoteContext = createPackageContext(targetPackage, 0)
    // 查询资源名称对应的资源ID
    val resID: Int = remoteContext.resources.getIdentifier("alarm", "drawable", targetPackage)
    // 如果ID大于0，说明资源存在；否则表示资源不存在。
    if (resID > 0) {
        // 使用目标软件包的Resources获取该ID对应的资源
        val drawable = ResourcesCompat.getDrawable(remoteContext.resources, resID, remoteContext.theme)
        // 使用资源
        imageview.setImageDrawable(drawable)
    } else {
        Log.w(TAG, "未找到指定资源！")
    }
} catch (e: Exception) {
    Log.e(TAG, "获取远程资源失败！", e)
}
```

若要访问外部软件包中的资源，我们首先需要通过当前程序Context的 `createPackageContext()` 方法创建目标软件包的远程Context实例，随后便可通过远程Context的 `getDrawable()` 等方法访问目标软件包中的资源，系统会通过远程调用将资源内容传递到当前进程中，如果访问频率较高可以增加缓存机制以减少远程调用次数。

此处我们知道目标资源的名称与类型，因此首先通过Resources的 `getIdentifier(String name, String type, String package)` 方法查询资源在目标软件包中的ID，然后再通过ID获取资源内容。如果该方法返回的ID为 `0` ，则表示目标软件包中不存在对应资源。

第三步，我们在示例程序 `S01_Base` 模块中声明对资源模块 `S01_Base_ResPack` 的可见性请求。

"AndroidManifest.xml":

```xml
<!-- 此处已省略部分属性... -->
<manifest>

    <!-- 访问其他软件包的资源需要声明可见性请求 -->
    <queries>
        <package android:name="net.bi4vmr.study.ui.resource.base.res" />
    </queries>
</manifest>
```

此时运行示例程序，点击按钮触发资源获取代码，我们应当能够看到ImageView加载了 `net.bi4vmr.study.ui.resource.base.res` 软件包中的 `alarm.xml` 矢量图。

## APK文件
应用程序启动时，系统会创建AssetManager实例，并通过 `addAssetPath()` 方法将当前软件包的 `.arsc` 索引文件加载至内存，以便后续程序通过Resources类访问资源。

基于上述原理，我们也可以自行创建AssetManager实例，并通过 `addAssetPath()` 方法加载任意APK文件的资源索引，从而实现对外部资源的访问。这种方式与远程Context相比更加灵活，我们不必将资源APK安装到系统中，访问者也不必声明对目标软件包的可见性请求。

我们可以通过这种方式实现插件化的主题切换能力，用户联网下载或导入主题APK文件后，应用程序便可从APK文件加载资源并构建界面。

🟣 示例六：访问APK文件中的资源。

在本示例中，我们从示例程序获取APK文件中的图片资源，并展示在示例程序界面上。

第一步，我们在主工程中新建单独的 `S01_Base_ResPack` 模块，作为远程获取资源的目标应用程序。

```text
S01_Base_ResPack/src/main/
└── res
    └── drawable
        └── house.xml
```

我们首先在该模块的资源目录中放置名为 `house.xml` 的矢量图，然后编译模块生成APK文件并复制到测试设备的 `/data` 目录中。

第二步，我们在示例程序 `S01_Base` 模块中编写逻辑代码。

"TestUIRemote.java":

```java
// 目标APK文件路径
String apkPath = "/data/S01_Base_ResPack-debug.apk";
// 解析APK包名
String pkgName = "UNKNOWN";
PackageInfo pkgInfo = getPackageManager().getPackageArchiveInfo(apkPath, 0);
if (pkgInfo != null) {
    pkgName = pkgInfo.packageName;
}

try {
    // 创建AssetManager实例并加载资源
    AssetManager remoteAM = AssetManager.class.newInstance();
    // 通过反射调用 `addAssetPath()` 方法加载APK资源
    Method method = AssetManager.class.getDeclaredMethod("addAssetPath", String.class);
    // 该方法将返回当前APK资源在AssetManager中的索引，若为 `0` 则表示加载失败。
    Object result = method.invoke(remoteAM, apkPath);
    int index = -1;
    if (result instanceof Integer) {
        index = (Integer) result;
    }

    if (index <= 0) {
        Log.e(TAG, "加载APK资源失败！");
        return;
    }

    // 创建Resources实例，并套用当前应用的显示参数和配置。
    Resources remoteRes = new Resources(
            remoteAM,
            getResources().getDisplayMetrics(),
            getResources().getConfiguration()
    );
    // 查询资源名称对应的资源ID
    int resID = remoteRes.getIdentifier("house", "drawable", pkgName);
    if (resID > 0) {
        Drawable drawable = ResourcesCompat.getDrawable(remoteRes, resID, null);
        imageview.setImageDrawable(drawable);
    } else {
        Log.w(TAG, "未找到指定资源！");
    }
} catch (Exception e) {
    Log.e(TAG, "获取远程资源失败！", e);
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIRemoteKT.kt":

```kotlin
// 目标APK文件路径
val apkPath = "/data/S01_Base_ResPack-debug.apk"
// 解析APK包名
val pkgName = packageManager.getPackageArchiveInfo(apkPath, 0)?.packageName ?: "UNKNOWN"

try {
    // 创建AssetManager实例并加载资源
    val remoteAM = AssetManager::class.java.newInstance()
    // 通过反射调用 `addAssetPath()` 方法加载APK资源
    val method = AssetManager::class.java.getDeclaredMethod("addAssetPath", String::class.java)
    // 该方法将返回当前APK资源在AssetManager中的索引，若为 `0` 则表示加载失败。
    val index = method.invoke(remoteAM, apkPath) as? Int ?: -1
    if (index <= 0) {
        Log.e(TAG, "加载APK资源失败！")
        return
    }

    // 创建Resources实例，并套用当前应用的显示参数和配置。
    val remoteRes = Resources(remoteAM, resources.displayMetrics, resources.configuration)
    // 查询资源名称对应的资源ID
    val resID: Int = remoteRes.getIdentifier("house", "drawable", pkgName)
    if (resID > 0) {
        val drawable = ResourcesCompat.getDrawable(remoteRes, resID, null)
        imageview.setImageDrawable(drawable)
    } else {
        Log.w(TAG, "未找到指定资源！")
    }
} catch (e: Exception) {
    Log.e(TAG, "获取远程资源失败！", e)
}
```

我们首先创建了新的AssetManager实例，并通过反射调用 `addAssetPath(String path)` 方法加载目标APK文件的资源索引；接下来，我们使用当前应用的显示参数和Configuration创建了Resources实例，随后便可通过该实例访问APK文件中的资源。

此时运行示例程序，点击按钮触发资源获取代码，我们应当能够看到ImageView加载了 `/data/S01_Base_ResPack-debug.apk` 文件中的 `house.xml` 矢量图。

---

`addAssetPath()` 方法是一个耗时操作，具体执行时长取决于目标APK文件的资源数量，为了提高性能，我们可以在内存中缓存APK文件对应的AssetManager实例，避免重复加载资源索引。


# 调试命令
## 语法
我们可以通过ADB Shell查看或修改显示参数，以便进行调试。

下文内容介绍了与显示参数相关的命令语法。

🔶 查看或修改分辨率

以下命令可以查看或修改屏幕分辨率：

```text
ADB $ wm size [<长>x<宽>] [-d <DisplayID>]
```

当我们不指定 `[<长>x<宽>]` 时，该命令将会显示指定屏幕的分辨率，当我们指定 `[<长>x<宽>]` 时，将会更改指定屏幕的分辨率。

🔶 重置分辨率

以下命令可以重置屏幕分辨率：

```text
ADB $ wm size reset [-d <DisplayID>]
```

当我们修改分辨率后，系统将会一直沿用该配置，直到恢复出厂设置；如果调试完毕需要恢复默认分辨率，我们也可以使用 `wm size reset` 命令。

🔶 查看或修改像素密度

以下命令可以查看或修改屏幕像素密度：

```text
ADB $ wm density [PPI值] [-d <DisplayID>]
```

当我们不指定PPI值时，该命令将会显示指定屏幕的PPI值，当我们指定PPI值时，将会更改指定屏幕的PPI值。

🔶 重置像素密度

以下命令可以重置屏幕像素密度：

```text
ADB $ wm density reset [-d <DisplayID>]
```

当我们修改像素密度后，系统将会一直沿用该配置，直到恢复出厂设置；如果调试完毕需要恢复默认像素密度，我们也可以使用 `wm density reset` 命令。

## 示例
下文列举了一些通过ADB Shell查看或修改显示参数的案例。

🔷 案例一

将默认屏幕的分辨率改为 `1920x1080` ，然后查看显示配置。

```text
# 修改默认屏幕的分辨率为 `1920x1080`
ADB $ wm size 1920x1080


# 查看默认屏幕的显示配置
ADB $ wm size
Physical size: 1920x720
Override size: 1920x1080
```

`Physical size` 表示屏幕的物理分辨率； `Override size` 表示我们用命令修改后所使用的分辨率。

---

🔷 案例二

将默认屏幕的PPI改为 `240` ，然后查看显示配置。

```text
# 修改默认屏幕的PPI为 `240`
ADB $ wm density 240


# 查看默认屏幕的PPI
ADB $ wm density
Physical density: 160
Override density: 240
```

`Physical density` 表示屏幕的物理PPI； `Override density` 表示我们用命令修改后所使用的PPI。
