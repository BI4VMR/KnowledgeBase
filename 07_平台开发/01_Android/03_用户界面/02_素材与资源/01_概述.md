# 简介
Android工程中的资源(Resource)泛指一切非逻辑代码的静态内容，例如：字符串、布局描述文件、位图、矢量图等。

资源文件都被统一放置在模块的 `res` 目录中，由于资源的类型众多，为了便于管理，我们还需要进一步划分子目录。

下文代码块展示了常见的资源目录与文件：

```text
<模块根目录>
├── src
│   └── 源代码...
└── res
    ├── drawable
    ├── drawable-mdpi
    ├── drawable-hdpi
    ├── drawable-xdpi
    ├── layout
    └── values
        ├── colors.xml
        ├── strings.xml
        └── styles.xml
```

下文内容将对上述目录与文件进行说明：

🔷 `drawable`

该目录用于放置矢量图描述文件，包括Shape、Selector、 `.9.png` 格式的图片等。

🔷 `drawable-mdpi` 等

这些目录用于放置点阵图，目录名称中的后缀指明了像素密度，系统将会选择与屏幕最为匹配的图片并加载；因此我们需要根据目标设备尺寸制作对应的素材，避免图片尺寸过大导致内存占用较高，或图片尺寸过小导致被拉伸后变得模糊。

🔷 `layout` 

该目录用于放置布局描述文件。

🔷 `values`

该目录用于放置文本、颜色、样式等资源。

下文列表展示了一些约定俗成的资源文件名称：

- `arrays.xml` : 常量数组。
- `colors.xml` : 颜色。
- `dimens.xml` : 尺寸。
- `strings.xml` : 文本。
- `styles.xml` : 样式。
- `themes.xml` : 主题。

该目录中的资源在编译阶段会被整合到 `.arsc` 索引文件，不保留原始XML文件，因此我们可以在工程中创建多个具有不同名称的XML文件以便区分资源用途，例如：在 `colors.xml` 中放置应用主页的颜色资源、在 `colors_setting.xml` 中放置设置模块的颜色资源。

<br />

本章的相关知识详见以下链接：

- [🔗 Android官方文档 - 应用程序资源](https://developer.android.com/guide/topics/resources/providing-resources)
- [🔗 Android官方文档 - 资源类型概览](https://developer.android.com/guide/topics/resources/available-resources)

本章的示例工程详见以下链接：

- [🔗 示例工程：概述](https://github.com/BI4VMR/Study-Android/tree/master/M03_UI/C02_Resource/S01_Base)


# 计量单位
## DP
密度无关像素(Density Independent Pixel, DIP)也被称为DP，是Android中特有的尺寸单位，它能够根据屏幕的像素密度(PPI)自动进行缩放，使控件在不同屏幕上的尺寸尽可能地保持一致，以便适配多种设备。

DP与PX的转换公式为：

$$
PX值 = DP值 * \frac{ PPI }{ 160 }
$$

PPI是屏幕的物理属性，系统会根据PPI值计算缩放倍率，调整控件尺寸或选择合适的图像资源。 `160` 是一个基准PPI，如果屏幕的PPI恰好也为 `160` ，则 `1dp` 等于 `1px` ，此时系统不必进行缩放；如果屏幕的PPI为 `320` ，则 `1dp` 将被转换为 `2px` 。

🔴 示例一：比较DP与PX在不同屏幕上的显示效果。

在本示例中，我们在两款常见的设备上显示矩形，分别以DP与PX作为计量单位，并比较它们的显示效果。

下文表格列出了测试设备的屏幕参数：

<div align="center">

|  设备名称  |   分辨率    | 屏幕尺寸  |  PPI   | DP缩放倍率 |
| :--------: | :---------: | :-------: | :----: | :--------: |
| 笔记本电脑 | 1920 * 1080 | 13.8 英寸 | 159.63 |  约 1 倍   |
|    手机    | 1920 * 1080 |  6 英寸   | 367.15 | 约 2.3 倍  |

</div>

第一步，我们在界面上放置一个宽高为 `480px * 270px` 的矩形，显示效果如下文图片所示：

<div align="center">

![使用PX的情况](./Assets_概述/尺寸计量单位_使用PX的情况.jpg)

</div>

笔记本电脑的屏幕分辨率与手机相同，且物理尺寸大约相差2倍，因此该控件在电脑上能够被用户看清，但在手机上显得较小，其中的文本难以辨认。

第二步，我们在界面上放置一个宽高为 `480dp * 270dp` 的矩形，显示效果如下文图片所示：

<div align="center">

![使用DP的情况](./Assets_概述/尺寸计量单位_使用DP的情况.jpg)

</div>

根据PPI与缩放倍率的映射规则，该控件在手机上将被放大约2.3倍，实际尺寸约为 `1100px * 620px` ，与笔记本电脑屏幕上的控件尺寸接近，因此其中的文本不会变得难以辨认。

## SP
受缩放影响的密度无关像素(Scaled Density, SP)主要用于设置文本的尺寸，默认情况下 `1sp` 等同于 `1dp` 。用户可以在系统设置中调整文本的缩放倍率，此时最终的倍率为：

$$
SP缩放倍率 = DP缩放倍率 * 文本缩放倍率
$$

## 单位转换
当需要在不同的尺寸单位之间相互转换时，我们可以使用DisplayMetrics对象获取屏幕尺寸与缩放倍率等参数，再进行计算。

我们可以通过以下方式获取DisplayMetrics对象：

🔷 单显示器环境

这种方式可以获取主显示器的DisplayMetrics对象，并不依赖Context，适用于只有单个屏幕的工程。

```java
DisplayMetrics dm = Resources.getSystem().getDisplayMetrics()
```

🔷 多显示器环境

这种方式依赖当前界面组件的Context对象，因此能够支持多个屏幕。

```java
// 创建一个空的DisplayMetrics对象
DisplayMetrics dm = new DisplayMetrics();
// 使用当前Context所关联的显示器设置DisplayMetrics参数
context.getDisplay().getRealMetrics(dm);
```

<br />

下文示例展示了DisplayMetrics对象包含的详细信息：

🟠 示例二：获取设备屏幕的相关参数。

在本示例中，我们获取设备主显示器的DisplayMetrics对象，并查看相关参数。

"TestUIBase.java":

```java
DisplayMetrics dm = Resources.getSystem().getDisplayMetrics();
Log.i(TAG, "屏幕宽度：" + dm.widthPixels);
Log.i(TAG, "屏幕高度：" + dm.heightPixels);
Log.i(TAG, "像素密度：" + dm.densityDpi);
Log.i(TAG, "缩放倍率(DP)：" + dm.density);
Log.i(TAG, "缩放倍率(SP)：" + dm.scaledDensity);
```

上述内容也可以使用Kotlin语言编写：

"TestUIBase.kt":

```kotlin
val dm = Resources.getSystem().displayMetrics
Log.i(TAG, "屏幕宽度：${dm.widthPixels}")
Log.i(TAG, "屏幕高度：${dm.heightPixels}")
Log.i(TAG, "像素密度：${dm.densityDpi}")
Log.i(TAG, "缩放倍率(DP)：${dm.density}")
Log.i(TAG, "缩放倍率(SP)：${dm.scaledDensity}")
```

此时运行示例程序，并查看控制台输出信息：

```text
22:45:35.485 27731 27731 I TestApp: 屏幕宽度：1080
22:45:35.485 27731 27731 I TestApp: 屏幕高度：2160
22:45:35.485 27731 27731 I TestApp: 像素密度：480
22:45:35.485 27731 27731 I TestApp: 缩放倍率(DP)：3.0
22:45:35.485 27731 27731 I TestApp: 缩放倍率(SP)：3.0
```

---

在前文示例中，我们已经知悉设备屏幕的像素密度与缩放倍率，此时便可进行单位换算了。

🟡 示例三：DP、SP与PX之间的相互转换。

在本示例中，我们实现DP、SP与PX之间的转换方法。

"TestUIBase.java":

```java
// 将DP转换为PX
public static int dpToPX(float dpValue) {
    // "applyDimension()"方法用于将指定的非标准单位转换为像素
    float rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, Resources.getSystem().getDisplayMetrics());
    // 物理像素不可能为小数，因此保留整数部分即可。
    return Math.round(rawValue);
}

// 将SP转换为PX
public static int spToPX(float spValue) {
    float rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, Resources.getSystem().getDisplayMetrics());
    return Math.round(rawValue);
}

// 将PX转换为DP
public static int pxToDP(int pxValue) {
    // 获取缩放倍率
    float density = Resources.getSystem().getDisplayMetrics().density;
    return Math.round(pxValue / density);
}

// 将PX转换为SP
public static int pxToSP(int pxValue) {
    // 获取字体缩放倍率
    float density = Resources.getSystem().getDisplayMetrics().scaledDensity;
    return Math.round(pxValue / density);
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIBase.kt":

```kotlin
// 将DP转换为PX
private fun dpToPX(dpValue: Float): Int {
    val dm: DisplayMetrics = Resources.getSystem().displayMetrics
    // "applyDimension()"方法用于将指定的单位转换为像素
    val rawValue: Float = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, dm)
    // 物理像素不可能为小数，因此保留整数部分即可。
    return rawValue.roundToInt()
}

// 将SP转换为PX
private fun spToPX(spValue: Float): Int {
    val dm = Resources.getSystem().displayMetrics
    val rawValue = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spValue, dm)
    return rawValue.roundToInt()
}

// 将PX转换为DP
private fun pxToDP(pxValue: Int): Int {
    // 获取DP缩放倍率
    val density = Resources.getSystem().displayMetrics.density
    return (pxValue / density).roundToInt()
}

// 将PX转换为SP
private fun pxToSP(pxValue: Int): Int {
    // 获取SP缩放倍率
    val density = Resources.getSystem().displayMetrics.scaledDensity
    return (pxValue / density).roundToInt()
}
```

此时运行示例程序，并查看控制台输出信息：

```text
22:46:58.015 27731 27731 I TestApp: 100dp -> ?px: 300
22:46:58.015 27731 27731 I TestApp: 100sp -> ?px: 300
22:46:58.015 27731 27731 I TestApp: 300px -> ?dp: 100
22:46:58.015 27731 27731 I TestApp: 300px -> ?sp: 100
```

> 🚩 提示
>
> 上述代码中的DisplayMetrics对象均为主显示器，如果需要支持多显示器，我们可以新增Context参数并获取DisplayMetrics对象。


# 资源索引
Android Asset Packaging Tool(AAPT)是在APK编译阶段处理资源文件的工具，该工具会为每项资源生成全局唯一的ID，并将ID与资源路径的映射关系记录在 `.arsc` 索引文件中；在应用程序运行阶段，程序可以通过索引文件查询ID指向的路径以便访问资源文件。

以颜色资源为例，我们在示例工程的 `res/values/colors.xml` 文件中声明一条资源：

"colors.xml":

```xml
<color name="black">#000000</color>
```

然后将示例工程编译为APK，并使用Android Studio反编译该APK文件，查看资源索引的内容：

<div align="center">

![查看APK中资源索引文件的内容](./Assets_概述/查看APK中资源索引文件的内容.jpg)

</div>

对于颜色、文本等资源，AAPT会将数据值直接写入索引文件，因此我们不会在APK中看到 `colors.xml` 、 `strings.xml` 等文件；对于图像、布局文件等资源，AAPT会将资源文件复制到APK中，并通过索引文件记录存放路径。

为了便于人类阅读代码，在编码阶段我们可以通过名称引用资源，而不是直接填写数字形式的资源ID。AAPT会为每条资源生成一个常量，常量名称为无扩展名的文件名，常量值为数字ID，这些常量被放置在当前模块的 `<包名>.R` 文件中；我们可以通过常量在布局文件和代码中引用资源，提高可读性。

若要在布局文件中引用资源，可以使用 `@[<包名>:]<资源类型>/<资源名称>` 语法：

```xml
<!-- 此处已省略部分属性... -->
<TextView
    android:textColor="@color/black" />
```

若要在代码中引用资源，可以使用 `[<包名>.]R.<资源类型>.<资源名称>` 语法：

```kotlin
// 先获取当前Context的Resources实例，再获取资源。
int colorValue = getResources().getColor(R.color.common_text, getTheme());
// 直接使用当前Context的相关方法获取资源。
int colorValue2 = getColor(android.R.color.holo_blue_light);

// 使用资源
textview.setTextColor(colorValue)
textview2.setTextColor(colorValue2)
```

Resources是资源管理类，我们可以通过Context获取该类的实例并访问各种资源；部分资源与主题有关，我们可以通过Context的 `getTheme()` 获取当前主题并传入，以便获取当前主题对应的资源内容；如果我们并不关心主题，也可以传入 `null` 。

Context类提供了一些快捷方法，以便我们更方便地访问资源，例如： `Context.getColor(int id)` 等价于 `Context.getResources().getColor(int id, Theme theme)` ，且此时 `theme` 参数将自动填入Context的主题。

Resources实例提供了一些方法以便我们查看资源详情。

🟢 示例四：查看资源详情。

在本示例中，我们通过Resources类提供的方法查看资源详细信息。

"TestUIIndex.java":

```java
// 获取完整名称
String fullName = getResources().getResourceName(R.string.app_name);
// 获取资源名称
String name = getResources().getResourceEntryName(R.string.app_name);
// 获取资源类型
String type = getResources().getResourceTypeName(R.string.app_name);
// 获取资源所在包名
String pkgName = getResources().getResourcePackageName(R.string.app_name);
```

上述内容也可以使用Kotlin语言编写：

"TestUIIndexKT.kt":

```kotlin
// 获取完整名称
val fullName = resources.getResourceName(R.string.app_name)
// 获取资源名称
val name = resources.getResourceEntryName(R.string.app_name)
// 获取资源类型
val type = resources.getResourceTypeName(R.string.app_name)
// 获取资源所在包名
val pkgName = resources.getResourcePackageName(R.string.app_name)
```

此时运行示例程序，并查看控制台输出信息：

```text
07:16:28.568  9921 9921 I TestApp: 完整名称：net.bi4vmr.study.ui.resource.base:string/app_name
07:16:28.568  9921 9921 I TestApp: 资源名称：app_name
07:16:28.568  9921 9921 I TestApp: 资源类型：string
07:16:28.568  9921 9921 I TestApp: 资源包名：net.bi4vmr.study.ui.resource.base
```

根据上述输出内容可知：

资源名称的完整格式为： `<包名>:<资源类型>/<资源名称>` ，当我们引用当前工程中定义的资源时，可以省略包名；当我们引用外部模块中定义的资源时，必须指明其所在的包名。

当我们想要获取Android SDK内置的资源时，需要将包名指明为 `android` ，例如： `@android:color/black` 或 `android.R.color.black` 表示引用SDK内置的“黑色”资源。


<!-- TODO
# 资源后缀

-night限定符




# 外部资源
## 其他软件包
除了使用当前工程的资源之外，我们还可以引用外部工程的

## APK文件

-->


# 调试命令
## 语法
我们可以通过ADB Shell查看或修改显示参数，以便进行调试。

下文内容介绍了与显示参数相关的命令语法。

🔶 查看或修改分辨率

以下命令可以查看或修改屏幕分辨率：

```text
ADB$ wm size [<长>x<宽>] [-d <DisplayID>]
```

当我们不指定 `[<长>x<宽>]` 时，该命令将会显示指定屏幕的分辨率，当我们指定 `[<长>x<宽>]` 时，将会更改指定屏幕的分辨率。

🔶 重置分辨率

以下命令可以重置屏幕分辨率：

```text
ADB$ wm size reset [-d <DisplayID>]
```

当我们修改分辨率后，系统将会一直沿用该配置，直到恢复出厂设置；如果调试完毕需要恢复默认分辨率，我们也可以使用 `wm size reset` 命令。

🔶 查看或修改像素密度

以下命令可以查看或修改屏幕像素密度：

```text
ADB$ wm density [PPI值] [-d <DisplayID>]
```

当我们不指定PPI值时，该命令将会显示指定屏幕的PPI值，当我们指定PPI值时，将会更改指定屏幕的PPI值。

🔶 重置像素密度

以下命令可以重置屏幕像素密度：

```text
ADB$ wm density reset [-d <DisplayID>]
```

当我们修改像素密度后，系统将会一直沿用该配置，直到恢复出厂设置；如果调试完毕需要恢复默认像素密度，我们也可以使用 `wm density reset` 命令。
