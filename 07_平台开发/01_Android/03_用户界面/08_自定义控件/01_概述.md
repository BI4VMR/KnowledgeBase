# 简介
Android SDK、Material Design以及第三方库提供了丰富的UI控件，但有时仍然无法满足我们的需求，此时我们就需要制作自定义控件。

自定义控件有以下几种实现方式：

- 组合现有控件：将多个子控件组合为一个新的控件，封装子控件之间的联动逻辑，以便多处复用。
- 继承现有控件：继承现有的控件或布局，为其扩展新的功能。
- 自由定制控件：利用系统提供的图形能力，自由地编写绘图逻辑。

本章示例工程详见以下链接：

[🔗 示例工程：概述](https://github.com/BI4VMR/Study-Android/tree/master/M03_UI/C07_CtrlCustom/S01_Base)


# 基本应用
下文示例展示了自定义控件的基本使用方法：

🔴 示例一：通过组合现有控件的方式创建“名片”控件。

在本示例中，我们通过组合现有控件的方式，实现一个名片控件，展示自定义控件的制作方法。

第一步，我们创建一个布局文件并放置若干控件，用于描述“名片”的外观。

"business_card.xml":

```xml
<!-- 此处已省略部分属性... -->
<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/shape_business_card_background">

    <ImageView
        android:id="@+id/ivAvatar"
        android:layout_width="64dp"
        android:layout_height="64dp" />

    <TextView
        android:id="@+id/tvName"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        tools:text="[名称]" />

    <TextView
        android:id="@+id/tvPhone"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        tools:text="[电话号码]" />
</androidx.constraintlayout.widget.ConstraintLayout>
```

在上述布局文件中，ImageView用于显示头像，两个TextView分别用于显示姓名和电话号码。

第二步，我们创建BusinessCard类，实现控件内部逻辑并加载上述布局文件。

"BusinessCard.java":

```java
public class BusinessCard extends FrameLayout {

    private ImageView ivAvatar;
    private TextView tvName;
    private TextView tvPhone;

    // 构造方法1
    public BusinessCard(@NonNull Context context) {
        super(context);
        // 将布局文件渲染生成View实例
        View view = LayoutInflater.from(context).inflate(R.layout.business_card, this, true);
        // 获取View实例中各个子元素的引用
        ivAvatar = view.findViewById(R.id.ivAvatar);
        tvName = view.findViewById(R.id.tvName);
        tvPhone = view.findViewById(R.id.tvPhone);
    }

    // 构造方法2
    public BusinessCard(@NonNull Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        /* 初始化操作 ... */
    }

    // 构造方法3
    public BusinessCard(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        /* 初始化操作 ... */
    }

    // 构造方法4
    public BusinessCard(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        /* 初始化操作 ... */
    }

    // 更新文本与图像资源
    public void updateInfo(String name, String phone, @DrawableRes int avatarResID) {
        tvName.setText(name);
        tvPhone.setText(phone);
        ivAvatar.setImageResource(avatarResID);
    }
}
```

上述内容也可以使用Kotlin语言编写：

"BusinessCardKT.kt":

```kotlin
class BusinessCardKT : FrameLayout {

    private val binding: BusinessCardBinding by lazy {
        // 将布局文件渲染生成View实例
        BusinessCardBinding.inflate(LayoutInflater.from(context), this, true)
    }

    // 构造方法1
    constructor(context: Context) : super(context)

    // 构造方法2
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)

    // 构造方法3
    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr)

    // 构造方法4
    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int, defStyleRes: Int) : super(
        context,
        attrs,
        defStyleAttr,
        defStyleRes
    )

    // 更新文本与图像资源
    fun updateInfo(name: String, phone: String, @DrawableRes avatarResID: Int) {
        with(binding) {
            tvName.text = name
            tvPhone.text = phone
            ivAvatar.setImageResource(avatarResID)
        }
    }
}
```

View拥有四个构造方法，当我们在代码中创建控件实例时，需要调用 `BusinessCard(Context context)` 构造方法，此处需要实现控件的初始化逻辑；当LayoutInflater解析布局文件生成控件实例时，将会调用 `BusinessCard(Context context, AttributeSet attrs)` 构造方法，第二参数 `attrs` 表示XML中的控件属性，此处需要实现控件的初始化逻辑，并解析XML属性。

具有一个参数与两个参数的构造方法是必选的，它们覆盖了动态创建View与通过XML声明View的场景。另外两个构造方法的参数 `defStyleAttr` 和 `defStyleRes` 与主题和样式有关，此处将其忽略，后文示例将详细介绍它们。

> ⚠️ 警告
>
> 当我们使用ViewBinding时，必须调用具有3个参数的 `inflate()` 方法以获取ViewBinding实例，并将 `attachToParent` 参数置为 `true` ；否则布局将不会关联到顶层容器，导致程序运行时控件显示为空白画面。

`updateInfo()` 方法即BusinessCard控件对外暴露的业务接口，我们将该方法参数传入的文本与图片资源分别设置到对应的控件中，实现动态更新UI的功能。

如果我们使用Kotlin语言编写控件，还可以利用默认参数将构造方法合并为一个，进一步简化代码：

"BusinessCardSimpleKT.kt":

```kotlin
class BusinessCardSimpleKT @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0,
    defStyleRes: Int = 0
) : FrameLayout(context, attrs, defStyleAttr, defStyleRes) {

    init {
        // 在此处放置构造阶段的初始化逻辑...
    }

    // 此处已省略部分代码...
}
```

至此，自定义控件“名片”已经制作完毕了，接下来我们切换到控件调用者视角，创建控件实例并使用它。

第三步，我们调用具有一个参数的构造方法，创建名片控件实例，设置姓名、电话与头像，并将其添加到测试Activity的视图容器中。

"TestUIBase.java":

```java
// 构建BusinessCard实例
BusinessCard businessCard = new BusinessCard(this);
// 设置文本与图像
businessCard.updateInfo("田所浩二", "11451419198", R.drawable.ic_funny_256);
// 将其添加到布局中
binding.container.addView(businessCard);
```

上述内容也可以使用Kotlin语言编写：

"TestUIBaseKT.kt":

```kotlin
// 构建BusinessCard实例
val businessCard = BusinessCardKT(this)
// 设置文本与图像
businessCard.updateInfo("田所浩二", "11451419198", R.drawable.ic_funny_256)
// 将其添加到布局中
binding.container.addView(businessCard)
```

此时运行示例程序，并查看界面外观：

<div align="center">

![名片控件的显示效果](./Assets_概述/基本应用_名片控件的显示效果.jpg)

</div>


# XML属性
## 基本应用
在前文“示例一”中，我们已经知晓了自定义控件的制作方法，但BusinessCard控件只能利用 `updateInfo()` 方法更新UI，无法解析XML属性。本节内容将介绍XML属性的定义与解析方法，为BusinessCard控件添加自定义XML属性支持。

🟠 示例二：为“名片”控件添加XML属性支持。

在本示例中，我们为BusinessCard控件添加自定义XML属性支持。

第一步，我们在 `<模块根目录>/src/main/res/values/` 目录中创建一个属性声明文件 `attrs_business_card.xml` ，并在其中声明一些属性。

"attrs_business_card.xml":

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="BusinessCard2">
        <attr name="name" format="string" />
        <attr name="phone" format="string" />
        <attr name="avatar" format="reference" />
    </declare-styleable>
</resources>
```

每个 `<declare-styleable/>` 小节表示一个属性集合，它的名称应当与自定义控件的类名保持一致，以提高可读性。

每个 `<attr/>` 小节表示一条属性，配置项 `name` 表示名称；配置项 `format` 表示数据类型。此处的“姓名("name")”与“电话号码("phone")”属性接受文本类型数据，使用者可以传入字符串或文本资源ID；“头像("avatar")”属性接受资源引用类型数据，使用者可以传入图像或颜色资源ID。

第二步，我们对前文“示例一”中的BusinessCard控件进行修改，为其添加解析XML属性的相关代码。

"BusinessCard2.java":

```java
public class BusinessCard2 extends FrameLayout {

    private BusinessCardBinding binding;

    // 构造方法1
    public BusinessCard2(@NonNull Context context) {
        // 调用构造方法2，XML属性集合传入空值，避免重复书写“初始化视图”的逻辑。
        this(context, null);
    }

    // 构造方法2
    public BusinessCard2(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, 0);
    }

    // 构造方法3
    public BusinessCard2(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, 0, 0);
    }

    // 构造方法4
    public BusinessCard2(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);

        // 初始化视图
        initView();

        // 如果当前实例不是通过布局文件生成的，则不必解析XML属性。
        if (attrs == null) {
            return;
        }

        // 获取自定义属性数组
        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.BusinessCard2, defStyleAttr, defStyleRes);
        // 获取属性，并设置到子控件上。
        if (ta.hasValue(R.styleable.BusinessCard2_name)) {
            String name = ta.getString(R.styleable.BusinessCard2_name);
            binding.tvName.setText(name);
        }
        if (ta.hasValue(R.styleable.BusinessCard2_phone)) {
            String phone = ta.getString(R.styleable.BusinessCard2_phone);
            binding.tvPhone.setText(phone);
        }
        if (ta.hasValue(R.styleable.BusinessCard2_avatar)) {
            Drawable avatar = ta.getDrawable(R.styleable.BusinessCard2_avatar);
            binding.ivAvatar.setImageDrawable(avatar);
        }

        // 释放TypedArray资源
        ta.recycle();
    }

    // 初始化视图
    private void initView() {
        binding = BusinessCardBinding.inflate(LayoutInflater.from(getContext()), this, true);
    }
}
```

上述内容也可以使用Kotlin语言编写：

"BusinessCard2KT.kt":

```kotlin
class BusinessCard2KT @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0,
    defStyleRes: Int = 0
) : FrameLayout(context, attrs, defStyleAttr, defStyleRes) {

    companion object {
        private val TAG: String = "TestApp-${BusinessCard2KT::class.java.simpleName}"
    }

    private val binding: BusinessCardBinding by lazy {
        // 将布局文件渲染生成View实例
        BusinessCardBinding.inflate(LayoutInflater.from(context), this, true)
    }

    init {
        // 初始化视图
        // 此处留空，因为"binding"变量已经通过"lazy"函数延迟初始化。

        // 如果当前实例不是通过布局文件生成的，则不必解析XML属性。
        if (attrs != null) {
            // 获取自定义属性数组
            val ta: TypedArray =
                context.obtainStyledAttributes(attrs, R.styleable.BusinessCard2, defStyleAttr, defStyleRes)
            ta.use {
                if (ta.hasValue(R.styleable.BusinessCard2_name)) {
                    val name: String? = ta.getString(R.styleable.BusinessCard2_name)
                    binding.tvName.text = name
                }
                if (ta.hasValue(R.styleable.BusinessCard2_phone)) {
                    val phone: String? = ta.getString(R.styleable.BusinessCard2_phone)
                    binding.tvPhone.text = phone
                }
                if (ta.hasValue(R.styleable.BusinessCard2_avatar)) {
                    val avatar: Drawable? = ta.getDrawable(R.styleable.BusinessCard2_avatar)
                    binding.ivAvatar.setImageDrawable(avatar)
                }
            }
        }
    }
}
```

`attrs` 、 `defStyleAttr` 和 `defStyleRes` 参数只在LayoutInflater解析布局文件时才会被传递，我们通过代码创建控件实例时只会调用 `BusinessCard2(Context context)` 构造方法。我们可以使参数较少的构造方法调用参数较多的构造方法，并将多余的参数设为默认值，此时初始化逻辑只需要在参数最多的构造方法中统一编写，我们根据 `attrs` 是否为空值即可判断是否需要解析XML属性，不必为每个构造方法单独编写初始化逻辑。

XML属性参数 `attrs` 是AttributeSet类型，属性的值为原始文本或资源引用地址，不便于我们进一步使用，因此我们需要通过Context实例的 `obtainStyledAttributes()` 方法将AttributeSet转换为TypedArray。

TypedArray提供了数据类型转换和解资源引用的功能，此处我们首先通过 `hasValue(int index)` 方法判断控件调用者是否在布局文件中指定了对应的属性，若属性存在，则调用 `getString(int index)` 、 `getDrawable(int index)` 等方法将属性值转为对应类型，然后设置到子控件上。

至此，自定义控件“名片”已经支持了XML属性解析能力，接下来我们切换到控件调用者视角，创建控件实例并使用它。

第三步，我们在测试Activity的布局文件中添加“名片”控件，并使用前文定义的三个属性设置数据。

```xml
<net.bi4vmr.study.xmlattrs.BusinessCard2
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:avatar="@drawable/ic_funny_256"
    app:name="田所浩二"
    app:phone="11451419198" />
```

## 属性类型
<!-- TODO -->

format="string"指明了类型


<div align="center">

|  类型  | format名称 |
| :----: | :--------: |
| 布尔值 |  boolean   |
|  整型  |  integer   |
| 浮点型 |   float    |


</div>




 String getString(@StyleableRes int index) 未定义或无法转换则返回空值

float getDimension(@StyleableRes int index, float defValue) 返回维度数


kot

调用了hasValue(index)判断是否存在，若不存在则抛异常IllegalArgumentException



getStringOrThrow(@StyleableRes index: Int): String


### 基本数据类型
基本数据类型属性包括布尔型、整型、浮点型三种数据。

TypedArray提供了以下方法用于从XML解析基本数据类型属性的值：

- `boolean getBoolean(int index, boolean defValue)` : 将属性 `index` 的值解析为布尔值；若调用者未指定该属性或类型不匹配，则返回默认值 `defValue` 。
- `int getInt(int index, int defValue)` : 将属性 `index` 的值解析为整型值；若调用者未指定该属性或类型不匹配，则返回默认值 `defValue` 。
- `int getInteger(int index, int defValue)` : 将属性 `index` 的值解析为整型值；若调用者未指定该属性，则返回默认值 `defValue` ；若类型不匹配则抛出UnsupportedOperationException异常
- `float getFloat(int index, float defValue)` : 将属性 `index` 的值解析为浮点值；若调用者未指定该属性或类型不匹配，则返回默认值 `defValue` 。

如果我们使用Kotlin语言并引入了 `core-ktx` 组件，还可以调用TypedArray提供的一些扩展方法：

- `getBooleanOrThrow(@StyleableRes index: Int): Boolean`
- `getIntOrThrow(@StyleableRes index: Int): Int`
- `getIntegerOrThrow(@StyleableRes index: Int): Int`
- `getFloatOrThrow(@StyleableRes index: Int): Float`

它们与同前缀的Java方法功能类似，但要求控件调用者必须指定 `index` 对应的属性，否则抛出IllegalArgumentException异常。

🟡 示例三：基本数据类型属性的使用方法。

在本示例中，我们定义一些基本数据类型的XML属性，并在自定义View中解析它们。

第一步，我们在资源文件中编写以下内容，声明一些属性：

"attrs_type.xml":

```xml
<resources>
    <declare-styleable name="AttrTypes">
        <!-- 定义属性：基本数据类型 -->
        <attr name="booleanValue" format="boolean" />
        <attr name="integerValue" format="integer" />
        <attr name="floatValue" format="float" />
    </declare-styleable>
</resources>
```

名为 `booleanValue` 的属性值是布尔类型；名为 `integerValue` 的属性值是整型；名为 `floatValue` 的属性值是浮点型。

第二步，我们在自定义控件中编写逻辑代码，从控件的XML属性中解析属性值。

"AttrTestView.java":

```java
TypedArray ta = getContext().obtainStyledAttributes(attrs, R.styleable.AttrTypes);

// 获取布尔值
boolean booleanValue = ta.getBoolean(R.styleable.AttrTypes_booleanValue, false);
tvBooleanValue.setText(booleanValue + "");

// 获取整型值
int intValue = ta.getInt(R.styleable.AttrTypes_integerValue, 0);
tvIntegerValue.setText(intValue + "");

// 获取浮点值
float floatValue = ta.getFloat(R.styleable.AttrTypes_floatValue, 0.0F);
tvFloatValue.setText(floatValue + "");

ta.recycle();
```

上述内容也可以使用Kotlin语言编写：

"AttrTestViewKT.kt":

```kotlin
context.obtainStyledAttributes(attrs, R.styleable.AttrTypes).use {
    // 获取布尔值
    val booleanValue: Boolean = it.getBoolean(R.styleable.AttrTypes_booleanValue, false)
    tvBooleanValue.text = booleanValue.toString()

    // 获取整型值
    val intValue: Int = it.getInt(R.styleable.AttrTypes_integerValue, 0)
    tvIntegerValue.text = intValue.toString()

    // 获取浮点值
    val floatValue: Float = it.getFloat(R.styleable.AttrTypes_floatValue, 0.0F)
    tvFloatValue.text = floatValue.toString()
}
```

以 `getBoolean()` 方法为例，它会尝试将 `R.styleable.AttrTypes_booleanValue` 属性的值转换为布尔类型，如果调用者没有定义该属性，或属性值无法被识别为布尔类型，则返回默认值 `false` 。

第三步，我们切换到调用者视角，在布局文件中为AttrTestView指定属性与值。

"testui_xmlattrs.xml":

```xml
<net.bi4vmr.study.xmlattrs.AttrTestView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:booleanValue="true"
    app:floatValue="0.05"
    app:integerValue="-1000" />
```

此时运行示例程序，AttrTestView应当显示了XML中所设置的值。

### 枚举



"attrs_type.xml":

```xml
<declare-styleable name="AttrTypes">
    <!-- 定义属性：枚举类型 -->
    <attr name="enumValue" format="enum">
        <enum name="vertical" value="0" />
        <enum name="horizontal" value="1" />
    </attr>
</declare-styleable>
```

编写解析逻辑


"AttrTestView.java":

```java
        // 获取枚举值
        int enumIndex = ta.getInt(R.styleable.AttrTypes_enumValue, 0);
        tvEnumValue.setText(enumIndex + "");
```


作为使用者，再XML中设置属性

"testui_xmlattrs":

```xml
<net.bi4vmr.study.xmlattrs.AttrTestView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:enumValue="horizontal" />
```

此时文本框 `tvEnumValue` 的数值应当为"1"，与枚举定义中horizontal的value对应

### 标志位



"attrs_type.xml":

```xml
<declare-styleable name="AttrTypes">
    <!-- 定义属性：枚举类型 -->
    <attr name="enumValue" format="enum">
        <enum name="vertical" value="0" />
        <enum name="horizontal" value="1" />
    </attr>
</declare-styleable>
```

编写解析逻辑


"AttrTestView.java":

```java
        // 获取枚举值
        int enumIndex = ta.getInt(R.styleable.AttrTypes_enumValue, 0);
        tvEnumValue.setText(enumIndex + "");
```


作为使用者，再XML中设置属性

"testui_xmlattrs":

```xml
<net.bi4vmr.study.xmlattrs.AttrTestView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    app:enumValue="horizontal" />
```

此时文本框 `tvEnumValue` 的数值应当为"1"，与枚举定义中horizontal的value对应


### 组合类型
部分类型能够支持多种类型的原始数据，例如getDrawable能够支持颜色、drawable、mipmap等输入值