# 简介
在操作系统中，一个进程无法直接访问另一个进程的内存，为了实现进程间通信(IPC)，我们需要定义客户端与服务端均认可的编程接口，以实现双方的数据交互。

Android平台提供了AIDL(Android Interface Definition Language)，用于描述跨进程通信所使用的接口，AIDL文件会被Gradle编译并生成对应的Java代码，我们可以通过绑定服务的方式使用这些代码提供的接口，与其他应用程序进行交互。

AIDL接口支持以下数据类型：

- Java中的基本数据类型
- String和CharSequence类型
- Map和List类型
- Parcelable类型

如果我们需要传递自定义类型的数据，必须为其实现Parcelable接口，以便进行序列化传输。

本章的示例工程详见以下链接：

- [🔗 示例工程：远程服务 - 服务端](https://github.com/BI4VMR/Study-Android/tree/master/M04_System/C02_Service/S05_AIDL-Server)
- [🔗 示例工程：远程服务 - 客户端](https://github.com/BI4VMR/Study-Android/tree/master/M04_System/C02_Service/S05_AIDL-Client)


# 基本应用
下文示例展示了AIDL的基本使用方法：

🔴 示例一：AIDL的基本应用。

在本示例中，我们通过AIDL实现前文示例中的下载服务，进行简单的跨进程通信。

第一步，我们编写AIDL接口，定义服务端所支持的能力。

AIDL文件的后缀为 `.aidl` ，应当放置于 `<模块根目录>/src/main/aidl/<包名>/` 目录中，此处的 `<包名>` 决定了AIDL文件编译生成的Java文件所在目录。

我们首先创建一个新的工程作为服务端，并创建AIDL文件 `src/main/aidl/net/bi4vmr/aidl/IDownloadService.aidl` ，填写以下内容：

"IDownloadService.aidl":

```java
package net.bi4vmr.aidl;

interface IDownloadService {

    // 获取服务端进程ID
    int getPID();

    // 添加任务并开始下载
    void addTask(in String url);

    // 获取任务列表
    List<String> getTasks();
}
```

AIDL文件的语法与Java接口类似， `package` 语句中的路径为该文件在 `<模块根目录>/src/main/aidl/` 目录内的路径。

AIDL接口中的引用类型数据默认都不可为空，如果我们需要可空的参数或返回值，需要添加 `@nullable` 注解，例如： `void addTask(in @nullable String url)` 。

第二步，我们在服务端实现AIDL接口，提供接口对应的能力。

我们首先为服务端工程执行一次Make或Build任务，使Gradle生成AIDL对应的Java类。编译完成后，我们可以检查模块的 `build/generated/aidl_source_output_dir/debug/out` 目录中是否存在 `IDownloadService.java` 等文件。

IDownloadService类中有一个抽象类IDownloadService.Stub，它继承自Binder类，Binder即Android系统的核心RPC机制。我们需要在服务端Service内实现IDownloadService.Stub中的抽象方法，编写具体的业务逻辑。

"DownloadService.java":

```java
public class DownloadService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
        return new DownloadImpl();
    }

    // AIDL接口的实现类
    private static class DownloadImpl extends IDownloadService.Stub {

        // 任务集合
        private final List<String> tasks = new ArrayList<>();

        // 获取服务端进程ID
        @Override
        public int getPID() {
            int pid = Process.myPid();
            return pid;
        }

        // 添加下载任务
        @Override
        public void addTask(String url) {
            // 在此处实现下载业务，此处省略。
            tasks.add(url);
        }

        // 查询下载任务
        @Override
        public List<String> getTasks() {
            return tasks;
        }
    }
}
```

上述内容也可以使用Kotlin语言编写：

"DownloadServiceKT.kt":

```kotlin
data class DownloadItemKT(
    var id: Int,
    var url: String,
    var percent: Float
) : Parcelable {

    companion object CREATOR : Parcelable.Creator<DownloadItemKT> {
        override fun createFromParcel(parcel: Parcel): DownloadItemKT {
            return DownloadItemKT(parcel)
        }

        override fun newArray(size: Int): Array<DownloadItemKT?> {
            return arrayOfNulls(size)
        }
    }

    constructor(parcel: Parcel) : this(
        // 按属性顺序从Parcel容器中读出属性值
        id = parcel.readInt(),
        url = parcel.readString() ?: "",
        percent = parcel.readFloat()
    )

    override fun describeContents(): Int {
        return 0
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        // 按属性顺序向Parcel容器中写入属性值
        parcel.apply {
            writeInt(id)
            writeString(url)
            writeFloat(percent)
        }
    }
}
```

Service编写完成后，我们在Manifest文件中注册该组件，并设置一个Action标签，以便客户端绑定它。

"AndroidManifest.xml":

```xml
<service
    android:name=".base.DownloadService"
    android:exported="true"
    android:process=":service">

    <intent-filter>
        <action android:name="net.bi4vmr.aidl.DOWNLOAD" />
    </intent-filter>
</service>
```

在上述配置文件中，我们声明了 `android:process=":service"` 属性，因此DownloadService将会运行在名为 `<服务端包名>:service` 的独立进程中，即使我们从服务端的默认进程 `<服务端包名>` 绑定该服务，也属于跨进程通信。

第三步，我们在客户端绑定该服务，并调用AIDL接口。

客户端若要访问AIDL接口，需要能够引用AIDL文件编译生成的Java类。此处我们为了方便进行实验，直接将AIDL文件从服务端复制到客户端工程，并保持相同的目录结构，由客户端编译生成Java类。

在实际应用中，我们通常会将AIDL文件作为一个独立的模块，由服务端依赖该模块并实现业务接口逻辑，由客户端依赖该模块并实现绑定、解绑等状态管理，然后将客户端作为JAR包或AAR包发布到Maven仓库；调用者无需关心客户端的内部实现，只需集成客户端SDK即可远程调用服务端提供的能力。

远程服务的使用方法与本地服务类似，都需要通过 `bindService()` 方法进行绑定，并在 `onServiceConnected()`回调中获取IBinder实现类，然后调用业务接口。

"TestUIBase.java":

```java
public class TestUIBase extends AppCompatActivity {

    private final ServiceConnection connection = new DLServiceConnection();
    private IDownloadService downloadService;
    private boolean isServiceConnected = false;

    /**
     * 服务连接回调实现类。
     */
    private class DLServiceConnection implements ServiceConnection {

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 使用Stub抽象类的 `asInterface()` 方法将Binder对象转换为对应的Service对象。
            downloadService = IDownloadService.Stub.asInterface(service);
            // 将连接标记位置为 `true` ，此时可以进行远程调用。
            isServiceConnected = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            // 将连接标记位置为 `false`
            isServiceConnected = false;
            // 将Service实例置空
            downloadService = null;
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        /* 绑定服务 */
        Intent intent = new Intent();
        // 远程服务所在软件包名
        intent.setPackage("net.bi4vmr.study.system.service.aidlserver");
        // 远程服务的Action参数
        intent.setAction("net.bi4vmr.aidl.DOWNLOAD");
        // 绑定服务
        boolean result = bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIBaseKT.kt":

```kotlin
class TestUIBaseKT : AppCompatActivity() {

    private val connection: DLServiceConnection = DLServiceConnection()
    private var downloadService: IDownloadService? = null
    private var isServiceConnected: Boolean = false

    /**
     * 服务连接回调实现类。
     */
    private inner class DLServiceConnection : ServiceConnection {

        override fun onServiceConnected(name: ComponentName, service: IBinder) {
            // 使用Stub抽象类的 `asInterface()` 方法将Binder对象转换为对应的Service对象。
            downloadService = IDownloadService.Stub.asInterface(service)
            // 将连接标记位置为 `true` ，此时可以进行远程调用。
            isServiceConnected = true
        }

        override fun onServiceDisconnected(name: ComponentName) {
            // 将连接标记位置为 `false`
            isServiceConnected = false
            // 将Service实例置空
            downloadService = null
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        /* 绑定服务 */
        val intent = Intent()
        // 远程服务所在软件包名
        intent.setPackage("net.bi4vmr.study.system.service.aidlserver")
        // 远程服务的Action参数
        intent.setAction("net.bi4vmr.aidl.DOWNLOAD")
        // 绑定服务
        val result: Boolean = bindService(intent, connection, Context.BIND_AUTO_CREATE)
    }
}
```

AIDL编译生成的Java代码中， `IDownloadService.Stub.asInterface()` 方法可以将 `onServiceConnected()` 回调方法中的第二参数 `service` 转换为IDownloadService类型，方便后续调用业务接口。

接下来，我们便可通过 `downloadService` 实例调用服务端的业务方法，此处以 `addTask()` 接口为例：

"TestUIBase.java":

```java
public void testAddTask() {
    // 根据连接状态标志位和Binder状态检测确定是否能够访问接口
    if (!isServiceConnected || !downloadService.asBinder().isBinderAlive()) {
        Log.i(TAG, "连接未就绪！");
        return;
    }

    try {
        String task = "https://test.net/1.txt";
        downloadService.addTask(task);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
```

上述内容也可以使用Kotlin语言编写：

"TestUIBaseKT.kt":

```kotlin
private fun testAddTask() {
    // 根据连接状态标志位和Binder状态检测确定是否能够访问接口
    if (!isServiceConnected || downloadService?.asBinder()?.isBinderAlive != true) {
        Log.i(TAG, "连接未就绪！")
        return
    }

    try {
        val task = "https://test.net/1.txt"
        requireNotNull(downloadService).addTask(task)
    } catch (e: RemoteException) {
        appendLog(e.message ?: "未知错误。")
        e.printStackTrace()
    }
}
```

在真正执行远程调用之前，我们需要先判断服务的连接状态是否为就绪，并检测服务端进程是否正常运行（防止服务端进程崩溃但还没来得及通知客户端）。在远程调用过程中，除了业务自身的异常，还可能发生远程调用异常：RemoteException，因此我们最好添加异常捕获语句。


# 自定义数据类型
Binder支持通过Parcel容器对数据进行序列化传输，对于自定义数据类型，我们可以为其实现Parcelable接口，随后即可在AIDL接口中使用它们。

关于Parcelable接口的知识详见相关章节： [🧭 Parcelable接口](../01_通用组件/05_Parcelable接口.md) 。

🟠 示例二：通过AIDL接口传递自定义类型对象。

在本示例中，我们以前文“示例一”为基础，将表示下载任务的数据类型从String改为自定义类型。

第一步，我们定义实体类，用来表示下载任务。

"DownloadItem.java":

```java
public class DownloadItem implements Parcelable {

    // 任务ID
    private int id;
    // 下载地址
    private String url;
    // 进度
    private float percent;

    public static final Creator<DownloadItem> CREATOR = new Creator<DownloadItem>() {
        @Override
        public DownloadItem createFromParcel(Parcel in) {
            return new DownloadItem(in);
        }

        @Override
        public DownloadItem[] newArray(int size) {
            return new DownloadItem[size];
        }
    };

    // Parcel构造方法
    protected DownloadItem(Parcel in) {
        // 按属性顺序从Parcel容器中读出属性值
        id = in.readInt();
        url = in.readString();
        percent = in.readFloat();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        // 按属性顺序向Parcel容器中写入属性值
        dest.writeInt(id);
        dest.writeString(url);
        dest.writeFloat(percent);
    }

    /* 此处省略Get、Set与构造方法... */
}
```

上述内容也可以使用Kotlin语言编写：

"DownloadItemKT.kt":

```kotlin
data class DownloadItemKT(
    var id: Int,
    var url: String,
    var percent: Float
) : Parcelable {

    companion object CREATOR : Parcelable.Creator<DownloadItemKT> {
        override fun createFromParcel(parcel: Parcel): DownloadItemKT {
            return DownloadItemKT(parcel)
        }

        override fun newArray(size: Int): Array<DownloadItemKT?> {
            return arrayOfNulls(size)
        }
    }

    constructor(parcel: Parcel) : this(
        // 按属性顺序从Parcel容器中读出属性值
        id = parcel.readInt(),
        url = parcel.readString() ?: "",
        percent = parcel.readFloat()
    )

    override fun describeContents(): Int {
        return 0
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        // 按属性顺序向Parcel容器中写入属性值
        parcel.apply {
            writeInt(id)
            writeString(url)
            writeFloat(percent)
        }
    }
}
```

第二步，我们在AIDL接口中将DownloadItem分别作为参数和返回值。

若要在AIDL接口中使用实现了Parcelable接口的类型，我们首先需要创建一个AIDL文件描述该类型。

"DownloadItem.aidl":

```java
// 该路径为同名Java类所在的包
package net.bi4vmr.study.types;

// 声明其类型为Parcelable
parcelable DownloadItem;
```

此处的 `package` 包名为同名Java类所在路径， `parcelable` 表示需要通过Parcel方式序列化与反序列化。

接下来，我们就可以在其他AIDL文件中将该类型作为参数或返回值。

"IDownloadService2.aidl":

```java
// 该路径为对应AIDL文件所在的包
import net.bi4vmr.aidl.entity.DownloadItem;

interface IDownloadService2 {

    // 添加任务并开始下载
    void addTask(in DownloadItem task);

    // 获取任务列表
    List<DownloadItem> getTasks();
}
```

此处的 `import` 语句应当指向 `DownloadItem.aidl` 在AIDL源码集中的包名，而非 `DownloadItem.java` 在Java源码集中的包名。

第三步，我们在服务端与客户端分别执行一次Make或Build任务，然后修改接口实现，适配新的数据类型。

# 数据方向标签
在定义AIDL接口时，我们可以为部分参数指定一个数据方向标签，例如前文“示例二”中的 `addTask(in DownloadItem task)` 接口。该标签可以取值为 `in` 、 `out` 或 `inout` ，用于控制两个进程之间参数的同步情况。

为了说明数据方向标签的作用，我们首先回顾一下Java中基本数据类型与引用数据类型参数传值行为的差异。

🟡 示例三：基本与引用数据类型参数的区别。

在本示例中，我们在方法内部分别修改基本与引用数据类型参数的值，并在方法外部观察它们。

"TestDataTypes.java":

```java
public class TestDataTypes {

    public static void main(String[] args) {
        int num = 1;
        List<String> list = new ArrayList<>();
        list.add("a");
        System.out.println("初始情况 - Num：" + num);
        System.out.println("初始情况 - List：" + list);

        // 调用方法修改"num"和"list"的值
        add(num, list);

        // 方法执行后，"num"和"list"的值。
        System.out.println("方法外部 - Num：" + num);
        System.out.println("方法外部 - List：" + list);
    }

    static void add(int num, List<String> argList) {
        // 改变参数的值（向列表中添加一项）
        num += 1;
        // 改变参数的值（向列表中添加一项）
        argList.add("b");

        System.out.println("方法内部 - Num：" + num);
        System.out.println("方法内部 - List：" + argList);
    }
}
```

此时运行示例程序，并查看控制台输出信息：

```text
初始情况 - Num：1
初始情况 - List：[a]
方法内部 - Num：2
方法内部 - List：[a, b]
方法外部 - Num：1
方法外部 - List：[a, b]
```

根据上述输出内容可知：

在 `add()` 方法内部修改变量后，基本数据类型的原始变量 `num` 没有被修改，而引用数据类型的原始变量 `list` 也被同步修改了。

对于基本数据类型变量，其中存储的是值本身，传递给方法时将会被复制为临时变量，在方法内部修改临时变量不影响原变量。对于引用数据类型变量，其中存储的是指向值内存空间的地址，传递给方法时临时变量仍然指向同一内存区域，因此在方法内部修改临时变量等同于修改原变量。

由于AIDL是跨进程的通信机制，同一个参数在客户端与服务端进程各自拥有不同的内存地址，若要与上述示例中的行为保持一致，在服务端修改参数后同步变化给客户端，将会带来额外的性能开销。在实际应用中，并不是所有场景都必须保证两端参数的一致性，因此AIDL设计了方向标签用来控制同步方式。

三种标签及其含义如下文内容所示：

🔶 `in` 标签

客户端参数的值可以传递给服务端，但如果服务端更改了此参数，变化不会同步给客户端。

在前文“示例三”中，假如我们定义AIDL接口 `add(in List<String> argList)` 并通过客户端调用它，服务端将会收到内容为 `[a]` 的列表。当服务端对表项进行增减且RPC过程结束后，客户端列表内容仍为 `[a]` ，不会同步变化。

🔶 `out` 标签

客户端参数的值不会传递给服务端，服务端将会收到一个值为空的参数；如果服务端更改了此参数的值，变化将会同步给客户端。

在前文“示例三”中，假如我们定义AIDL接口 `add(out List<String> argList)` 并通过客户端调用它，服务端将会收到内容为空的列表。当服务端对表项进行增减（例如新增一个表项 `b` ）且RPC过程结束后，客户端列表内容也将同步变更为 `[a, b]` 。

🔶 `inout` 标签

客户端参数的值可以传递给服务端，并且服务端对参数的修改也会在RPC结束后同步给客户端。

在前文“示例三”中，假如我们定义AIDL接口 `add(inout List<String> argList)` 并通过客户端调用它，服务端将会收到内容为 `[a]` 的列表，当服务端对表项进行增减且RPC过程结束后，客户端列表内容也将同步变更为 `[a, b]` ，此时RPC行为与本地方法调用是一致的，但性能最低。

<br />









以上实验也验证了基本数据类型只能被"in"修饰，因为基本数据类型是复制一份数值传递，而不是引用传递。如果AIDL接口不需要频繁改变某个参数，我们通过返回值获取结果即可，此时传入参数应该使用"in"标签，避免参数同步带来的性能开销；如果某个参数需要频繁改变，尤其是进行大量追加操作，我们可以使用"out"或"inout"标签，在客户端直接读取原始参数，这种场景下如果使用返回值获取结果将会频繁创建临时变量，降低性能。

参数修改并非实时，远程调用也遵循线程封闭原则，调用开始后外部修改结果不会影响内部，内部修改结果仅在执行完毕的时刻同步。
out只对当前rpc调用过程生效，如果服务端收到请求后新建线程修改变量，此时无效，因为请求线程在新建线程时结束并返回结果，此时新线程中的修改还未开始实施。
使用"out"或"inout"标签修饰自定义类型时，必须为该类添加 `void readFromParcel(Parcel in)` 方法，以便从服务端读取变化后的数据，否则编译过程中将会出错。

以TaskBean类为例， `readFromParcel()` 方法写作：

"TaskBean.java":

```java
public void readFromParcel(Parcel in) {
    id = in.readInt();
    url = in.readString();
    percent = in.readFloat();
}
```

# 同步与异步
AIDL中的接口默认是同步的，这意味着客户端发起指令后，它的调用线程将会持续阻塞，直到服务端方法执行完毕并返回，客户端线程才会恢复并继续执行其他任务。

当客户端线程阻塞时，调用的是Linux系统函数 `wait_event_interruptible()` ，此时线程是休眠状态，不会占用CPU资源。但是客户端通常会从UI线程发起指令，长时间阻塞UI线程将会导致ANR，我们通常会在服务端开启新线程以执行耗时操作，并将结果通过回调方法回传给客户端。

AIDL接口中的方法可以被"oneway"关键字修饰，这种方法将会成为异步方法，客户端发起指令后，它的调用线程不会被阻塞，Binder驱动将使用自身的线程池在服务端执行任务。一个方法被设为"oneway"后，其参数的定向标签只能是"in"，并且返回值只能是"void"，执行结果需要使用回调通知客户端。

"oneway"方法具有队列功能，同一个Binder对象同时只能执行其中的一个"oneway"方法，其他"oneway"方法将在前一个"oneway"方法执行完毕后得到调度。Binder队列中的方法虽然没有开始执行，但是已经申请到了Buffer资源，因此如果某个接口内的异步方法调用频繁且耗时，将会导致缓存溢出与调用失败，此类方法不适合使用"oneway"方式进行异步操作。

> ⚠️ 警告
>
> "oneway"方法只对远程调用有效，如果客户端与服务端在同一个进程中，这种本地调用仍然是同步的，会阻塞客户端线程。

在前文示例中，我们使用新线程实现了下载方法 `addTask()` ，此处我们将其改为异步方法。

首先我们需要修改AIDL接口中的方法定义，在方法前加上"oneway"关键字。

"IDownloadService.aidl":

```java
interface IDownloadService {

    /* 此处省略其他方法 */

    // 添加任务并开始下载
    oneway void addTask(in ItemBean task);
}
```

然后我们修改DownloadService中的方法实现，移除新线程并直接执行耗时操作。

"DownloadService.java":

```java
@Override
public void addTask(ItemBean item) {
    final float TOTAL = 100.0F;
    int length = 0;

    try {
        Log.i(TAG, "开始下载:" + item.getUrl());
        while (length < TOTAL) {
            length += 10;
            // 设置进度并通过回调通知客户端
            item.setPercent((length / TOTAL) * 100);
            callback.onStateChanged(item);
            // 休眠1秒，模拟耗时操作。
            Thread.sleep(1000);
        }
        Log.i(TAG, "下载完成");
    } catch (RemoteException e) {
        Log.e(TAG, "发生远程错误");
    }
}
```

我们将服务端与客户端都安装到测试设备上，使用客户端调用服务端的 `addTask()` 方法，并查看控制台输出信息：

```text
16:17:22.515 27111 27128 I Server-DownloadService: 开始下载: https://test.net/1.txt
16:17:22.515 27072 27091 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=10.0}]

# 此处省略部分输出内容...

16:17:22.515 27072 27091 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=100.0}]
16:17:32.534 27111 27128 I Server-DownloadService: 下载完成。
```

根据上述输出内容可知：

"27072"是客户端的UI线程，当我们点击按钮发起任务后，UI并没有因线程被阻塞而卡住；服务端使用Binder驱动分配的线程"27128"执行耗时操作，并通过客户端注册的回调方法通知客户端任务进度。

# 异常处理
当服务端的操作发生错误时，只有部分类型的异常能够传递给客户端，其他异常将会在服务端进程抛出，然后Binder驱动通告给客户端一个默认返回值，结束方法调用过程。

当远程服务出现不可传递异常时，对于基本数据类型的返回值，客户端将会读到对应的默认值；对于引用数据类型，客户端将会读到空值；对于集合，客户端将会读到内容为空的集合。由此可见，我们在客户端中应当对远程方法的返回值进行空值判断，防止主线程出现NPE而导致界面闪退。

目前远程服务所支持传递的异常类型如下文所示：

- NullPointerException
- BadParcelableException
- IllegalArgumentException
- IllegalStateException
- SecurityException
- NetworkOnMainThreadException
- UnsupportedOperationException
- ServiceSpecificException

Binder通过Parcel容器向客户端传递调用结果时，数据格式为：“异常代码 + 返回内容”，异常代码为"0"表示无错误发生；如果为其他值则代表对应的异常类型，此时就不必再写入返回内容了。

我们在下载服务的 `getPID()` 方法返回之前插入除以0的操作语句，模拟服务端抛出算术异常的场景。

"DownloadService.java":

```java
@Override
public int getPID() {
    // 制造算术异常
    int i = 1 / 0;
    return Process.myPid();
}
```

当我们从客户端连接下载服务并调用该方法时，Binder将会打印"Uncaught remote exception!"日志，同时向客户端返回默认值。

```text
# 服务端进程抛出的异常
16:17:32.534 8043 8061 E JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.ArithmeticException: divide by zero
        at net.bi4vmr.study.base.DownloadService$DownloadStub.getPID(DownloadService.java:43)
        at net.bi4vmr.aidl.IDownloadService$Stub.onTransact(IDownloadService.java:83)
        at android.os.Binder.execTransactInternal(Binder.java:1021)
        at android.os.Binder.execTransact(Binder.java:994)

# 客户端进程读取到了默认值
15:43:36.160 7998 7998 I Client: PID: 0
```

因为本方法的返回值是整形，所以客户端读取到的默认值就是"0"。

如果我们在服务端定义的某些异常类型，其含义与支持远程传递的异常相似，我们就可以利用Java的异常链机制进行转换并传递给客户端，以便客户端进一步处理。

我们修改下载服务的 `getPID()` 方法，将除以0的算术异常捕获，转换为UnsupportedOperationException类型并添加额外信息。

"DownloadService.java":

```java
@Override
public int getPID() {
    // 捕获算术异常
    try {
        int i = 1 / 0;
    } catch (ArithmeticException e) {
        // 转换为受支持的异常类型，并且添加消息。
        throw new UnsupportedOperationException("算术异常", e);
    }
    return Process.myPid();
}
```

此时从客户端调用该方法，并观察日志输出：

```text
16:07:11.324 8173 8173 E AndroidRuntime: FATAL EXCEPTION: main
    Process: net.bi4vmr.study, PID: 8173
    java.lang.UnsupportedOperationException: 算术异常
        at android.os.Parcel.createException(Parcel.java:2083)
        at android.os.Parcel.readException(Parcel.java:2039)
        at android.os.Parcel.readException(Parcel.java:1987)
        at net.bi4vmr.aidl.IDownloadService$Stub$Proxy.getPID(IDownloadService.java:166)
        at net.bi4vmr.study.base.DemoBaseUI.lambda$onCreate$2$net-bi4vmr-study-base-DemoBaseUI(DemoBaseUI.java:70)
        at net.bi4vmr.study.base.DemoBaseUI$$ExternalSyntheticLambda2.onClick(Unknown Source:2)
        at android.view.View.performClick(View.java:7125)
        at com.google.android.material.button.MaterialButton.performClick(MaterialButton.java:1194)
        at android.view.View.performClickInternal(View.java:7102)
        at android.view.View.access$3500(View.java:801)
        at android.view.View$PerformClick.run(View.java:27336)
        at android.os.Handler.handleCallback(Handler.java:883)
        at android.os.Handler.dispatchMessage(Handler.java:100)
        at android.os.Looper.loop(Looper.java:214)
        at android.app.ActivityThread.main(ActivityThread.java:7356)
        at java.lang.reflect.Method.invoke(Native Method)
        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)
        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)
```

我们可以观察到异常链信息无法传递到客户端，但额外信息“算术异常”文本可以传递到客户端，客户端能够根据此消息进一步处理异常。


# 回调接口
AILD接口也能够像本地调用一样使用回调机制，实现异步业务。

我们为下载服务添加一个进度监听器TaskCallback，客户端可以通过注册此监听器获取下载进度的变化。

"TaskCallback.aidl":

```java
package net.bi4vmr.aidl.callback;

// 该路径为对应AIDL文件所在的包
import net.bi4vmr.aidl.bean.ItemBean;

interface TaskCallback {

    // 进度改变事件
    void onStateChanged(in ItemBean item);
}
```

然后在下载服务AIDL接口中添加设置该监听器的方法 `setTaskCallback()` ：

"IDownloadService.aidl":

```java
// 该路径为对应AIDL文件所在的包
import net.bi4vmr.aidl.callback.TaskCallback;

interface IDownloadService {

    /* 此处省略其他方法 */

    // 注册状态回调
    void setTaskCallback(in TaskCallback cb);
}
```

回调接口是一种引用数据类型，因此在其他AIDL文件中使用时需要进行导入，路径为回调接口AIDL文件所在的包名。回调接口中的方法引用类型参数前均有"in"修饰符，因为回调接口是由服务端调用客户端中的接口，此时服务端作为调用者，将变量传递给客户端。

最后我们对下载服务中的Stub类实现进行修改，完成回调方法的相关功能。

"DownloadService.java":

```java
class DownloadStub extends IDownloadService.Stub {

    private static final String TAG = "TestApp-Server-" + DownloadService.class.getSimpleName();

    // 保存所有任务
    private final List<ItemBean> tasks = new CopyOnWriteArrayList<>();
    // 回调接口的实现类，用于向客户端反馈结果。
    private TaskCallback callback;

    @Override
    public int getPID() {
        return Process.myPid();
    }

    @Override
    public void addTask(ItemBean item) {
        tasks.add(item);
        // 创建新线程模拟下载过程
        new Thread(() -> {
            final float TOTAL = 100.0F;
            int length = 0;

            try {
                Log.i(TAG, "开始下载:" + item.getUrl());
                while (length < TOTAL) {
                    length += 10;
                    // 设置进度并通过回调通知客户端
                    item.setPercent((length / TOTAL) * 100);
                    callback.onStateChanged(item);
                    // 休眠1秒，模拟耗时操作。
                    Thread.sleep(1000);
                }
                Log.i(TAG, "下载完成。");
            } catch (InterruptedException e) {
                Log.w(TAG, "任务终止。");
            } catch (RemoteException e) {
                Log.e(TAG, "发生远程错误！");
            }
        }).start();
    }

    @Override
    public List<ItemBean> getTasks() {
        return tasks;
    }

    @Override
    public void setTaskCallback(TaskCallback cb) {
        callback = cb;
    }
}
```

此时服务端准备完成，我们在客户端连接服务成功的回调方法中，注册下载进度监听器：

```java
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    IDownloadService.Stub downloadService = IDownloadService.Stub.asInterface(service);
    // 设置回调以监听服务端的事件
    try {
        downloadService.setTaskCallback(new TaskCallback.Stub() {
            @Override
            public void onStateChanged(ItemBean item) {
                Log.i(TAG, "OnStateChanged. Item:[" + item + "]");
            }
        });
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
```

当我们调用 `addTask()` 方法添加下载任务后，可以从控制台看到进度改变回调方法每隔1秒被触发一次，且对应的ItemBean从服务端被传递到客户端。

```text
14:43:01.891  3773  3773 I Client-TestUIBase: --- 绑定服务 ---
14:43:02.300  3773  3773 I Client-TestUIBase: 连接已就绪。
14:43:04.154  3773  3773 I Client-TestUIBase: --- 添加任务 ---
14:43:04.157  3804  3819 I Server-DownloadService: 开始下载: https://test.net/1.txt
14:43:04.158  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=10.0}]
14:43:05.162  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=20.0}]
14:43:06.165  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=30.0}]
14:43:07.167  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=40.0}]
14:43:08.169  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=50.0}]
14:43:09.171  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=60.0}]
14:43:10.172  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=70.0}]
14:43:11.174  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=80.0}]
14:43:12.176  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=90.0}]
14:43:13.177  3773  3788 I Client-TestUIBase: OnStateChanged. Item:[ItemBean{id=0, url='https://test.net/1.txt', percent=100.0}]
14:43:14.179  3804  3819 I Server-DownloadService: 下载完成。
```


# 文件传输
AIDL接口有数据容量限制，因此不能传输大量数据，有时我们需要跨进程传输文件，可以使用PFD，PFD是一个指向文件的指针，可以跨进程传输，当他传递给远程进程后，远程进程可以通过此标识符读写文件内容。

不管是上传还是下载，都建议客户端提供pfd，，并且服务端同步因为客户端调用后阻塞，服务端读取完毕接口返回，客户端自动释放pfd，不需要额外的接口控制pfd释放，实现简单

如果希望服务端不会因为单个任务开始导致其他任务等待，就需要通过回调、任务结束通知等机制， 告知客户端关闭PFD
