# 简介
Service是Android系统中的一种组件，用于实现需要长期运行或与多个界面交互的任务，例如：播放音乐、下载文件等操作。如果我们在Activity中开启异步任务，一旦Activity被关闭，这个任务就无法再被控制了，执行结果也无法反馈给用户，此类场景就比较适合使用Service进行任务管理。

Service是一种持有Context的消息服务，我们可以在Service中执行创建广播接收器、启动Activity等操作。Service默认使用应用程序的主线程执行代码，为了避免应用程序发生ANR，开发者应当开启新线程来执行耗时操作。

Service可以作为独立进程运行，实现业务解耦，例如：音乐播放器UI进程意外崩溃不会中断播放进程，这提升了用户体验。Service也可以实现跨应用程序的RPC，是应用程序之间、应用程序与系统交互的主要方案之一。


# 服务类型
## 用户界面
根据Service的界面外观，我们可以将Service分为以下两种类型：

🔷 前台服务

前台服务运行时，将会在通知栏显示一条不可移除的通知，以引起用户的注意；当服务终止后通知也将随之消失。

此类服务的典型应用为：音乐播放器、下载管理器等。

🔷 后台服务

后台服务不与用户直接交互，也不会在通知栏产生视觉上的提醒。

此类服务的典型应用为：天气更新、数据同步程序等。

## 启动方式
根据服务被启动的方式，我们可以将Service分为以下两种类型：

🔶 启动服务

外部组件可以通过 `startService()` 方法启动一个服务，此时外部组件不会与服务进行通信，只是单向地、一次性地唤起服务。典型的应用场景为：系统重启后，通过 `startService()` 方法启动音乐播放服务恢复播放先前的音乐。

服务被启动后会在后台持续运行，除非其自行关闭（任务完成）或系统因内存不足将其回收。

🔶 绑定服务

外部组件可以通过 `bindService()` 方法启动一个服务，此时外部组件可以与服务进行IPC交互。典型的应用场景为：用户打开音乐播放器界面，通过 `bindService()` 方法绑定音乐播放服务，随后即可查看音乐信息、发出播放与暂停指令。

服务被绑定后会在后台持续运行，当所有外部组件与之解除绑定，或系统因内存不足将其回收，服务将会终止运行。

<br />

上述两种启动方式对应Service的不同生命周期，一个Service可以同时支持这两种方式，具体实现取决于服务的实际用途。


# 版本变更
## 索引

<div align="center">

|       序号        |    版本    |               摘要               |
| :---------------: | :--------: | :------------------------------: |
| [变更一](#变更一) | Android 8  |      新增对于启动服务的限制      |
| [变更二](#变更二) | Android 9  |       前台服务需要声明权限       |
| [变更三](#变更三) | Android 11 | 连接外部服务需要声明软件包可见性 |

</div>

## 变更一
### 摘要
自从Android 8开始，系统新增对于启动服务的限制。

### 详情
自从Android 8开始，应用程序不允许启动处于非活跃状态软件包中的后台服务。如果程序A已经切换至后台（或者该程序没有Activity、从未被运行过。），此时程序B通过 `startService()` 方法启动程序A中的Service，系统就会抛出异常。

如果程序A的Service是前台服务，程序B可以通过 `startForegroundService()` 方法启动该Service，但Service必须在被启动的5秒内执行 `startForeground()` 方法绑定一条通知，否则系统认为该Service不是前台服务，就会抛出异常。

该限制条件仅限由启动方式启动的服务，不会影响通过绑定方式启动的服务。

## 变更二
### 摘要
自从Android 9开始，使用前台服务需要声明权限。

### 详情
自从Android 9开始，若应用程序需要使用前台服务显示通知，则需要在Manifest文件中声明以下权限：

"AndroidManifest.xml":

```xml
<manifest>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
</manifest>
```

这是一个普通权限，通常只需要声明即可正常使用。

## 变更三
### 摘要
自从Android 11开始，当前应用程序连接其他应用程序的服务需要声明软件包可见性。

### 详情
自从Android 11开始，应用程序如果需要与外部组件交互，则需要在Manifest文件中进行声明。

当应用程序需要调用外部软件包中的服务时，我们需要在 `<manifest>` 标签内添加以下配置：

"AndroidManifest.xml":

```xml
<manifest>
    <queries>
        <package android:name="<目标服务所在软件包的包名>" />
    </queries>
</manifest>
```
