# AndroidX

Android SDK随Android系统发布版本，发布周期较长，不利于功能扩展，

Android Support Library

android.support.v4 表示该扩展包最低支持的版本为API 4，android.support.v7表示该扩展包最低支持的版本为API 7，


API 4与API 7淘汰了， Android Support Library这种方式不合适了，新的扩展包名为androidx，androidx.*包下面的API都是随着扩展库发布的，这些API基本不会依赖于操作系统的具体版本。



android.support.constraint

androidx.constraintlayout.widget


android.support.annotation

androidx.annotation



android.support.v7.widget.RecyclerView

androidx.recyclerview.widget.RecyclerView


# Service - 连接检测


目标应用升级时， [bindService] 方法可能返回 `true` 但后续系统未回调ServiceConnection接口，此时客户端无法得知绑定是否
成功，因此客户端需要在一段时间后检查连接状态，如果连接未建立则再次尝试绑定。


远程服务断开

由于远程服务对于客户端来说是不可控的，我们在使用远程服务期间也需要监听远程的状态，Binder提供主动和被动获取远程服务可用状态的方法：

    主动判断

boolean alive = myService.isBinderAlive();

    被动回调

private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient(){

    @Override
    public void binderDied(){
        // 这里运行在客户端Binder线程池
        if(myService==null) return;
        myService.asBinder().unlinkToDeath(mDeathRecipient, 0);
        myService = null;
    }
}

// 然后在服务连接成功时使用
ServiceConnection connection=new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        myService=IErrorService.Stub.asInterface(service);
        service.linkToDeath(mDeathRecipient, 0);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        // 服务端意外断开时调用，客户端主动断开不会调用
        // 这里运行在客户端UI线程，可以尝试重新连接服务
        myService=null;
    }
};



# 自定义View
## 系统回调

https://picx.zhimg.com/v2-48790e1e7779f671caf3f4e8cf4c93c5_1440w.jpg


## 刷新方法
requestLayout() 、invalidate()、postInvalidate()

requestLayout(): 当view确定自身已经不再适合现有的区域时，该view本身调用requestLayout()方法来要求parent view（父类的视图）重新调用他的measure和layout来重新设置自己位置。特别是当view的layoutparameter发生改变，并且它的值还没能应用到view上时，这时候适合调用这个方法。注意，并不会不执行ondraw。

invalidate
()、postInvalidate()： 调用invalidate()、postInvalidate()会 界面刷新，执行 draw 过程。区别就是Invalidate不能直接在线程中调用，因为他是违背了单线程模型：Android UI操作并不是线程安全的，并且这些操作必须在UI线程

中调用。

鉴于此，如果要使用invalidate的刷新，那我们就得配合handler的使用，使异步非ui线程转到ui线程中调用，如果要在非ui线程中直接使用就调用postInvalidate方法即可，这样就省去使用handler的烦恼。

## 绘图
Rect ： 定义矩形区域，创建时需要指定在控件区域内的四个顶点，可以通过CenterX、CenterY获取中心点坐标。
RectF：Rect是基于Int类型的，RectF是Float类型，其他功能不变。


Paint: 画笔，控制颜色、描边、渐变效果等样式

Canvas:画布，可供绘制图形的区域，提供绘制矩形、绘制圆形等方法，需要结合Rect、Paint决定最终生成的图形。

Path: 描述一根或一组线段，可以绘制直线、曲线或指定剪裁形状。



# ObjectAnim

duration表示持续时间，用于控制动画速度，1000表示1秒播放完毕，时长增加动画变慢，时长减少动画加快。

时长不能设置负值，会报错：
java.lang.IllegalArgumentException: Animators cannot have negative duration: -1000

duration可以动态更改，但直接修改会导致动画进度跳变，不连贯，如果需要连贯需要计算新时间对应的进度并进行设置：

```text
            animator?.let {
                val currentPlayTime = it.currentPlayTime // 获取当前播放时间
                val progress = currentPlayTime.toFloat() / it.duration // 计算当前进度
                it.duration = value // 设置新的持续时间
                it.setCurrentPlayTime((progress * value).toLong()) // 根据新持续时间设置进度
            }
```




# Jacoco

覆盖率检测只能判断代码是否被执行，测试用例执行失败、测试用例不合理等情况无能为例，不能盲目根据覆盖率判断单元测试的完整性。

Android的Jacoco版本与AGP绑定，使用配置项是无意义的



# CrossWindowBlur API

Android 12开始提供，可以提取当前窗口底部的内容并生成模糊效果，自动实时更新。

限制：

- 获取到的Drawable必须设置在底层View的背景上，因此如果需要显示带有颜色的遮罩效果，遮罩必须在Blur Drawable控件的上层，否则会被覆盖。
- 同一Blur区域只能设置一个模糊半径，因此使用模糊背景的多个控件不可重叠，否则重叠区域实际模糊半径是不确定的，与UI设计预期不符。


# 注解
@MainThread
标记该方法需要在主线程调用，非强制，不会检查并阻断。



# PopupWindow
AlertDialog：以“对话框”语义居中/固定区域显示，通常不依赖某个控件作为锚点。
PopupWindow：以某个 View 为锚点显示（如 showAsDropDown / showAtLocation），适合做下拉菜单、气泡提示。




PopupWindow ()	// 创建一个空的PopupWindow

PopupWindow (View contentView)	

PopupWindow (int width, 
                int height)

PopupWindow (View contentView, 	// PopupWindow的内容View, 相当于setContentView
                int width, 	// 宽, 相当于setwidth()
                int height,  // 高, 相当于setHeight
                boolean focusable) // 是否可获取焦点, 相当于setFocusable()


PopupWindow需要设置宽高和View
创建时需要指定宽高，View 根布局的layoutwidth/layoutheight属性无效。


相对于锚点View的位置

window.setOverlapAnchor(true)

是否允许覆盖锚点View，默认 false。
未覆盖状态默认与锚点View左侧下方对齐，覆盖状态则从锚点View左侧顶部开始显示。


window.showAsDropDown(v)

以View v 作为锚点显示PopupWindow，默认左下角对齐。

window.showAsDropDown(v,100,100);

左下角对齐并额外偏移x和y像素


window.showAsDropDown(v,0,0,Gravity.END)

右下角对齐

只能填写END/START/其他数值是无效的。


相对于当前窗口

window.showAtLocation(v, Gravity.END, 0, 0)

在v所在窗口显示PopupWindow，位置由Gravity参数决定。

offset与Gravity相关

Gravity.Start
offsetX 为正向右偏移

Gravity.END
offsetX 为正向左偏移

NO_GRAVITY等同于Gravity.TOP | Gravity.START

offset最多与屏幕对齐，更大的值是无效的，弹窗不会超出屏幕边界。






void setOutsideTouchable (boolean touchable) // 设置外部是否可被点击
boolean isOutsideTouchable () 


可获取焦点
一般控件都不需要焦点. 但是输入框EditText需要先获取焦点才能输入. 最重要的是当PopupWindow可获取焦点时按下手机返回键将不会销毁当前Activity而是关闭当前PopupWindow. 所以我们一般还是设置为true. 更加符合用户操作逻辑. 该方法为true时同时拥有setOutsideTouchable(true)的作用.


弹出后更新位置
window.update(v, 200, ViewGroup.LayoutParams.WRAP_CONTENT);


# 媒体 - 图像 - Bitmap

不要缓存Drawable，部分Drawable内部实现会缓存Context的实例的Resource和Theme等信息，缓存它们会导致Activity销毁后无法被回收、主题变更后图像未跟随主题切换等，应当缓存Bitmap。

