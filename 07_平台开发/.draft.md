# AndroidX

Android SDK随Android系统发布版本，发布周期较长，不利于功能扩展，

Android Support Library

android.support.v4 表示该扩展包最低支持的版本为API 4，android.support.v7表示该扩展包最低支持的版本为API 7，


API 4与API 7淘汰了， Android Support Library这种方式不合适了，新的扩展包名为androidx，androidx.*包下面的API都是随着扩展库发布的，这些API基本不会依赖于操作系统的具体版本。



android.support.constraint

androidx.constraintlayout.widget


android.support.annotation

androidx.annotation



android.support.v7.widget.RecyclerView

androidx.recyclerview.widget.RecyclerView


# 协程测试



JVM环境默认没有 `Dispatchers.Main` 调度器，如果测试部分包含UI组件可能会出现错误，此时我们需要添加测试库，并指定一个调度器

testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.8.1")


    private val testDispatcher = StandardTestDispatcher()

    @Before
    fun setup() {
        /* 构建模拟环境 */
        Dispatchers.setMain(testDispatcher)
    }
    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
    @Test
    fun test_Env() = runTest {
        // 运行协程代码
    }


测试协程等待Main调度器任务执行后再继续执行，适合测试线程等待其他线程异步更新后再执行断言。
testDispatcher.scheduler.advanceUntilIdle()


# Service - 连接检测


目标应用升级时， [bindService] 方法可能返回 `true` 但后续系统未回调ServiceConnection接口，此时客户端无法得知绑定是否
成功，因此客户端需要在一段时间后检查连接状态，如果连接未建立则再次尝试绑定。


远程服务断开

由于远程服务对于客户端来说是不可控的，我们在使用远程服务期间也需要监听远程的状态，Binder提供主动和被动获取远程服务可用状态的方法：

    主动判断

boolean alive = myService.isBinderAlive();

    被动回调

private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient(){

    @Override
    public void binderDied(){
        // 这里运行在客户端Binder线程池
        if(myService==null) return;
        myService.asBinder().unlinkToDeath(mDeathRecipient, 0);
        myService = null;
    }
}

// 然后在服务连接成功时使用
ServiceConnection connection=new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        myService=IErrorService.Stub.asInterface(service);
        service.linkToDeath(mDeathRecipient, 0);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        // 服务端意外断开时调用，客户端主动断开不会调用
        // 这里运行在客户端UI线程，可以尝试重新连接服务
        myService=null;
    }
};


# 系统信息

appendLog("BRAND！\n"+ Build.BRAND);
appendLog("ID！\n"+ Build.ID);
appendLog("MODEL！\n"+ Build.MODEL);


# 自定义View
## 系统回调

https://picx.zhimg.com/v2-48790e1e7779f671caf3f4e8cf4c93c5_1440w.jpg


## 刷新方法
requestLayout() 、invalidate()、postInvalidate()

requestLayout(): 当view确定自身已经不再适合现有的区域时，该view本身调用requestLayout()方法来要求parent view（父类的视图）重新调用他的measure和layout来重新设置自己位置。特别是当view的layoutparameter发生改变，并且它的值还没能应用到view上时，这时候适合调用这个方法。注意，并不会不执行ondraw。

invalidate
()、postInvalidate()： 调用invalidate()、postInvalidate()会 界面刷新，执行 draw 过程。区别就是Invalidate不能直接在线程中调用，因为他是违背了单线程模型：Android UI操作并不是线程安全的，并且这些操作必须在UI线程

中调用。

鉴于此，如果要使用invalidate的刷新，那我们就得配合handler的使用，使异步非ui线程转到ui线程中调用，如果要在非ui线程中直接使用就调用postInvalidate方法即可，这样就省去使用handler的烦恼。

## 绘图
Rect ： 定义矩形区域，创建时需要指定在控件区域内的四个顶点，可以通过CenterX、CenterY获取中心点坐标。
RectF：Rect是基于Int类型的，RectF是Float类型，其他功能不变。


Paint: 画笔，控制颜色、描边、渐变效果等样式

Canvas:画布，可供绘制图形的区域，提供绘制矩形、绘制圆形等方法，需要结合Rect、Paint决定最终生成的图形。

Path: 描述一根或一组线段，可以绘制直线、曲线或指定剪裁形状。



# ObjectAnim

duration表示持续时间，用于控制动画速度，1000表示1秒播放完毕，时长增加动画变慢，时长减少动画加快。

时长不能设置负值，会报错：
java.lang.IllegalArgumentException: Animators cannot have negative duration: -1000

duration可以动态更改，但直接修改会导致动画进度跳变，不连贯，如果需要连贯需要计算新时间对应的进度并进行设置：

```text
            animator?.let {
                val currentPlayTime = it.currentPlayTime // 获取当前播放时间
                val progress = currentPlayTime.toFloat() / it.duration // 计算当前进度
                it.duration = value // 设置新的持续时间
                it.setCurrentPlayTime((progress * value).toLong()) // 根据新持续时间设置进度
            }
```




# Jacoco

覆盖率检测只能判断代码是否被执行，测试用例执行失败、测试用例不合理等情况无能为例，不能盲目根据覆盖率判断单元测试的完整性。


# Absent Code Exception

Absent Code attribute in method that is not native or abstract in class file android/car/CarProjectionManager
java.lang.ClassFormatError: Absent Code attribute in method that is not native or abstract in class file android/car/CarProjectionManager
	at java.base/java.lang.ClassLoader.defineClass1(Native Method)
	at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1017)
	at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150)
	at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862)
	at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681)
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639)
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:525)


该类是通过Jar包引入的，其中构造方法没有调用 `super()` 、 普通方法没有返回值，因为Jar已被编译为字节码，因此引用它们时不会再次编译，编译器也不会提示我们错误，直到运行时缺少部分指令才会抛出异常。

```java
public final class CarProjectionManager extends CarManagerBase {

    public CarProjectionManager(Car car, IBinder service) {
        // 此处应当有 `super(car)` 语句
    }

    public boolean requestBluetoothProfileInhibit(BluetoothDevice device, int profile) {
        // 此处应当有 `return` 语句
    }

    public boolean releaseBluetoothProfileInhibit(BluetoothDevice device, int profile) {
        // 此处应当有 `return` 语句
    }
}
```

# Robolector
定制API

原版运行环境只支持标准API，如果需要一些自定义的API，有两种方法：

新增API与SDK未重名：例如新增了VehicleConfigManager，标准SDK里没有这个类，如果是JAR引入可以直接testImpletion打包到测试组件，或者在测试set中创建空实现。

新增API与SDK重名：需要将Robolector改为离线模式，并修改运行环境，解压、将新增API的Class合并，替换原有CLass，再使用jar cf aaa.jar ./ 命令或压缩软件（关闭压缩）重新打JAR包。

首先以在线模式运行一次，使得Robo下载原版运行环境组件。

/home/bi4vmr/.m2/repository/org/robolectric/android-all-instrumented/13-robolectric-9030017-i7/

使用jar或压缩工具解压，添加、删除或替换要修改的Class文件。

重新打包并放在offline目录
jar cf android-all-instrumented-13-robolectric-9030017-i7-pateo.jar -C android-all-instrumented-13-robolectric-9030017-i7/ ./


test sourceset不会打包，所以其中的类无法加入运行环境，我们可以单独建立模块，将编译后的aar作为testRuntimeonly使用。
